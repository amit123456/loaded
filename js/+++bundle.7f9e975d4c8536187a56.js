! function(t) {
    function e(n) {
        if (i[n]) return i[n].exports;
        var r = i[n] = {
            i: n,
            l: !1,
            exports: {}
        };
        return t[n].call(r.exports, r, r.exports, e), r.l = !0, r.exports
    }
    var i = {};
    e.m = t, e.c = i, e.d = function(t, i, n) {
        e.o(t, i) || Object.defineProperty(t, i, {
            configurable: !1,
            enumerable: !0,
            get: n
        })
    }, e.n = function(t) {
        var i = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return e.d(i, "a", i), i
    }, e.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, e.p = "", e(e.s = 11)
}([function(t, e, i) {
    "use strict";

    function n() {}

    function r(t, e) {
        this.x = t || 0, this.y = e || 0
    }

    function s(t, e, i, n, a, o, h, l, c, u) {
        Object.defineProperty(this, "id", {
            value: Io++
        }), this.uuid = Oo.generateUUID(), this.name = "", this.image = void 0 !== t ? t : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : s.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : Sa, this.wrapT = void 0 !== n ? n : Sa, this.magFilter = void 0 !== a ? a : La, this.minFilter = void 0 !== o ? o : Ia, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== h ? h : Ya, this.type = void 0 !== l ? l : Da, this.offset = new r(0, 0), this.repeat = new r(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : wo, this.version = 0, this.onUpdate = null
    }

    function a(t, e, i, n) {
        this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
    }

    function o(t, e, i) {
        this.uuid = Oo.generateUUID(), this.width = t, this.height = e, this.scissor = new a(0, 0, t, e), this.scissorTest = !1, this.viewport = new a(0, 0, t, e), i = i || {}, void 0 === i.minFilter && (i.minFilter = La), this.texture = new s(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }

    function h(t, e, i) {
        o.call(this, t, e, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
    }

    function l(t, e, i, n) {
        this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
    }

    function c(t, e, i) {
        this.x = t || 0, this.y = e || 0, this.z = i || 0
    }

    function u() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function d(t, e, i, n, r, a, o, h, l, c, u, d) {
        s.call(this, null, a, o, h, l, c, n, r, u, d), this.image = {
            data: t,
            width: e,
            height: i
        }, this.magFilter = void 0 !== l ? l : Pa, this.minFilter = void 0 !== c ? c : Pa, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }

    function p(t, e, i, n, r, a, o, h, l, c) {
        t = void 0 !== t ? t : [], e = void 0 !== e ? e : ya, s.call(this, t, e, i, n, r, a, o, h, l, c), this.flipY = !1
    }

    function f() {
        this.seq = [], this.map = {}
    }

    function m(t, e, i) {
        var n = t[0];
        if (n <= 0 || n > 0) return t;
        var r = e * i,
            s = Uo[r];
        if (void 0 === s && (s = new Float32Array(r), Uo[r] = s), 0 !== e) {
            n.toArray(s, 0);
            for (var a = 1, o = 0; a !== e; ++a) o += i, t[a].toArray(s, o)
        }
        return s
    }

    function v(t, e) {
        var i = No[e];
        void 0 === i && (i = new Int32Array(e), No[e] = i);
        for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
        return i
    }

    function g(t, e) {
        t.uniform1f(this.addr, e)
    }

    function y(t, e) {
        t.uniform1i(this.addr, e)
    }

    function _(t, e) {
        void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
    }

    function x(t, e) {
        void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
    }

    function b(t, e) {
        void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
    }

    function w(t, e) {
        t.uniformMatrix2fv(this.addr, !1, e.elements || e)
    }

    function T(t, e) {
        void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : (Fo.set(e.elements), t.uniformMatrix3fv(this.addr, !1, Fo))
    }

    function M(t, e) {
        void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : (ko.set(e.elements), t.uniformMatrix4fv(this.addr, !1, ko))
    }

    function E(t, e, i) {
        var n = i.allocTextureUnit();
        t.uniform1i(this.addr, n), i.setTexture2D(e || Do, n)
    }

    function S(t, e, i) {
        var n = i.allocTextureUnit();
        t.uniform1i(this.addr, n), i.setTextureCube(e || zo, n)
    }

    function A(t, e) {
        t.uniform2iv(this.addr, e)
    }

    function P(t, e) {
        t.uniform3iv(this.addr, e)
    }

    function R(t, e) {
        t.uniform4iv(this.addr, e)
    }

    function C(t) {
        switch (t) {
            case 5126:
                return g;
            case 35664:
                return _;
            case 35665:
                return x;
            case 35666:
                return b;
            case 35674:
                return w;
            case 35675:
                return T;
            case 35676:
                return M;
            case 35678:
            case 36198:
                return E;
            case 35680:
                return S;
            case 5124:
            case 35670:
                return y;
            case 35667:
            case 35671:
                return A;
            case 35668:
            case 35672:
                return P;
            case 35669:
            case 35673:
                return R
        }
    }

    function L(t, e) {
        t.uniform1fv(this.addr, e)
    }

    function O(t, e) {
        t.uniform1iv(this.addr, e)
    }

    function I(t, e) {
        t.uniform2fv(this.addr, m(e, this.size, 2))
    }

    function D(t, e) {
        t.uniform3fv(this.addr, m(e, this.size, 3))
    }

    function z(t, e) {
        t.uniform4fv(this.addr, m(e, this.size, 4))
    }

    function U(t, e) {
        t.uniformMatrix2fv(this.addr, !1, m(e, this.size, 4))
    }

    function N(t, e) {
        t.uniformMatrix3fv(this.addr, !1, m(e, this.size, 9))
    }

    function k(t, e) {
        t.uniformMatrix4fv(this.addr, !1, m(e, this.size, 16))
    }

    function F(t, e, i) {
        var n = e.length,
            r = v(i, n);
        t.uniform1iv(this.addr, r);
        for (var s = 0; s !== n; ++s) i.setTexture2D(e[s] || Do, r[s])
    }

    function B(t, e, i) {
        var n = e.length,
            r = v(i, n);
        t.uniform1iv(this.addr, r);
        for (var s = 0; s !== n; ++s) i.setTextureCube(e[s] || zo, r[s])
    }

    function G(t) {
        switch (t) {
            case 5126:
                return L;
            case 35664:
                return I;
            case 35665:
                return D;
            case 35666:
                return z;
            case 35674:
                return U;
            case 35675:
                return N;
            case 35676:
                return k;
            case 35678:
                return F;
            case 35680:
                return B;
            case 5124:
            case 35670:
                return O;
            case 35667:
            case 35671:
                return A;
            case 35668:
            case 35672:
                return P;
            case 35669:
            case 35673:
                return R
        }
    }

    function H(t, e, i) {
        this.id = t, this.addr = i, this.setValue = C(e.type)
    }

    function j(t, e, i) {
        this.id = t, this.addr = i, this.size = e.size, this.setValue = G(e.type)
    }

    function V(t) {
        this.id = t, f.call(this)
    }

    function W(t, e) {
        t.seq.push(e), t.map[e.id] = e
    }

    function X(t, e, i) {
        var n = t.name,
            r = n.length;
        for (Bo.lastIndex = 0;;) {
            var s = Bo.exec(n),
                a = Bo.lastIndex,
                o = s[1],
                h = "]" === s[2],
                l = s[3];
            if (h && (o |= 0), void 0 === l || "[" === l && a + 2 === r) {
                W(i, void 0 === l ? new H(o, t, e) : new j(o, t, e));
                break
            }
            var c = i.map,
                u = c[o];
            void 0 === u && (u = new V(o), W(i, u)), i = u
        }
    }

    function q(t, e, i) {
        f.call(this), this.renderer = i;
        for (var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r < n; ++r) {
            var s = t.getActiveUniform(e, r),
                a = s.name;
            X(s, t.getUniformLocation(e, a), this)
        }
    }

    function Y(t, e, i) {
        return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
    }

    function Z(t, e) {
        this.min = void 0 !== t ? t : new r(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new r(-1 / 0, -1 / 0)
    }

    function $(t, e, i, n, s) {
        function a() {
            var t = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                n = new Uint16Array([0, 1, 2, 0, 2, 3]);
            h = e.createBuffer(), l = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, h), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, l), e.bufferData(e.ELEMENT_ARRAY_BUFFER, n, e.STATIC_DRAW), m = e.createTexture(), v = e.createTexture(), i.bindTexture(e.TEXTURE_2D, m), e.texImage2D(e.TEXTURE_2D, 0, e.RGB, 16, 16, 0, e.RGB, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), i.bindTexture(e.TEXTURE_2D, v), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 16, 16, 0, e.RGBA, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), u = {
                vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
            }, d = o(u), p = {
                vertex: e.getAttribLocation(d, "position"),
                uv: e.getAttribLocation(d, "uv")
            }, f = {
                renderType: e.getUniformLocation(d, "renderType"),
                map: e.getUniformLocation(d, "map"),
                occlusionMap: e.getUniformLocation(d, "occlusionMap"),
                opacity: e.getUniformLocation(d, "opacity"),
                color: e.getUniformLocation(d, "color"),
                scale: e.getUniformLocation(d, "scale"),
                rotation: e.getUniformLocation(d, "rotation"),
                screenPosition: e.getUniformLocation(d, "screenPosition")
            }
        }

        function o(t) {
            var i = e.createProgram(),
                n = e.createShader(e.FRAGMENT_SHADER),
                r = e.createShader(e.VERTEX_SHADER),
                a = "precision " + s.precision + " float;\n";
            return e.shaderSource(n, a + t.fragmentShader), e.shaderSource(r, a + t.vertexShader), e.compileShader(n), e.compileShader(r), e.attachShader(i, n), e.attachShader(i, r), e.linkProgram(i), i
        }
        var h, l, u, d, p, f, m, v;
        this.render = function(t, s, o, u) {
            if (0 !== t.length) {
                var g = new c,
                    y = u.w / u.z,
                    _ = .5 * u.z,
                    x = .5 * u.w,
                    b = 16 / u.w,
                    w = new r(b * y, b),
                    T = new c(1, 1, 0),
                    M = new r(1, 1),
                    E = new Z;
                E.min.set(u.x, u.y), E.max.set(u.x + (u.z - 16), u.y + (u.w - 16)), void 0 === d && a(), i.useProgram(d), i.initAttributes(), i.enableAttribute(p.vertex), i.enableAttribute(p.uv), i.disableUnusedAttributes(), e.uniform1i(f.occlusionMap, 0), e.uniform1i(f.map, 1), e.bindBuffer(e.ARRAY_BUFFER, h), e.vertexAttribPointer(p.vertex, 2, e.FLOAT, !1, 16, 0), e.vertexAttribPointer(p.uv, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, l), i.disable(e.CULL_FACE), i.buffers.depth.setMask(!1);
                for (var S = 0, A = t.length; S < A; S++) {
                    b = 16 / u.w, w.set(b * y, b);
                    var P = t[S];
                    if (g.set(P.matrixWorld.elements[12], P.matrixWorld.elements[13], P.matrixWorld.elements[14]), g.applyMatrix4(o.matrixWorldInverse), g.applyMatrix4(o.projectionMatrix), T.copy(g), M.x = u.x + T.x * _ + _ - 8, M.y = u.y + T.y * x + x - 8, !0 === E.containsPoint(M)) {
                        i.activeTexture(e.TEXTURE0), i.bindTexture(e.TEXTURE_2D, null), i.activeTexture(e.TEXTURE1), i.bindTexture(e.TEXTURE_2D, m), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGB, M.x, M.y, 16, 16, 0), e.uniform1i(f.renderType, 0), e.uniform2f(f.scale, w.x, w.y), e.uniform3f(f.screenPosition, T.x, T.y, T.z), i.disable(e.BLEND), i.enable(e.DEPTH_TEST), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), i.activeTexture(e.TEXTURE0), i.bindTexture(e.TEXTURE_2D, v), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, M.x, M.y, 16, 16, 0), e.uniform1i(f.renderType, 1), i.disable(e.DEPTH_TEST), i.activeTexture(e.TEXTURE1), i.bindTexture(e.TEXTURE_2D, m), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), P.positionScreen.copy(T), P.customUpdateCallback ? P.customUpdateCallback(P) : P.updateLensFlares(), e.uniform1i(f.renderType, 2), i.enable(e.BLEND);
                        for (var R = 0, C = P.lensFlares.length; R < C; R++) {
                            var L = P.lensFlares[R];
                            L.opacity > .001 && L.scale > .001 && (T.x = L.x, T.y = L.y, T.z = L.z, b = L.size * L.scale / u.w, w.x = b * y, w.y = b, e.uniform3f(f.screenPosition, T.x, T.y, T.z), e.uniform2f(f.scale, w.x, w.y), e.uniform1f(f.rotation, L.rotation), e.uniform1f(f.opacity, L.opacity), e.uniform3f(f.color, L.color.r, L.color.g, L.color.b), i.setBlending(L.blending, L.blendEquation, L.blendSrc, L.blendDst), n.setTexture2D(L.texture, 1), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0))
                        }
                    }
                }
                i.enable(e.CULL_FACE), i.enable(e.DEPTH_TEST), i.buffers.depth.setMask(!0), i.reset()
            }
        }
    }

    function Q(t, e, i, n, r, a, o, h, l) {
        s.call(this, t, e, i, n, r, a, o, h, l), this.needsUpdate = !0
    }

    function J(t, e, i, n, r) {
        function s() {
            var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                i = new Uint16Array([0, 1, 2, 0, 2, 3]);
            h = e.createBuffer(), u = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, h), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, u), e.bufferData(e.ELEMENT_ARRAY_BUFFER, i, e.STATIC_DRAW), d = a(), p = {
                position: e.getAttribLocation(d, "position"),
                uv: e.getAttribLocation(d, "uv")
            }, f = {
                uvOffset: e.getUniformLocation(d, "uvOffset"),
                uvScale: e.getUniformLocation(d, "uvScale"),
                rotation: e.getUniformLocation(d, "rotation"),
                scale: e.getUniformLocation(d, "scale"),
                color: e.getUniformLocation(d, "color"),
                map: e.getUniformLocation(d, "map"),
                opacity: e.getUniformLocation(d, "opacity"),
                modelViewMatrix: e.getUniformLocation(d, "modelViewMatrix"),
                projectionMatrix: e.getUniformLocation(d, "projectionMatrix"),
                fogType: e.getUniformLocation(d, "fogType"),
                fogDensity: e.getUniformLocation(d, "fogDensity"),
                fogNear: e.getUniformLocation(d, "fogNear"),
                fogFar: e.getUniformLocation(d, "fogFar"),
                fogColor: e.getUniformLocation(d, "fogColor"),
                alphaTest: e.getUniformLocation(d, "alphaTest")
            };
            var n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            n.width = 8, n.height = 8;
            var r = n.getContext("2d");
            r.fillStyle = "white", r.fillRect(0, 0, 8, 8), m = new Q(n)
        }

        function a() {
            var t = e.createProgram(),
                i = e.createShader(e.VERTEX_SHADER),
                n = e.createShader(e.FRAGMENT_SHADER);
            return e.shaderSource(i, ["precision " + r.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")), e.shaderSource(n, ["precision " + r.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")), e.compileShader(i), e.compileShader(n), e.attachShader(t, i), e.attachShader(t, n), e.linkProgram(t), t
        }

        function o(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
        }
        var h, u, d, p, f, m, v = new c,
            g = new l,
            y = new c;
        this.render = function(r, a, l) {
            if (0 !== r.length) {
                void 0 === d && s(), i.useProgram(d), i.initAttributes(), i.enableAttribute(p.position), i.enableAttribute(p.uv), i.disableUnusedAttributes(), i.disable(e.CULL_FACE), i.enable(e.BLEND), e.bindBuffer(e.ARRAY_BUFFER, h), e.vertexAttribPointer(p.position, 2, e.FLOAT, !1, 16, 0), e.vertexAttribPointer(p.uv, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, u), e.uniformMatrix4fv(f.projectionMatrix, !1, l.projectionMatrix.elements), i.activeTexture(e.TEXTURE0), e.uniform1i(f.map, 0);
                var c = 0,
                    _ = 0,
                    x = a.fog;
                x ? (e.uniform3f(f.fogColor, x.color.r, x.color.g, x.color.b), x.isFog ? (e.uniform1f(f.fogNear, x.near), e.uniform1f(f.fogFar, x.far), e.uniform1i(f.fogType, 1), c = 1, _ = 1) : x.isFogExp2 && (e.uniform1f(f.fogDensity, x.density), e.uniform1i(f.fogType, 2), c = 2, _ = 2)) : (e.uniform1i(f.fogType, 0), c = 0, _ = 0);
                for (var b = 0, w = r.length; b < w; b++) {
                    var T = r[b];
                    T.modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, T.matrixWorld), T.z = -T.modelViewMatrix.elements[14]
                }
                r.sort(o);
                for (var M = [], b = 0, w = r.length; b < w; b++) {
                    var T = r[b],
                        E = T.material;
                    if (!1 !== E.visible) {
                        T.onBeforeRender(t, a, l, void 0, E, void 0), e.uniform1f(f.alphaTest, E.alphaTest), e.uniformMatrix4fv(f.modelViewMatrix, !1, T.modelViewMatrix.elements), T.matrixWorld.decompose(v, g, y), M[0] = y.x, M[1] = y.y;
                        var S = 0;
                        a.fog && E.fog && (S = _), c !== S && (e.uniform1i(f.fogType, S), c = S), null !== E.map ? (e.uniform2f(f.uvOffset, E.map.offset.x, E.map.offset.y), e.uniform2f(f.uvScale, E.map.repeat.x, E.map.repeat.y)) : (e.uniform2f(f.uvOffset, 0, 0), e.uniform2f(f.uvScale, 1, 1)), e.uniform1f(f.opacity, E.opacity), e.uniform3f(f.color, E.color.r, E.color.g, E.color.b), e.uniform1f(f.rotation, E.rotation), e.uniform2fv(f.scale, M), i.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst, E.blendEquationAlpha, E.blendSrcAlpha, E.blendDstAlpha, E.premultipliedAlpha), i.buffers.depth.setTest(E.depthTest), i.buffers.depth.setMask(E.depthWrite), n.setTexture2D(E.map || m, 0), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), T.onAfterRender(t, a, l, void 0, E, void 0)
                    }
                }
                i.enable(e.CULL_FACE), i.reset()
            }
        }
    }

    function K() {
        Object.defineProperty(this, "id", {
            value: Xo++
        }), this.uuid = Oo.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = Ds, this.side = Es, this.flatShading = !1, this.vertexColors = Cs, this.opacity = 1, this.transparent = !1, this.blendSrc = Ys, this.blendDst = Zs, this.blendEquation = Fs, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = ra, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
    }

    function tt(t) {
        K.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }

    function et(t) {
        K.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Co, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
    }

    function it(t) {
        K.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new c, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
    }

    function nt(t, e) {
        this.min = void 0 !== t ? t : new c(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new c(-1 / 0, -1 / 0, -1 / 0)
    }

    function rt(t, e) {
        this.center = void 0 !== t ? t : new c, this.radius = void 0 !== e ? e : 0
    }

    function st() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    function at(t, e) {
        this.normal = void 0 !== t ? t : new c(1, 0, 0), this.constant = void 0 !== e ? e : 0
    }

    function ot(t, e, i, n, r, s) {
        this.planes = [void 0 !== t ? t : new at, void 0 !== e ? e : new at, void 0 !== i ? i : new at, void 0 !== n ? n : new at, void 0 !== r ? r : new at, void 0 !== s ? s : new at]
    }

    function ht(t, e, i) {
        function n(e, i, n, r, s, a) {
            var o = e.geometry,
                h = null,
                l = _,
                c = e.customDepthMaterial;
            if (n && (l = x, c = e.customDistanceMaterial), c) h = c;
            else {
                var u = !1;
                i.morphTargets && (o && o.isBufferGeometry ? u = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (u = o.morphTargets && o.morphTargets.length > 0)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                var d = e.isSkinnedMesh && i.skinning,
                    p = 0;
                u && (p |= v), d && (p |= g), h = l[p]
            }
            if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                var f = h.uuid,
                    m = i.uuid,
                    y = b[f];
                void 0 === y && (y = {}, b[f] = y);
                var w = y[m];
                void 0 === w && (w = h.clone(), y[m] = w), h = w
            }
            h.visible = i.visible, h.wireframe = i.wireframe;
            var T = i.side;
            return C.renderSingleSided && T == As && (T = Es), C.renderReverseSided && (T === Es ? T = Ss : T === Ss && (T = Es)), h.side = T, h.clipShadows = i.clipShadows, h.clippingPlanes = i.clippingPlanes, h.clipIntersection = i.clipIntersection, h.wireframeLinewidth = i.wireframeLinewidth, h.linewidth = i.linewidth, n && h.isMeshDistanceMaterial && (h.referencePosition.copy(r), h.nearDistance = s, h.farDistance = a), h
        }

        function s(i, r, a, o) {
            if (!1 !== i.visible) {
                if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || h.intersectsObject(i))) {
                    i.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, i.matrixWorld);
                    var l = e.update(i),
                        c = i.material;
                    if (Array.isArray(c))
                        for (var u = l.groups, d = 0, p = u.length; d < p; d++) {
                            var f = u[d],
                                v = c[f.materialIndex];
                            if (v && v.visible) {
                                var g = n(i, v, o, m, a.near, a.far);
                                t.renderBufferDirect(a, null, l, g, i, f)
                            }
                        } else if (c.visible) {
                            var g = n(i, c, o, m, a.near, a.far);
                            t.renderBufferDirect(a, null, l, g, i, null)
                        }
                }
                for (var y = i.children, _ = 0, x = y.length; _ < x; _++) s(y[_], r, a, o)
            }
        }
        for (var h = new ot, l = new u, d = new r, p = new r(i, i), f = new c, m = new c, v = 1, g = 2, y = 1 + (v | g), _ = new Array(y), x = new Array(y), b = {}, w = [new c(1, 0, 0), new c(-1, 0, 0), new c(0, 0, 1), new c(0, 0, -1), new c(0, 1, 0), new c(0, -1, 0)], T = [new c(0, 1, 0), new c(0, 1, 0), new c(0, 1, 0), new c(0, 1, 0), new c(0, 0, 1), new c(0, 0, -1)], M = [new a, new a, new a, new a, new a, new a], E = 0; E !== y; ++E) {
            var S = 0 != (E & v),
                A = 0 != (E & g),
                P = new et({
                    depthPacking: Lo,
                    morphTargets: S,
                    skinning: A
                });
            _[E] = P;
            var R = new it({
                morphTargets: S,
                skinning: A
            });
            x[E] = R
        }
        var C = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Ts, this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function(e, i, n) {
            if (!1 !== C.enabled && (!1 !== C.autoUpdate || !1 !== C.needsUpdate) && 0 !== e.length) {
                var r = t.context,
                    a = t.state;
                a.disable(r.BLEND), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!0), a.setScissorTest(!1);
                for (var c, u = 0, v = e.length; u < v; u++) {
                    var g = e[u],
                        y = g.shadow,
                        _ = g && g.isPointLight;
                    if (void 0 !== y) {
                        var x = y.camera;
                        if (d.copy(y.mapSize), d.min(p), _) {
                            var b = d.x,
                                E = d.y;
                            M[0].set(2 * b, E, b, E), M[1].set(0, E, b, E), M[2].set(3 * b, E, b, E), M[3].set(b, E, b, E), M[4].set(3 * b, 0, b, E), M[5].set(b, 0, b, E), d.x *= 4, d.y *= 2
                        }
                        if (null === y.map) {
                            var S = {
                                minFilter: Pa,
                                magFilter: Pa,
                                format: Ya
                            };
                            y.map = new o(d.x, d.y, S), y.map.texture.name = g.name + ".shadowMap", x.updateProjectionMatrix()
                        }
                        y.isSpotLightShadow && y.update(g);
                        var A = y.map,
                            P = y.matrix;
                        m.setFromMatrixPosition(g.matrixWorld), x.position.copy(m), _ ? (c = 6, P.makeTranslation(-m.x, -m.y, -m.z)) : (c = 1, f.setFromMatrixPosition(g.target.matrixWorld), x.lookAt(f), x.updateMatrixWorld(), P.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), P.multiply(x.projectionMatrix), P.multiply(x.matrixWorldInverse)), t.setRenderTarget(A), t.clear();
                        for (var R = 0; R < c; R++) {
                            if (_) {
                                f.copy(x.position), f.add(w[R]), x.up.copy(T[R]), x.lookAt(f), x.updateMatrixWorld();
                                var L = M[R];
                                a.viewport(L)
                            }
                            l.multiplyMatrices(x.projectionMatrix, x.matrixWorldInverse), h.setFromMatrix(l), s(i, n, x, _)
                        }
                    } else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.")
                }
                C.needsUpdate = !1
            }
        }
    }

    function lt(t) {
        function e(e, i) {
            var n = e.array,
                r = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                s = t.createBuffer();
            t.bindBuffer(i, s), t.bufferData(i, n, r), e.onUploadCallback();
            var a = t.FLOAT;
            return n instanceof Float32Array ? a = t.FLOAT : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = t.UNSIGNED_SHORT : n instanceof Int16Array ? a = t.SHORT : n instanceof Uint32Array ? a = t.UNSIGNED_INT : n instanceof Int32Array ? a = t.INT : n instanceof Int8Array ? a = t.BYTE : n instanceof Uint8Array && (a = t.UNSIGNED_BYTE), {
                buffer: s,
                type: a,
                bytesPerElement: n.BYTES_PER_ELEMENT,
                version: e.version
            }
        }

        function i(e, i, n) {
            var r = i.array,
                s = i.updateRange;
            t.bindBuffer(n, e), !1 === i.dynamic ? t.bufferData(n, r, t.STATIC_DRAW) : -1 === s.count ? t.bufferSubData(n, 0, r) : 0 === s.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, s.offset * r.BYTES_PER_ELEMENT, r.subarray(s.offset, s.offset + s.count)), s.count = -1)
        }

        function n(t) {
            return t.isInterleavedBufferAttribute && (t = t.data), a[t.uuid]
        }

        function r(e) {
            e.isInterleavedBufferAttribute && (e = e.data);
            var i = a[e.uuid];
            i && (t.deleteBuffer(i.buffer), delete a[e.uuid])
        }

        function s(t, n) {
            t.isInterleavedBufferAttribute && (t = t.data);
            var r = a[t.uuid];
            void 0 === r ? a[t.uuid] = e(t, n) : r.version < t.version && (i(r.buffer, t, n), r.version = t.version)
        }
        var a = {};
        return {
            get: n,
            remove: r,
            update: s
        }
    }

    function ct(t, e, i, n) {
        this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || ct.DefaultOrder
    }

    function ut() {
        this.mask = 1
    }

    function dt() {
        function t() {
            r.setFromEuler(n, !1)
        }

        function e() {
            n.setFromQuaternion(r, void 0, !1)
        }
        Object.defineProperty(this, "id", {
            value: qo++
        }), this.uuid = Oo.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = dt.DefaultUp.clone();
        var i = new c,
            n = new ct,
            r = new l,
            s = new c(1, 1, 1);
        n.onChange(t), r.onChange(e), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: i
            },
            rotation: {
                enumerable: !0,
                value: n
            },
            quaternion: {
                enumerable: !0,
                value: r
            },
            scale: {
                enumerable: !0,
                value: s
            },
            modelViewMatrix: {
                value: new u
            },
            normalMatrix: {
                value: new st
            }
        }), this.matrix = new u, this.matrixWorld = new u, this.matrixAutoUpdate = dt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ut, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function pt() {
        dt.call(this), this.type = "Camera", this.matrixWorldInverse = new u, this.projectionMatrix = new u
    }

    function ft(t, e, i, n, r, s) {
        pt.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = void 0 !== r ? r : .1, this.far = void 0 !== s ? s : 2e3, this.updateProjectionMatrix()
    }

    function mt(t, e, i, n) {
        pt.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function vt(t, e, i, n, r, s) {
        this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new c, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new Y, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== s ? s : 0
    }

    function gt() {
        return Yo++
    }

    function yt() {
        Object.defineProperty(this, "id", {
            value: gt()
        }), this.uuid = Oo.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function _t(t, e, i) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.uuid = Oo.generateUUID(), this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function() {}, this.version = 0
    }

    function xt(t, e) {
        _t.call(this, new Int8Array(t), e)
    }

    function bt(t, e) {
        _t.call(this, new Uint8Array(t), e)
    }

    function wt(t, e) {
        _t.call(this, new Uint8ClampedArray(t), e)
    }

    function Tt(t, e) {
        _t.call(this, new Int16Array(t), e)
    }

    function Mt(t, e) {
        _t.call(this, new Uint16Array(t), e)
    }

    function Et(t, e) {
        _t.call(this, new Int32Array(t), e)
    }

    function St(t, e) {
        _t.call(this, new Uint32Array(t), e)
    }

    function At(t, e) {
        _t.call(this, new Float32Array(t), e)
    }

    function Pt(t, e) {
        _t.call(this, new Float64Array(t), e)
    }

    function Rt() {
        this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function Ct(t) {
        if (0 === t.length) return -1 / 0;
        for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
        return e
    }

    function Lt() {
        Object.defineProperty(this, "id", {
            value: gt()
        }), this.uuid = Oo.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }
    }

    function Ot(t, e, i, n, r, s) {
        yt.call(this), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: s
        }, this.fromBufferGeometry(new It(t, e, i, n, r, s)), this.mergeVertices()
    }

    function It(t, e, i, n, r, s) {
        function a(t, e, i, n, r, s, a, m, v, g, y) {
            var _, x, b = s / v,
                w = a / g,
                T = s / 2,
                M = a / 2,
                E = m / 2,
                S = v + 1,
                A = g + 1,
                P = 0,
                R = 0,
                C = new c;
            for (x = 0; x < A; x++) {
                var L = x * w - M;
                for (_ = 0; _ < S; _++) {
                    var O = _ * b - T;
                    C[t] = O * n, C[e] = L * r, C[i] = E, l.push(C.x, C.y, C.z), C[t] = 0, C[e] = 0, C[i] = m > 0 ? 1 : -1, u.push(C.x, C.y, C.z), d.push(_ / v), d.push(1 - x / g), P += 1
                }
            }
            for (x = 0; x < g; x++)
                for (_ = 0; _ < v; _++) {
                    var I = p + _ + S * x,
                        D = p + _ + S * (x + 1),
                        z = p + (_ + 1) + S * (x + 1),
                        U = p + (_ + 1) + S * x;
                    h.push(I, D, U), h.push(D, z, U), R += 6
                }
            o.addGroup(f, R, y), f += R, p += P
        }
        Lt.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: s
        };
        var o = this;
        n = Math.floor(n) || 1, r = Math.floor(r) || 1, s = Math.floor(s) || 1;
        var h = [],
            l = [],
            u = [],
            d = [],
            p = 0,
            f = 0;
        a("z", "y", "x", -1, -1, i, e, t, s, r, 0), a("z", "y", "x", 1, -1, i, e, -t, s, r, 1), a("x", "z", "y", 1, 1, t, i, e, n, s, 2), a("x", "z", "y", 1, -1, t, i, -e, n, s, 3), a("x", "y", "z", 1, -1, t, e, i, n, r, 4), a("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(h), this.addAttribute("position", new At(l, 3)), this.addAttribute("normal", new At(u, 3)), this.addAttribute("uv", new At(d, 2))
    }

    function Dt(t, e, i, n) {
        yt.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
        }, this.fromBufferGeometry(new zt(t, e, i, n)), this.mergeVertices()
    }

    function zt(t, e, i, n) {
        Lt.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
        };
        var r, s, a = t / 2,
            o = e / 2,
            h = Math.floor(i) || 1,
            l = Math.floor(n) || 1,
            c = h + 1,
            u = l + 1,
            d = t / h,
            p = e / l,
            f = [],
            m = [],
            v = [],
            g = [];
        for (s = 0; s < u; s++) {
            var y = s * p - o;
            for (r = 0; r < c; r++) {
                var _ = r * d - a;
                m.push(_, -y, 0), v.push(0, 0, 1), g.push(r / h), g.push(1 - s / l)
            }
        }
        for (s = 0; s < l; s++)
            for (r = 0; r < h; r++) {
                var x = r + c * s,
                    b = r + c * (s + 1),
                    w = r + 1 + c * (s + 1),
                    T = r + 1 + c * s;
                f.push(x, b, T), f.push(b, w, T)
            }
        this.setIndex(f), this.addAttribute("position", new At(m, 3)), this.addAttribute("normal", new At(v, 3)), this.addAttribute("uv", new At(g, 2))
    }

    function Ut(t) {
        K.call(this), this.type = "MeshBasicMaterial", this.color = new Y(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = la, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
    }

    function Nt(t, e) {
        this.origin = void 0 !== t ? t : new c, this.direction = void 0 !== e ? e : new c
    }

    function kt(t, e) {
        this.start = void 0 !== t ? t : new c, this.end = void 0 !== e ? e : new c
    }

    function Ft(t, e, i) {
        this.a = void 0 !== t ? t : new c, this.b = void 0 !== e ? e : new c, this.c = void 0 !== i ? i : new c
    }

    function Bt(t, e) {
        dt.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Lt, this.material = void 0 !== e ? e : new Ut({
            color: 16777215 * Math.random()
        }), this.drawMode = _o, this.updateMorphTargets()
    }

    function Gt(t, e, i, n) {
        function r(e, n, r, u) {
            var d = n.background;
            null === d ? s(l, c) : d && d.isColor && (s(d, 1), u = !0), (t.autoClear || u) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && d.isCubeTexture ? (void 0 === h && (h = new Bt(new It(1, 1, 1), new tt({
                uniforms: Wo.cube.uniforms,
                vertexShader: Wo.cube.vertexShader,
                fragmentShader: Wo.cube.fragmentShader,
                side: Ss,
                depthTest: !0,
                depthWrite: !1,
                polygonOffset: !0,
                fog: !1
            })), h.geometry.removeAttribute("normal"), h.geometry.removeAttribute("uv"), h.onBeforeRender = function(t, e, i) {
                var n = i.far;
                this.matrixWorld.makeScale(n, n, n), this.matrixWorld.copyPosition(i.matrixWorld), this.material.polygonOffsetUnits = 10 * n
            }, i.update(h.geometry)), h.material.uniforms.tCube.value = d, e.push(h, h.geometry, h.material, 0, null)) : d && d.isTexture && (void 0 === a && (a = new ft(-1, 1, 1, -1, 0, 1), o = new Bt(new zt(2, 2), new Ut({
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), i.update(o.geometry)), o.material.map = d, t.renderBufferDirect(a, null, o.geometry, o.material, o, null))
        }

        function s(t, i) {
            e.buffers.color.setClear(t.r, t.g, t.b, i, n)
        }
        var a, o, h, l = new Y(0),
            c = 0;
        return {
            getClearColor: function() {
                return l
            },
            setClearColor: function(t, e) {
                l.set(t), c = void 0 !== e ? e : 1, s(l, c)
            },
            getClearAlpha: function() {
                return c
            },
            setClearAlpha: function(t) {
                c = t, s(l, c)
            },
            render: r
        }
    }

    function Ht(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }

    function jt(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }

    function Vt() {
        function t() {
            r = 0, s.length = 0, a.length = 0
        }

        function e(t, e, i, o, h) {
            var l = n[r];
            void 0 === l ? (l = {
                id: t.id,
                object: t,
                geometry: e,
                material: i,
                program: i.program,
                renderOrder: t.renderOrder,
                z: o,
                group: h
            }, n[r] = l) : (l.id = t.id, l.object = t, l.geometry = e, l.material = i, l.program = i.program, l.renderOrder = t.renderOrder, l.z = o, l.group = h), (!0 === i.transparent ? a : s).push(l), r++
        }

        function i() {
            s.length > 1 && s.sort(Ht), a.length > 1 && a.sort(jt)
        }
        var n = [],
            r = 0,
            s = [],
            a = [];
        return {
            opaque: s,
            transparent: a,
            init: t,
            push: e,
            sort: i
        }
    }

    function Wt() {
        function t(t, e) {
            var n = t.id + "," + e.id,
                r = i[n];
            return void 0 === r && (r = new Vt, i[n] = r), r
        }

        function e() {
            i = {}
        }
        var i = {};
        return {
            get: t,
            dispose: e
        }
    }

    function Xt(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }

    function qt(t) {
        function e(e, r, s, a) {
            var o = e.morphTargetInfluences,
                h = o.length,
                l = i[r.id];
            if (void 0 === l) {
                l = [];
                for (var c = 0; c < h; c++) l[c] = [c, 0];
                i[r.id] = l
            }
            for (var u = s.morphTargets && r.morphAttributes.position, d = s.morphNormals && r.morphAttributes.normal, c = 0; c < h; c++) {
                var p = l[c];
                0 !== p[1] && (u && r.removeAttribute("morphTarget" + c), d && r.removeAttribute("morphNormal" + c))
            }
            for (var c = 0; c < h; c++) {
                var p = l[c];
                p[0] = c, p[1] = o[c]
            }
            l.sort(Xt);
            for (var c = 0; c < 8; c++) {
                var p = l[c];
                if (p) {
                    var f = p[0],
                        m = p[1];
                    if (m) {
                        u && r.addAttribute("morphTarget" + c, u[f]), d && r.addAttribute("morphNormal" + c, d[f]), n[c] = m;
                        continue
                    }
                }
                n[c] = 0
            }
            a.getUniforms().setValue(t, "morphTargetInfluences", n)
        }
        var i = {},
            n = new Float32Array(8);
        return {
            update: e
        }
    }

    function Yt(t, e, i) {
        function n(t) {
            o = t
        }

        function r(t) {
            h = t.type, l = t.bytesPerElement
        }

        function s(e, n) {
            t.drawElements(o, n, h, e * l), i.calls++, i.vertices += n, o === t.TRIANGLES ? i.faces += n / 3 : o === t.POINTS && (i.points += n)
        }

        function a(n, r, s) {
            var a = e.get("ANGLE_instanced_arrays");
            if (null === a) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            a.drawElementsInstancedANGLE(o, s, h, r * l, n.maxInstancedCount), i.calls++, i.vertices += s * n.maxInstancedCount, o === t.TRIANGLES ? i.faces += n.maxInstancedCount * s / 3 : o === t.POINTS && (i.points += n.maxInstancedCount * s)
        }
        var o, h, l;
        this.setMode = n, this.setIndex = r, this.render = s, this.renderInstances = a
    }

    function Zt(t, e, i) {
        function n(t) {
            a = t
        }

        function r(e, n) {
            t.drawArrays(a, e, n), i.calls++, i.vertices += n, a === t.TRIANGLES ? i.faces += n / 3 : a === t.POINTS && (i.points += n)
        }

        function s(n, r, s) {
            var o = e.get("ANGLE_instanced_arrays");
            if (null === o) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            var h = n.attributes.position;
            h.isInterleavedBufferAttribute ? (s = h.data.count, o.drawArraysInstancedANGLE(a, 0, s, n.maxInstancedCount)) : o.drawArraysInstancedANGLE(a, r, s, n.maxInstancedCount), i.calls++, i.vertices += s * n.maxInstancedCount, a === t.TRIANGLES ? i.faces += n.maxInstancedCount * s / 3 : a === t.POINTS && (i.points += n.maxInstancedCount * s)
        }
        var a;
        this.setMode = n, this.render = r, this.renderInstances = s
    }

    function $t(t, e, i) {
        function n(t) {
            var r = t.target,
                s = o[r.id];
            null !== s.index && e.remove(s.index);
            for (var a in s.attributes) e.remove(s.attributes[a]);
            r.removeEventListener("dispose", n), delete o[r.id];
            var l = h[r.id];
            l && (e.remove(l), delete h[r.id]), l = h[s.id], l && (e.remove(l), delete h[s.id]), i.geometries--
        }

        function r(t, e) {
            var r = o[e.id];
            return r || (e.addEventListener("dispose", n), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Lt).setFromObject(t)), r = e._bufferGeometry), o[e.id] = r, i.geometries++, r)
        }

        function s(i) {
            var n = i.index,
                r = i.attributes;
            null !== n && e.update(n, t.ELEMENT_ARRAY_BUFFER);
            for (var s in r) e.update(r[s], t.ARRAY_BUFFER);
            var a = i.morphAttributes;
            for (var s in a)
                for (var o = a[s], h = 0, l = o.length; h < l; h++) e.update(o[h], t.ARRAY_BUFFER)
        }

        function a(i) {
            var n = h[i.id];
            if (n) return n;
            var r = [],
                s = i.index,
                a = i.attributes;
            if (null !== s)
                for (var o = s.array, l = 0, c = o.length; l < c; l += 3) {
                    var u = o[l + 0],
                        d = o[l + 1],
                        p = o[l + 2];
                    r.push(u, d, d, p, p, u)
                } else
                    for (var o = a.position.array, l = 0, c = o.length / 3 - 1; l < c; l += 3) {
                        var u = l + 0,
                            d = l + 1,
                            p = l + 2;
                        r.push(u, d, d, p, p, u)
                    }
            return n = new(Ct(r) > 65535 ? St : Mt)(r, 1), e.update(n, t.ELEMENT_ARRAY_BUFFER), h[i.id] = n, n
        }
        var o = {},
            h = {};
        return {
            get: r,
            update: s,
            getWireframeAttribute: a
        }
    }

    function Qt() {
        var t = {};
        return {
            get: function(e) {
                if (void 0 !== t[e.id]) return t[e.id];
                var i;
                switch (e.type) {
                    case "DirectionalLight":
                        i = {
                            direction: new c,
                            color: new Y,
                            shadow: !0,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new r
                        };
                        break;
                    case "SpotLight":
                        i = {
                            position: new c,
                            direction: new c,
                            color: new Y,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !0,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new r
                        };
                        break;
                    case "PointLight":
                        i = {
                            position: new c,
                            color: new Y,
                            distance: 0,
                            decay: 0,
                            shadow: !0,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new r,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                    case "HemisphereLight":
                        i = {
                            direction: new c,
                            skyColor: new Y,
                            groundColor: new Y
                        };
                        break;
                    case "RectAreaLight":
                        i = {
                            color: new Y,
                            position: new c,
                            halfWidth: new c,
                            halfHeight: new c
                        }
                }
                return t[e.id] = i, i
            }
        }
    }

    function Jt() {
        function t(t, a, o) {
            for (var h = 0, l = 0, c = 0, u = 0, d = 0, p = 0, f = 0, m = 0, v = o.matrixWorldInverse, g = 0, y = t.length; g < y; g++) {
                var _ = t[g],
                    x = _.color,
                    b = _.intensity,
                    w = _.distance,
                    T = _.shadow && _.shadow.map ? _.shadow.map.texture : null;
                if (_.isAmbientLight) h += x.r * b, l += x.g * b, c += x.b * b;
                else if (_.isDirectionalLight) {
                    var M = e.get(_);
                    if (M.color.copy(_.color).multiplyScalar(_.intensity), M.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), M.direction.sub(n), M.direction.transformDirection(v), M.shadow = _.castShadow, _.castShadow) {
                        var E = _.shadow;
                        M.shadowBias = E.bias, M.shadowRadius = E.radius, M.shadowMapSize = E.mapSize
                    }
                    i.directionalShadowMap[u] = T, i.directionalShadowMatrix[u] = _.shadow.matrix, i.directional[u] = M, u++
                } else if (_.isSpotLight) {
                    var M = e.get(_);
                    if (M.position.setFromMatrixPosition(_.matrixWorld), M.position.applyMatrix4(v), M.color.copy(x).multiplyScalar(b), M.distance = w, M.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), M.direction.sub(n), M.direction.transformDirection(v), M.coneCos = Math.cos(_.angle), M.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)), M.decay = 0 === _.distance ? 0 : _.decay, M.shadow = _.castShadow, _.castShadow) {
                        var E = _.shadow;
                        M.shadowBias = E.bias, M.shadowRadius = E.radius, M.shadowMapSize = E.mapSize
                    }
                    i.spotShadowMap[p] = T, i.spotShadowMatrix[p] = _.shadow.matrix, i.spot[p] = M, p++
                } else if (_.isRectAreaLight) {
                    var M = e.get(_);
                    M.color.copy(x).multiplyScalar(b / (_.width * _.height)), M.position.setFromMatrixPosition(_.matrixWorld), M.position.applyMatrix4(v), s.identity(), r.copy(_.matrixWorld), r.premultiply(v), s.extractRotation(r), M.halfWidth.set(.5 * _.width, 0, 0), M.halfHeight.set(0, .5 * _.height, 0), M.halfWidth.applyMatrix4(s), M.halfHeight.applyMatrix4(s), i.rectArea[f] = M, f++
                } else if (_.isPointLight) {
                    var M = e.get(_);
                    if (M.position.setFromMatrixPosition(_.matrixWorld), M.position.applyMatrix4(v), M.color.copy(_.color).multiplyScalar(_.intensity), M.distance = _.distance, M.decay = 0 === _.distance ? 0 : _.decay, M.shadow = _.castShadow, _.castShadow) {
                        var E = _.shadow;
                        M.shadowBias = E.bias, M.shadowRadius = E.radius, M.shadowMapSize = E.mapSize, M.shadowCameraNear = E.camera.near, M.shadowCameraFar = E.camera.far
                    }
                    i.pointShadowMap[d] = T, i.pointShadowMatrix[d] = _.shadow.matrix, i.point[d] = M, d++
                } else if (_.isHemisphereLight) {
                    var M = e.get(_);
                    M.direction.setFromMatrixPosition(_.matrixWorld), M.direction.transformDirection(v), M.direction.normalize(), M.skyColor.copy(_.color).multiplyScalar(b), M.groundColor.copy(_.groundColor).multiplyScalar(b), i.hemi[m] = M, m++
                }
            }
            i.ambient[0] = h, i.ambient[1] = l, i.ambient[2] = c, i.directional.length = u, i.spot.length = p, i.rectArea.length = f, i.point.length = d, i.hemi.length = m, i.hash = u + "," + d + "," + p + "," + f + "," + m + "," + a.length
        }
        var e = new Qt,
            i = {
                hash: "",
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            },
            n = new c,
            r = new u,
            s = new u;
        return {
            setup: t,
            state: i
        }
    }

    function Kt(t, e) {
        function i(i) {
            var n = e.frame,
                s = i.geometry,
                a = t.get(i, s);
            return r[a.id] !== n && (s.isGeometry && a.updateFromObject(i), t.update(a), r[a.id] = n), a
        }

        function n() {
            r = {}
        }
        var r = {};
        return {
            update: i,
            clear: n
        }
    }

    function te(t) {
        for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
        return e.join("\n")
    }

    function ee(t, e, i) {
        var n = t.createShader(e);
        return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(n), te(i)), n
    }

    function ie(t) {
        switch (t) {
            case wo:
                return ["Linear", "( value )"];
            case To:
                return ["sRGB", "( value )"];
            case Eo:
                return ["RGBE", "( value )"];
            case Ao:
                return ["RGBM", "( value, 7.0 )"];
            case Po:
                return ["RGBM", "( value, 16.0 )"];
            case Ro:
                return ["RGBD", "( value, 256.0 )"];
            case Mo:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw new Error("unsupported encoding: " + t)
        }
    }

    function ne(t, e) {
        var i = ie(e);
        return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
    }

    function re(t, e) {
        var i = ie(e);
        return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
    }

    function se(t, e) {
        var i;
        switch (e) {
            case pa:
                i = "Linear";
                break;
            case fa:
                i = "Reinhard";
                break;
            case ma:
                i = "Uncharted2";
                break;
            case va:
                i = "OptimizedCineon";
                break;
            default:
                throw new Error("unsupported toneMapping: " + e)
        }
        return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
    }

    function ae(t, e, i) {
        return t = t || {}, [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(le).join("\n")
    }

    function oe(t) {
        var e = [];
        for (var i in t) {
            var n = t[i];
            !1 !== n && e.push("#define " + i + " " + n)
        }
        return e.join("\n")
    }

    function he(t, e, i) {
        for (var n = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), s = 0; s < r; s++) {
            var a = t.getActiveAttrib(e, s),
                o = a.name;
            n[o] = t.getAttribLocation(e, o)
        }
        return n
    }

    function le(t) {
        return "" !== t
    }

    function ce(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    }

    function ue(t) {
        function e(t, e) {
            var i = Vo[e];
            if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
            return ue(i)
        }
        var i = /^[ \t]*#include +<([\w\d.]+)>/gm;
        return t.replace(i, e)
    }

    function de(t) {
        function e(t, e, i, n) {
            for (var r = "", s = parseInt(e); s < parseInt(i); s++) r += n.replace(/\[ i \]/g, "[ " + s + " ]");
            return r
        }
        var i = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        return t.replace(i, e)
    }

    function pe(t, e, i, n, r, s) {
        var a = t.context,
            o = n.defines,
            h = r.vertexShader,
            l = r.fragmentShader,
            c = "SHADOWMAP_TYPE_BASIC";
        s.shadowMapType === Ts ? c = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === Ms && (c = "SHADOWMAP_TYPE_PCF_SOFT");
        var u = "ENVMAP_TYPE_CUBE",
            d = "ENVMAP_MODE_REFLECTION",
            p = "ENVMAP_BLENDING_MULTIPLY";
        if (s.envMap) {
            switch (n.envMap.mapping) {
                case ya:
                case _a:
                    u = "ENVMAP_TYPE_CUBE";
                    break;
                case Ta:
                case Ma:
                    u = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case xa:
                case ba:
                    u = "ENVMAP_TYPE_EQUIREC";
                    break;
                case wa:
                    u = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
                case _a:
                case ba:
                    d = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
                case la:
                    p = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case ca:
                    p = "ENVMAP_BLENDING_MIX";
                    break;
                case ua:
                    p = "ENVMAP_BLENDING_ADD"
            }
        }
        var f, m, v = t.gammaFactor > 0 ? t.gammaFactor : 1,
            g = ae(n.extensions, s, e),
            y = oe(o),
            _ = a.createProgram();
        n.isRawShaderMaterial ? (f = [y, "\n"].filter(le).join("\n"), m = [g, y, "\n"].filter(le).join("\n")) : (f = ["precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + r.name, y, s.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + v, "#define MAX_BONES " + s.maxBones, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + d : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.displacementMap && s.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexColors ? "#define USE_COLOR" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.skinning ? "#define USE_SKINNING" : "", s.useVertexTexture ? "#define BONE_TEXTURE" : "", s.morphTargets ? "#define USE_MORPHTARGETS" : "", s.morphNormals && !1 === s.flatShading ? "#define USE_MORPHNORMALS" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + s.numClippingPlanes, s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + c : "", s.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(le).join("\n"), m = [g, "precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + r.name, y, s.alphaTest ? "#define ALPHATEST " + s.alphaTest : "", "#define GAMMA_FACTOR " + v, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + u : "", s.envMap ? "#define " + d : "", s.envMap ? "#define " + p : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexColors ? "#define USE_COLOR" : "", s.gradientMap ? "#define USE_GRADIENTMAP" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + s.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (s.numClippingPlanes - s.numClipIntersection), s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + c : "", s.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", s.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", s.envMap && e.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", s.toneMapping !== da ? "#define TONE_MAPPING" : "", s.toneMapping !== da ? Vo.tonemapping_pars_fragment : "", s.toneMapping !== da ? se("toneMapping", s.toneMapping) : "", s.dithering ? "#define DITHERING" : "", s.outputEncoding || s.mapEncoding || s.envMapEncoding || s.emissiveMapEncoding ? Vo.encodings_pars_fragment : "", s.mapEncoding ? ne("mapTexelToLinear", s.mapEncoding) : "", s.envMapEncoding ? ne("envMapTexelToLinear", s.envMapEncoding) : "", s.emissiveMapEncoding ? ne("emissiveMapTexelToLinear", s.emissiveMapEncoding) : "", s.outputEncoding ? re("linearToOutputTexel", s.outputEncoding) : "", s.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(le).join("\n")), h = ue(h), h = ce(h, s), l = ue(l), l = ce(l, s), n.isShaderMaterial || (h = de(h), l = de(l));
        var x = f + h,
            b = m + l,
            w = ee(a, a.VERTEX_SHADER, x),
            T = ee(a, a.FRAGMENT_SHADER, b);
        a.attachShader(_, w), a.attachShader(_, T), void 0 !== n.index0AttributeName ? a.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === s.morphTargets && a.bindAttribLocation(_, 0, "position"), a.linkProgram(_);
        var M = a.getProgramInfoLog(_),
            E = a.getShaderInfoLog(w),
            S = a.getShaderInfoLog(T),
            A = !0,
            P = !0;
        !1 === a.getProgramParameter(_, a.LINK_STATUS) ? (A = !1, console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(_, a.VALIDATE_STATUS), "gl.getProgramInfoLog", M, E, S)) : "" !== M ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", M) : "" !== E && "" !== S || (P = !1), P && (this.diagnostics = {
            runnable: A,
            material: n,
            programLog: M,
            vertexShader: {
                log: E,
                prefix: f
            },
            fragmentShader: {
                log: S,
                prefix: m
            }
        }), a.deleteShader(w), a.deleteShader(T);
        var R;
        this.getUniforms = function() {
            return void 0 === R && (R = new q(a, _, t)), R
        };
        var C;
        return this.getAttributes = function() {
            return void 0 === C && (C = he(a, _)), C
        }, this.destroy = function() {
            a.deleteProgram(_), this.program = void 0
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                }
            }
        }), this.id = Zo++, this.code = i, this.usedTimes = 1, this.program = _, this.vertexShader = w, this.fragmentShader = T, this
    }

    function fe(t, e, i) {
        function n(t) {
            var e = t.skeleton,
                n = e.bones;
            if (i.floatVertexTextures) return 1024;
            var r = i.maxVertexUniforms,
                s = Math.floor((r - 20) / 4),
                a = Math.min(s, n.length);
            return a < n.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + n.length + " bones. This GPU supports " + a + "."), 0) : a
        }

        function r(t, e) {
            var i;
            return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = wo, i === wo && e && (i = Mo), i
        }
        var s = [],
            a = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow"
            },
            o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
        this.getParameters = function(e, s, o, h, l, c, u) {
            var d = a[e.type],
                p = u.isSkinnedMesh ? n(u) : 0,
                f = i.precision;
            null !== e.precision && (f = i.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", f, "instead.");
            var m = t.getRenderTarget();
            return {
                shaderID: d,
                precision: f,
                supportsVertexTextures: i.vertexTextures,
                outputEncoding: r(m ? m.texture : null, t.gammaOutput),
                map: !!e.map,
                mapEncoding: r(e.map, t.gammaInput),
                envMap: !!e.envMap,
                envMapMode: e.envMap && e.envMap.mapping,
                envMapEncoding: r(e.envMap, t.gammaInput),
                envMapCubeUV: !!e.envMap && (e.envMap.mapping === Ta || e.envMap.mapping === Ma),
                lightMap: !!e.lightMap,
                aoMap: !!e.aoMap,
                emissiveMap: !!e.emissiveMap,
                emissiveMapEncoding: r(e.emissiveMap, t.gammaInput),
                bumpMap: !!e.bumpMap,
                normalMap: !!e.normalMap,
                displacementMap: !!e.displacementMap,
                roughnessMap: !!e.roughnessMap,
                metalnessMap: !!e.metalnessMap,
                specularMap: !!e.specularMap,
                alphaMap: !!e.alphaMap,
                gradientMap: !!e.gradientMap,
                combine: e.combine,
                vertexColors: e.vertexColors,
                fog: !!h,
                useFog: e.fog,
                fogExp: h && h.isFogExp2,
                flatShading: e.flatShading,
                sizeAttenuation: e.sizeAttenuation,
                logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                skinning: e.skinning && p > 0,
                maxBones: p,
                useVertexTexture: i.floatVertexTextures,
                morphTargets: e.morphTargets,
                morphNormals: e.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                numDirLights: s.directional.length,
                numPointLights: s.point.length,
                numSpotLights: s.spot.length,
                numRectAreaLights: s.rectArea.length,
                numHemiLights: s.hemi.length,
                numClippingPlanes: l,
                numClipIntersection: c,
                dithering: e.dithering,
                shadowMapEnabled: t.shadowMap.enabled && u.receiveShadow && o.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: t.toneMapping,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: e.premultipliedAlpha,
                alphaTest: e.alphaTest,
                doubleSided: e.side === As,
                flipSided: e.side === Ss,
                depthPacking: void 0 !== e.depthPacking && e.depthPacking
            }
        }, this.getProgramCode = function(e, i) {
            var n = [];
            if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                for (var r in e.defines) n.push(r), n.push(e.defines[r]);
            for (var s = 0; s < o.length; s++) n.push(i[o[s]]);
            return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.join()
        }, this.acquireProgram = function(i, n, r, a) {
            for (var o, h = 0, l = s.length; h < l; h++) {
                var c = s[h];
                if (c.code === a) {
                    o = c, ++o.usedTimes;
                    break
                }
            }
            return void 0 === o && (o = new pe(t, e, a, i, n, r), s.push(o)), o
        }, this.releaseProgram = function(t) {
            if (0 == --t.usedTimes) {
                var e = s.indexOf(t);
                s[e] = s[s.length - 1], s.pop(), t.destroy()
            }
        }, this.programs = s
    }

    function me(t, e, i, n, r, s, a) {
        function o(t, e) {
            if (t.width > e || t.height > e) {
                var i = e / Math.max(t.width, t.height),
                    n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                n.width = Math.floor(t.width * i), n.height = Math.floor(t.height * i);
                return n.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + n.width + "x" + n.height, t), n
            }
            return t
        }

        function h(t) {
            return Oo.isPowerOfTwo(t.width) && Oo.isPowerOfTwo(t.height)
        }

        function l(t) {
            if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) {
                var e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                e.width = Oo.nearestPowerOfTwo(t.width), e.height = Oo.nearestPowerOfTwo(t.height);
                return e.getContext("2d").drawImage(t, 0, 0, e.width, e.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + e.width + "x" + e.height, t), e
            }
            return t
        }

        function c(t) {
            return t.wrapS !== Sa || t.wrapT !== Sa || t.minFilter !== Pa && t.minFilter !== La
        }

        function u(t, e) {
            return t.generateMipmaps && e && t.minFilter !== Pa && t.minFilter !== La
        }

        function d(e) {
            return e === Pa || e === Ra || e === Ca ? t.NEAREST : t.LINEAR
        }

        function p(t) {
            var e = t.target;
            e.removeEventListener("dispose", p), m(e), a.textures--
        }

        function f(t) {
            var e = t.target;
            e.removeEventListener("dispose", f), v(e), a.textures--
        }

        function m(e) {
            var i = n.get(e);
            if (e.image && i.__image__webglTextureCube) t.deleteTexture(i.__image__webglTextureCube);
            else {
                if (void 0 === i.__webglInit) return;
                t.deleteTexture(i.__webglTexture)
            }
            n.remove(e)
        }

        function v(e) {
            var i = n.get(e),
                r = n.get(e.texture);
            if (e) {
                if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)
                    for (var s = 0; s < 6; s++) t.deleteFramebuffer(i.__webglFramebuffer[s]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[s]);
                else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                n.remove(e.texture), n.remove(e)
            }
        }

        function g(e, r) {
            var s = n.get(e);
            if (e.version > 0 && s.__version !== e.version) {
                var a = e.image;
                if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
                else {
                    if (!1 !== a.complete) return void b(s, e, r);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                }
            }
            i.activeTexture(t.TEXTURE0 + r), i.bindTexture(t.TEXTURE_2D, s.__webglTexture)
        }

        function y(e, l) {
            var c = n.get(e);
            if (6 === e.image.length)
                if (e.version > 0 && c.__version !== e.version) {
                    c.__image__webglTextureCube || (e.addEventListener("dispose", p), c.__image__webglTextureCube = t.createTexture(), a.textures++), i.activeTexture(t.TEXTURE0 + l), i.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                    for (var d = e && e.isCompressedTexture, f = e.image[0] && e.image[0].isDataTexture, m = [], v = 0; v < 6; v++) m[v] = d || f ? f ? e.image[v].image : e.image[v] : o(e.image[v], r.maxCubemapSize);
                    var g = m[0],
                        y = h(g),
                        _ = s.convert(e.format),
                        b = s.convert(e.type);
                    x(t.TEXTURE_CUBE_MAP, e, y);
                    for (var v = 0; v < 6; v++)
                        if (d)
                            for (var w, T = m[v].mipmaps, M = 0, E = T.length; M < E; M++) w = T[M], e.format !== Ya && e.format !== qa ? i.getCompressedTextureFormats().indexOf(_) > -1 ? i.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + v, M, _, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + v, M, _, w.width, w.height, 0, _, b, w.data);
                        else f ? i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + v, 0, _, m[v].width, m[v].height, 0, _, b, m[v].data) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + v, 0, _, _, b, m[v]);
                    u(e, y) && t.generateMipmap(t.TEXTURE_CUBE_MAP), c.__version = e.version, e.onUpdate && e.onUpdate(e)
                } else i.activeTexture(t.TEXTURE0 + l), i.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube)
        }

        function _(e, r) {
            i.activeTexture(t.TEXTURE0 + r), i.bindTexture(t.TEXTURE_CUBE_MAP, n.get(e).__webglTexture)
        }

        function x(i, a, o) {
            var h;
            if (o ? (t.texParameteri(i, t.TEXTURE_WRAP_S, s.convert(a.wrapS)), t.texParameteri(i, t.TEXTURE_WRAP_T, s.convert(a.wrapT)), t.texParameteri(i, t.TEXTURE_MAG_FILTER, s.convert(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, s.convert(a.minFilter))) : (t.texParameteri(i, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(i, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), a.wrapS === Sa && a.wrapT === Sa || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", a), t.texParameteri(i, t.TEXTURE_MAG_FILTER, d(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, d(a.minFilter)), a.minFilter !== Pa && a.minFilter !== La && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", a)), h = e.get("EXT_texture_filter_anisotropic")) {
                if (a.type === Ba && null === e.get("OES_texture_float_linear")) return;
                if (a.type === Ga && null === e.get("OES_texture_half_float_linear")) return;
                (a.anisotropy > 1 || n.get(a).__currentAnisotropy) && (t.texParameterf(i, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
            }
        }

        function b(e, n, d) {
            void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", p), e.__webglTexture = t.createTexture(), a.textures++), i.activeTexture(t.TEXTURE0 + d), i.bindTexture(t.TEXTURE_2D, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, n.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, n.unpackAlignment);
            var f = o(n.image, r.maxTextureSize);
            c(n) && !1 === h(f) && (f = l(f));
            var m = h(f),
                v = s.convert(n.format),
                g = s.convert(n.type);
            x(t.TEXTURE_2D, n, m);
            var y, _ = n.mipmaps;
            if (n.isDepthTexture) {
                var b = t.DEPTH_COMPONENT;
                if (n.type === Ba) {
                    if (!P) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    b = t.DEPTH_COMPONENT32F
                } else P && (b = t.DEPTH_COMPONENT16);
                n.format === Ja && b === t.DEPTH_COMPONENT && n.type !== Na && n.type !== Fa && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = Na, g = s.convert(n.type)), n.format === Ka && (b = t.DEPTH_STENCIL, n.type !== Wa && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = Wa, g = s.convert(n.type))), i.texImage2D(t.TEXTURE_2D, 0, b, f.width, f.height, 0, v, g, null)
            } else if (n.isDataTexture)
                if (_.length > 0 && m) {
                    for (var w = 0, T = _.length; w < T; w++) y = _[w], i.texImage2D(t.TEXTURE_2D, w, v, y.width, y.height, 0, v, g, y.data);
                    n.generateMipmaps = !1
                } else i.texImage2D(t.TEXTURE_2D, 0, v, f.width, f.height, 0, v, g, f.data);
            else if (n.isCompressedTexture)
                for (var w = 0, T = _.length; w < T; w++) y = _[w], n.format !== Ya && n.format !== qa ? i.getCompressedTextureFormats().indexOf(v) > -1 ? i.compressedTexImage2D(t.TEXTURE_2D, w, v, y.width, y.height, 0, y.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(t.TEXTURE_2D, w, v, y.width, y.height, 0, v, g, y.data);
            else if (_.length > 0 && m) {
                for (var w = 0, T = _.length; w < T; w++) y = _[w], i.texImage2D(t.TEXTURE_2D, w, v, v, g, y);
                n.generateMipmaps = !1
            } else i.texImage2D(t.TEXTURE_2D, 0, v, v, g, f);
            u(n, m) && t.generateMipmap(t.TEXTURE_2D), e.__version = n.version, n.onUpdate && n.onUpdate(n)
        }

        function w(e, r, a, o) {
            var h = s.convert(r.texture.format),
                l = s.convert(r.texture.type);
            i.texImage2D(o, 0, h, r.width, r.height, 0, h, l, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, a, o, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
        }

        function T(e, i) {
            t.bindRenderbuffer(t.RENDERBUFFER, e), i.depthBuffer && !i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : i.depthBuffer && i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, i.width, i.height), t.bindRenderbuffer(t.RENDERBUFFER, null)
        }

        function M(e, i) {
            if (i && i.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
            if (t.bindFramebuffer(t.FRAMEBUFFER, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), g(i.depthTexture, 0);
            var r = n.get(i.depthTexture).__webglTexture;
            if (i.depthTexture.format === Ja) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
            else {
                if (i.depthTexture.format !== Ka) throw new Error("Unknown depthTexture format");
                t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0)
            }
        }

        function E(e) {
            var i = n.get(e),
                r = !0 === e.isWebGLRenderTargetCube;
            if (e.depthTexture) {
                if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                M(i.__webglFramebuffer, e)
            } else if (r) {
                i.__webglDepthbuffer = [];
                for (var s = 0; s < 6; s++) t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer[s]), i.__webglDepthbuffer[s] = t.createRenderbuffer(), T(i.__webglDepthbuffer[s], e)
            } else t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), T(i.__webglDepthbuffer, e);
            t.bindFramebuffer(t.FRAMEBUFFER, null)
        }

        function S(e) {
            var r = n.get(e),
                s = n.get(e.texture);
            e.addEventListener("dispose", f), s.__webglTexture = t.createTexture(), a.textures++;
            var o = !0 === e.isWebGLRenderTargetCube,
                l = h(e);
            if (o) {
                r.__webglFramebuffer = [];
                for (var c = 0; c < 6; c++) r.__webglFramebuffer[c] = t.createFramebuffer()
            } else r.__webglFramebuffer = t.createFramebuffer();
            if (o) {
                i.bindTexture(t.TEXTURE_CUBE_MAP, s.__webglTexture), x(t.TEXTURE_CUBE_MAP, e.texture, l);
                for (var c = 0; c < 6; c++) w(r.__webglFramebuffer[c], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + c);
                u(e.texture, l) && t.generateMipmap(t.TEXTURE_CUBE_MAP), i.bindTexture(t.TEXTURE_CUBE_MAP, null)
            } else i.bindTexture(t.TEXTURE_2D, s.__webglTexture), x(t.TEXTURE_2D, e.texture, l), w(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), u(e.texture, l) && t.generateMipmap(t.TEXTURE_2D), i.bindTexture(t.TEXTURE_2D, null);
            e.depthBuffer && E(e)
        }

        function A(e) {
            var r = e.texture;
            if (u(r, h(e))) {
                var s = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                    a = n.get(r).__webglTexture;
                i.bindTexture(s, a), t.generateMipmap(s), i.bindTexture(s, null)
            }
        }
        var P = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext;
        this.setTexture2D = g, this.setTextureCube = y, this.setTextureCubeDynamic = _, this.setupRenderTarget = S, this.updateRenderTargetMipmap = A
    }

    function ve() {
        function t(t) {
            var e = t.uuid,
                i = n[e];
            return void 0 === i && (i = {}, n[e] = i), i
        }

        function e(t) {
            delete n[t.uuid]
        }

        function i() {
            n = {}
        }
        var n = {};
        return {
            get: t,
            remove: e,
            clear: i
        }
    }

    function ge(t, e, i) {
        function n() {
            var e = !1,
                i = new a,
                n = null,
                r = new a(0, 0, 0, 0);
            return {
                setMask: function(i) {
                    n === i || e || (t.colorMask(i, i, i, i), n = i)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e, n, s, a, o) {
                    !0 === o && (e *= a, n *= a, s *= a), i.set(e, n, s, a), !1 === r.equals(i) && (t.clearColor(e, n, s, a), r.copy(i))
                },
                reset: function() {
                    e = !1, n = null, r.set(-1, 0, 0, 0)
                }
            }
        }

        function r() {
            var e = !1,
                i = null,
                n = null,
                r = null;
            return {
                setTest: function(e) {
                    e ? d(t.DEPTH_TEST) : p(t.DEPTH_TEST)
                },
                setMask: function(n) {
                    i === n || e || (t.depthMask(n), i = n)
                },
                setFunc: function(e) {
                    if (n !== e) {
                        if (e) switch (e) {
                            case ea:
                                t.depthFunc(t.NEVER);
                                break;
                            case ia:
                                t.depthFunc(t.ALWAYS);
                                break;
                            case na:
                                t.depthFunc(t.LESS);
                                break;
                            case ra:
                                t.depthFunc(t.LEQUAL);
                                break;
                            case sa:
                                t.depthFunc(t.EQUAL);
                                break;
                            case aa:
                                t.depthFunc(t.GEQUAL);
                                break;
                            case oa:
                                t.depthFunc(t.GREATER);
                                break;
                            case ha:
                                t.depthFunc(t.NOTEQUAL);
                                break;
                            default:
                                t.depthFunc(t.LEQUAL)
                        } else t.depthFunc(t.LEQUAL);
                        n = e
                    }
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    r !== e && (t.clearDepth(e), r = e)
                },
                reset: function() {
                    e = !1, i = null, n = null, r = null
                }
            }
        }

        function s() {
            var e = !1,
                i = null,
                n = null,
                r = null,
                s = null,
                a = null,
                o = null,
                h = null,
                l = null;
            return {
                setTest: function(e) {
                    e ? d(t.STENCIL_TEST) : p(t.STENCIL_TEST)
                },
                setMask: function(n) {
                    i === n || e || (t.stencilMask(n), i = n)
                },
                setFunc: function(e, i, a) {
                    n === e && r === i && s === a || (t.stencilFunc(e, i, a), n = e, r = i, s = a)
                },
                setOp: function(e, i, n) {
                    a === e && o === i && h === n || (t.stencilOp(e, i, n), a = e, o = i, h = n)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    l !== e && (t.clearStencil(e), l = e)
                },
                reset: function() {
                    e = !1, i = null, n = null, r = null, s = null, a = null, o = null, h = null, l = null
                }
            }
        }

        function o(e, i, n) {
            var r = new Uint8Array(4),
                s = t.createTexture();
            t.bindTexture(e, s), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
            for (var a = 0; a < n; a++) t.texImage2D(i + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
            return s
        }

        function h() {
            for (var t = 0, e = D.length; t < e; t++) D[t] = 0
        }

        function l(i) {
            if (D[i] = 1, 0 === z[i] && (t.enableVertexAttribArray(i), z[i] = 1), 0 !== U[i]) {
                e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, 0), U[i] = 0
            }
        }

        function c(i, n) {
            if (D[i] = 1, 0 === z[i] && (t.enableVertexAttribArray(i), z[i] = 1), U[i] !== n) {
                e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, n), U[i] = n
            }
        }

        function u() {
            for (var e = 0, i = z.length; e !== i; ++e) z[e] !== D[e] && (t.disableVertexAttribArray(e), z[e] = 0)
        }

        function d(e) {
            !0 !== N[e] && (t.enable(e), N[e] = !0)
        }

        function p(e) {
            !1 !== N[e] && (t.disable(e), N[e] = !1)
        }

        function f() {
            if (null === k && (k = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1")))
                for (var i = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), n = 0; n < i.length; n++) k.push(i[n]);
            return k
        }

        function m(e) {
            return F !== e && (t.useProgram(e), F = e, !0)
        }

        function v(e, n, r, s, a, o, h, l) {
            if (e !== Is ? d(t.BLEND) : p(t.BLEND), e !== ks) {
                if (e !== B || l !== q) switch (e) {
                    case zs:
                        l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE));
                        break;
                    case Us:
                        l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                        break;
                    case Ns:
                        l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR));
                        break;
                    default:
                        l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA))
                }
                G = null, H = null, j = null, V = null, W = null, X = null
            } else a = a || n, o = o || r, h = h || s, n === G && a === V || (t.blendEquationSeparate(i.convert(n), i.convert(a)), G = n, V = a), r === H && s === j && o === W && h === X || (t.blendFuncSeparate(i.convert(r), i.convert(s), i.convert(o), i.convert(h)), H = r, j = s, W = o, X = h);
            B = e, q = l
        }

        function g(e) {
            e.side === As ? p(t.CULL_FACE) : d(t.CULL_FACE), y(e.side === Ss), !0 === e.transparent ? v(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : v(Is), L.setFunc(e.depthFunc), L.setTest(e.depthTest), L.setMask(e.depthWrite), C.setMask(e.colorWrite), b(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
        }

        function y(e) {
            Y !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), Y = e)
        }

        function _(e) {
            e !== vs ? (d(t.CULL_FACE), e !== Z && (e === gs ? t.cullFace(t.BACK) : e === ys ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : p(t.CULL_FACE), Z = e
        }

        function x(e) {
            e !== $ && (et && t.lineWidth(e), $ = e)
        }

        function b(e, i, n) {
            e ? (d(t.POLYGON_OFFSET_FILL), Q === i && J === n || (t.polygonOffset(i, n), Q = i, J = n)) : p(t.POLYGON_OFFSET_FILL)
        }

        function w(e) {
            e ? d(t.SCISSOR_TEST) : p(t.SCISSOR_TEST)
        }

        function T(e) {
            void 0 === e && (e = t.TEXTURE0 + K - 1), it !== e && (t.activeTexture(e), it = e)
        }

        function M(e, i) {
            null === it && T();
            var n = nt[it];
            void 0 === n && (n = {
                type: void 0,
                texture: void 0
            }, nt[it] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || at[e]), n.type = e, n.texture = i)
        }

        function E() {
            try {
                t.compressedTexImage2D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        }

        function S() {
            try {
                t.texImage2D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        }

        function A(e) {
            !1 === rt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), rt.copy(e))
        }

        function P(e) {
            !1 === st.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), st.copy(e))
        }

        function R() {
            for (var e = 0; e < z.length; e++) 1 === z[e] && (t.disableVertexAttribArray(e), z[e] = 0);
            N = {}, k = null, it = null, nt = {}, F = null, B = null, Y = null, Z = null, C.reset(), L.reset(), O.reset()
        }
        var C = new n,
            L = new r,
            O = new s,
            I = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            D = new Uint8Array(I),
            z = new Uint8Array(I),
            U = new Uint8Array(I),
            N = {},
            k = null,
            F = null,
            B = null,
            G = null,
            H = null,
            j = null,
            V = null,
            W = null,
            X = null,
            q = !1,
            Y = null,
            Z = null,
            $ = null,
            Q = null,
            J = null,
            K = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            tt = parseFloat(/^WebGL\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]),
            et = parseFloat(tt) >= 1,
            it = null,
            nt = {},
            rt = new a,
            st = new a,
            at = {};
        return at[t.TEXTURE_2D] = o(t.TEXTURE_2D, t.TEXTURE_2D, 1), at[t.TEXTURE_CUBE_MAP] = o(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), C.setClear(0, 0, 0, 1), L.setClear(1), O.setClear(0), d(t.DEPTH_TEST), L.setFunc(ra), y(!1), _(gs), d(t.CULL_FACE), d(t.BLEND), v(Ds), {
            buffers: {
                color: C,
                depth: L,
                stencil: O
            },
            initAttributes: h,
            enableAttribute: l,
            enableAttributeAndDivisor: c,
            disableUnusedAttributes: u,
            enable: d,
            disable: p,
            getCompressedTextureFormats: f,
            useProgram: m,
            setBlending: v,
            setMaterial: g,
            setFlipSided: y,
            setCullFace: _,
            setLineWidth: x,
            setPolygonOffset: b,
            setScissorTest: w,
            activeTexture: T,
            bindTexture: M,
            compressedTexImage2D: E,
            texImage2D: S,
            scissor: A,
            viewport: P,
            reset: R
        }
    }

    function ye(t, e, i) {
        function n() {
            if (void 0 !== s) return s;
            var i = e.get("EXT_texture_filter_anisotropic");
            return s = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
        }

        function r(e) {
            if ("highp" === e) {
                if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                e = "mediump"
            }
            return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        var s, a = void 0 !== i.precision ? i.precision : "highp",
            o = r(a);
        o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
        var h = !0 === i.logarithmicDepthBuffer && !!e.get("EXT_frag_depth"),
            l = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            c = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            u = t.getParameter(t.MAX_TEXTURE_SIZE),
            d = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            p = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
            m = t.getParameter(t.MAX_VARYING_VECTORS),
            v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
            g = c > 0,
            y = !!e.get("OES_texture_float");
        return {
            getMaxAnisotropy: n,
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: h,
            maxTextures: l,
            maxVertexTextures: c,
            maxTextureSize: u,
            maxCubemapSize: d,
            maxAttributes: p,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: v,
            vertexTextures: g,
            floatFragmentTextures: y,
            floatVertexTextures: g && y
        }
    }

    function _e(t) {
        mt.call(this), this.cameras = t || []
    }

    function xe(t) {
        function e() {
            if (null !== n && n.isPresenting) {
                var e = n.getEyeParameters("left"),
                    r = e.renderWidth,
                    s = e.renderHeight;
                f = t.getPixelRatio(), p = t.getSize(), t.setDrawingBufferSize(2 * r, s, 1)
            } else i.enabled && t.setDrawingBufferSize(p.width, p.height, f)
        }
        var i = this,
            n = null,
            r = null;
        "VRFrameData" in window && (r = new window.VRFrameData);
        var s = new u,
            o = new u,
            h = new u,
            l = new mt;
        l.bounds = new a(0, 0, .5, 1), l.layers.enable(1);
        var c = new mt;
        c.bounds = new a(.5, 0, .5, 1), c.layers.enable(2);
        var d = new _e([l, c]);
        d.layers.enable(1), d.layers.enable(2);
        var p, f;
        window.addEventListener("vrdisplaypresentchange", e, !1), this.enabled = !1, this.standing = !1, this.getDevice = function() {
            return n
        }, this.setDevice = function(t) {
            void 0 !== t && (n = t)
        }, this.getCamera = function(t) {
            if (null === n) return t;
            n.depthNear = t.near, n.depthFar = t.far, n.getFrameData(r);
            var e = r.pose;
            null !== e.position ? t.position.fromArray(e.position) : t.position.set(0, 0, 0), null !== e.orientation && t.quaternion.fromArray(e.orientation), t.updateMatrixWorld();
            var i = n.stageParameters;
            if (this.standing && i && (o.fromArray(i.sittingToStandingTransform), h.getInverse(o), t.matrixWorld.multiply(o), t.matrixWorldInverse.multiply(h)), !1 === n.isPresenting) return t;
            l.near = t.near, c.near = t.near, l.far = t.far, c.far = t.far, d.matrixWorld.copy(t.matrixWorld), d.matrixWorldInverse.copy(t.matrixWorldInverse), l.matrixWorldInverse.fromArray(r.leftViewMatrix), c.matrixWorldInverse.fromArray(r.rightViewMatrix), this.standing && i && (l.matrixWorldInverse.multiply(h), c.matrixWorldInverse.multiply(h));
            var a = t.parent;
            null !== a && (s.getInverse(a.matrixWorld), l.matrixWorldInverse.multiply(s), c.matrixWorldInverse.multiply(s)), l.matrixWorld.getInverse(l.matrixWorldInverse), c.matrixWorld.getInverse(c.matrixWorldInverse), l.projectionMatrix.fromArray(r.leftProjectionMatrix), c.projectionMatrix.fromArray(r.rightProjectionMatrix), d.projectionMatrix.copy(l.projectionMatrix);
            var u = n.getLayers();
            if (u.length) {
                var p = u[0];
                null !== p.leftBounds && 4 === p.leftBounds.length && l.bounds.fromArray(p.leftBounds), null !== p.rightBounds && 4 === p.rightBounds.length && c.bounds.fromArray(p.rightBounds)
            }
            return d
        }, this.getStandingMatrix = function() {
            return o
        }, this.submitFrame = function() {
            n && n.isPresenting && n.submitFrame()
        }, this.dispose = function() {
            window.removeEventListener("vrdisplaypresentchange", e)
        }
    }

    function be(t) {
        var e = {};
        return {
            get: function(i) {
                if (void 0 !== e[i]) return e[i];
                var n;
                switch (i) {
                    case "WEBGL_depth_texture":
                        n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    case "WEBGL_compressed_texture_etc1":
                        n = t.getExtension("WEBGL_compressed_texture_etc1");
                        break;
                    default:
                        n = t.getExtension(i)
                }
                return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n, n
            }
        }
    }

    function we() {
        function t() {
            l.value !== n && (l.value = n, l.needsUpdate = r > 0), i.numPlanes = r, i.numIntersection = 0
        }

        function e(t, e, n, r) {
            var s = null !== t ? t.length : 0,
                a = null;
            if (0 !== s) {
                if (a = l.value, !0 !== r || null === a) {
                    var c = n + 4 * s,
                        u = e.matrixWorldInverse;
                    h.getNormalMatrix(u), (null === a || a.length < c) && (a = new Float32Array(c));
                    for (var d = 0, p = n; d !== s; ++d, p += 4) o.copy(t[d]).applyMatrix4(u, h), o.normal.toArray(a, p), a[p + 3] = o.constant
                }
                l.value = a, l.needsUpdate = !0
            }
            return i.numPlanes = s, a
        }
        var i = this,
            n = null,
            r = 0,
            s = !1,
            a = !1,
            o = new at,
            h = new st,
            l = {
                value: null,
                needsUpdate: !1
            };
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, i, a) {
            var o = 0 !== t.length || i || 0 !== r || s;
            return s = i, n = e(t, a, 0), r = t.length, o
        }, this.beginShadows = function() {
            a = !0, e(null)
        }, this.endShadows = function() {
            a = !1, t()
        }, this.setState = function(i, o, h, c, u, d) {
            if (!s || null === i || 0 === i.length || a && !h) a ? e(null) : t();
            else {
                var p = a ? 0 : r,
                    f = 4 * p,
                    m = u.clippingState || null;
                l.value = m, m = e(i, c, f, d);
                for (var v = 0; v !== f; ++v) m[v] = n[v];
                u.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += p
            }
        }
    }

    function Te(t, e) {
        function i(i) {
            var n;
            if (i === Ea) return t.REPEAT;
            if (i === Sa) return t.CLAMP_TO_EDGE;
            if (i === Aa) return t.MIRRORED_REPEAT;
            if (i === Pa) return t.NEAREST;
            if (i === Ra) return t.NEAREST_MIPMAP_NEAREST;
            if (i === Ca) return t.NEAREST_MIPMAP_LINEAR;
            if (i === La) return t.LINEAR;
            if (i === Oa) return t.LINEAR_MIPMAP_NEAREST;
            if (i === Ia) return t.LINEAR_MIPMAP_LINEAR;
            if (i === Da) return t.UNSIGNED_BYTE;
            if (i === Ha) return t.UNSIGNED_SHORT_4_4_4_4;
            if (i === ja) return t.UNSIGNED_SHORT_5_5_5_1;
            if (i === Va) return t.UNSIGNED_SHORT_5_6_5;
            if (i === za) return t.BYTE;
            if (i === Ua) return t.SHORT;
            if (i === Na) return t.UNSIGNED_SHORT;
            if (i === ka) return t.INT;
            if (i === Fa) return t.UNSIGNED_INT;
            if (i === Ba) return t.FLOAT;
            if (i === Ga && null !== (n = e.get("OES_texture_half_float"))) return n.HALF_FLOAT_OES;
            if (i === Xa) return t.ALPHA;
            if (i === qa) return t.RGB;
            if (i === Ya) return t.RGBA;
            if (i === Za) return t.LUMINANCE;
            if (i === $a) return t.LUMINANCE_ALPHA;
            if (i === Ja) return t.DEPTH_COMPONENT;
            if (i === Ka) return t.DEPTH_STENCIL;
            if (i === Fs) return t.FUNC_ADD;
            if (i === Bs) return t.FUNC_SUBTRACT;
            if (i === Gs) return t.FUNC_REVERSE_SUBTRACT;
            if (i === Vs) return t.ZERO;
            if (i === Ws) return t.ONE;
            if (i === Xs) return t.SRC_COLOR;
            if (i === qs) return t.ONE_MINUS_SRC_COLOR;
            if (i === Ys) return t.SRC_ALPHA;
            if (i === Zs) return t.ONE_MINUS_SRC_ALPHA;
            if (i === $s) return t.DST_ALPHA;
            if (i === Qs) return t.ONE_MINUS_DST_ALPHA;
            if (i === Js) return t.DST_COLOR;
            if (i === Ks) return t.ONE_MINUS_DST_COLOR;
            if (i === ta) return t.SRC_ALPHA_SATURATE;
            if ((i === to || i === eo || i === io || i === no) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) {
                if (i === to) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (i === eo) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (i === io) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (i === no) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if ((i === ro || i === so || i === ao || i === oo) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) {
                if (i === ro) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (i === so) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (i === ao) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (i === oo) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (i === ho && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
            if ((i === Hs || i === js) && null !== (n = e.get("EXT_blend_minmax"))) {
                if (i === Hs) return n.MIN_EXT;
                if (i === js) return n.MAX_EXT
            }
            return i === Wa && null !== (n = e.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : 0
        }
        return {
            convert: i
        }
    }

    function Me(t) {
        function e() {
            return null === tt ? mt : 1
        }

        function i() {
            Rt = new be(At), Rt.get("WEBGL_depth_texture"), Rt.get("OES_texture_float"), Rt.get("OES_texture_float_linear"), Rt.get("OES_texture_half_float"), Rt.get("OES_texture_half_float_linear"), Rt.get("OES_standard_derivatives"), Rt.get("ANGLE_instanced_arrays"), Rt.get("OES_element_index_uint") && (Lt.MaxIndex = 4294967296), ee = new Te(At, Rt), Ct = new ye(At, Rt, t), Ot = new ge(At, Rt, ee), Ot.scissor(ct.copy(gt).multiplyScalar(mt)), Ot.viewport(at.copy(vt).multiplyScalar(mt)), It = new ve, Dt = new me(At, Rt, Ot, It, Ct, ee, Et), zt = new lt(At), Ut = new $t(At, zt, Et), Nt = new Kt(Ut, St), jt = new qt(At), Ft = new fe(Q, Rt, Ct), kt = new Jt, Bt = new Wt, Ht = new Gt(Q, Ot, Ut, H), Vt = new Zt(At, Rt, St), Xt = new Yt(At, Rt, St), Qt = new $(Q, At, Ot, Dt, Ct), te = new J(Q, At, Ot, Dt, Ct), Q.info.programs = Ft.programs, Q.context = At, Q.capabilities = Ct, Q.extensions = Rt, Q.properties = It, Q.renderLists = Bt, Q.state = Ot
        }

        function n(t) {
            t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), K = !0
        }

        function r(t) {
            console.log("THREE.WebGLRenderer: Context Restored."), K = !1, i()
        }

        function s(t) {
            var e = t.target;
            e.removeEventListener("dispose", s), o(e)
        }

        function o(t) {
            h(t), It.remove(t)
        }

        function h(t) {
            var e = It.get(t).program;
            t.program = void 0, void 0 !== e && Ft.releaseProgram(e)
        }

        function l(t, e, i) {
            t.render(function(t) {
                Q.renderBufferImmediate(t, e, i)
            })
        }

        function p(t, e, i, n) {
            if (i && i.isInstancedBufferGeometry && null === Rt.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            void 0 === n && (n = 0), Ot.initAttributes();
            var r = i.attributes,
                s = e.getAttributes(),
                a = t.defaultAttributeValues;
            for (var o in s) {
                var h = s[o];
                if (h >= 0) {
                    var l = r[o];
                    if (void 0 !== l) {
                        var c = l.normalized,
                            u = l.itemSize,
                            d = zt.get(l);
                        if (void 0 === d) continue;
                        var p = d.buffer,
                            f = d.type,
                            m = d.bytesPerElement;
                        if (l.isInterleavedBufferAttribute) {
                            var v = l.data,
                                g = v.stride,
                                y = l.offset;
                            v && v.isInstancedInterleavedBuffer ? (Ot.enableAttributeAndDivisor(h, v.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = v.meshPerAttribute * v.count)) : Ot.enableAttribute(h), At.bindBuffer(At.ARRAY_BUFFER, p), At.vertexAttribPointer(h, u, f, c, g * m, (n * g + y) * m)
                        } else l.isInstancedBufferAttribute ? (Ot.enableAttributeAndDivisor(h, l.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = l.meshPerAttribute * l.count)) : Ot.enableAttribute(h), At.bindBuffer(At.ARRAY_BUFFER, p), At.vertexAttribPointer(h, u, f, c, 0, n * u * m)
                    } else if (void 0 !== a) {
                        var _ = a[o];
                        if (void 0 !== _) switch (_.length) {
                            case 2:
                                At.vertexAttrib2fv(h, _);
                                break;
                            case 3:
                                At.vertexAttrib3fv(h, _);
                                break;
                            case 4:
                                At.vertexAttrib4fv(h, _);
                                break;
                            default:
                                At.vertexAttrib1fv(h, _)
                        }
                    }
                }
            }
            Ot.disableUnusedAttributes()
        }

        function f() {
            re || ((ie.getDevice() || window).requestAnimationFrame(m), re = !0)
        }

        function m(t) {
            null !== se && se(t), (ie.getDevice() || window).requestAnimationFrame(m)
        }

        function v(t, e, i) {
            if (t.visible) {
                if (t.layers.test(e.layers))
                    if (t.isLight) V.push(t), t.castShadow && W.push(t);
                    else if (t.isSprite) t.frustumCulled && !_t.intersectsSprite(t) || Y.push(t);
                else if (t.isLensFlare) Z.push(t);
                else if (t.isImmediateRenderObject) i && Mt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Tt), X.push(t, null, t.material, Mt.z, null);
                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || _t.intersectsObject(t))) {
                    i && Mt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Tt);
                    var n = Nt.update(t),
                        r = t.material;
                    if (Array.isArray(r))
                        for (var s = n.groups, a = 0, o = s.length; a < o; a++) {
                            var h = s[a],
                                l = r[h.materialIndex];
                            l && l.visible && X.push(t, n, l, Mt.z, h)
                        } else r.visible && X.push(t, n, r, Mt.z, null)
                }
                for (var c = t.children, a = 0, o = c.length; a < o; a++) v(c[a], e, i)
            }
        }

        function g(t, e, i, n) {
            for (var r = 0, s = t.length; r < s; r++) {
                var a = t[r],
                    o = a.object,
                    h = a.geometry,
                    l = void 0 === n ? a.material : n,
                    c = a.group;
                if (i.isArrayCamera) {
                    st = i;
                    for (var u = i.cameras, d = 0, p = u.length; d < p; d++) {
                        var f = u[d];
                        if (o.layers.test(f.layers)) {
                            var m = f.bounds,
                                v = m.x * pt,
                                g = m.y * ft,
                                _ = m.z * pt,
                                x = m.w * ft;
                            Ot.viewport(at.set(v, g, _, x).multiplyScalar(mt)), y(o, e, f, h, l, c)
                        }
                    }
                } else st = null, y(o, e, i, h, l, c)
            }
        }

        function y(t, e, i, n, r, s) {
            if (t.onBeforeRender(Q, e, i, n, r, s), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                Ot.setMaterial(r);
                var a = x(i, e.fog, r, t);
                nt = "", l(t, a, r)
            } else Q.renderBufferDirect(i, e.fog, n, r, t, s);
            t.onAfterRender(Q, e, i, n, r, s)
        }

        function _(t, e, i) {
            var n = It.get(t),
                r = Ft.getParameters(t, kt.state, W, e, xt.numPlanes, xt.numIntersection, i),
                a = Ft.getProgramCode(t, r),
                o = n.program,
                l = !0;
            if (void 0 === o) t.addEventListener("dispose", s);
            else if (o.code !== a) h(t);
            else {
                if (void 0 !== r.shaderID) return;
                l = !1
            }
            if (l) {
                if (r.shaderID) {
                    var c = Wo[r.shaderID];
                    n.shader = {
                        name: t.type,
                        uniforms: jo.clone(c.uniforms),
                        vertexShader: c.vertexShader,
                        fragmentShader: c.fragmentShader
                    }
                } else n.shader = {
                    name: t.type,
                    uniforms: t.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                };
                t.onBeforeCompile(n.shader), o = Ft.acquireProgram(t, n.shader, r, a), n.program = o, t.program = o
            }
            var u = o.getAttributes();
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                for (var d = 0; d < Q.maxMorphTargets; d++) u["morphTarget" + d] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals) {
                t.numSupportedMorphNormals = 0;
                for (var d = 0; d < Q.maxMorphNormals; d++) u["morphNormal" + d] >= 0 && t.numSupportedMorphNormals++
            }
            var p = n.shader.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = xt.numPlanes, n.numIntersection = xt.numIntersection, p.clippingPlanes = xt.uniform), n.fog = e, n.lightsHash = kt.state.hash, t.lights && (p.ambientLightColor.value = kt.state.ambient, p.directionalLights.value = kt.state.directional, p.spotLights.value = kt.state.spot, p.rectAreaLights.value = kt.state.rectArea, p.pointLights.value = kt.state.point, p.hemisphereLights.value = kt.state.hemi, p.directionalShadowMap.value = kt.state.directionalShadowMap, p.directionalShadowMatrix.value = kt.state.directionalShadowMatrix, p.spotShadowMap.value = kt.state.spotShadowMap, p.spotShadowMatrix.value = kt.state.spotShadowMatrix, p.pointShadowMap.value = kt.state.pointShadowMap, p.pointShadowMatrix.value = kt.state.pointShadowMatrix);
            var f = n.program.getUniforms(),
                m = q.seqWithValue(f.seq, p);
            n.uniformsList = m
        }

        function x(t, e, i, n) {
            dt = 0;
            var r = It.get(i);
            if (bt && (wt || t !== rt)) {
                var s = t === rt && i.id === it;
                xt.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, s)
            }!1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : i.lights && r.lightsHash !== kt.state.hash ? i.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === xt.numPlanes && r.numIntersection === xt.numIntersection || (i.needsUpdate = !0)), i.needsUpdate && (_(i, e, n), i.needsUpdate = !1);
            var a = !1,
                o = !1,
                h = !1,
                l = r.program,
                c = l.getUniforms(),
                u = r.shader.uniforms;
            if (Ot.useProgram(l.program) && (a = !0, o = !0, h = !0), i.id !== it && (it = i.id, o = !0), a || t !== rt) {
                if (c.setValue(At, "projectionMatrix", t.projectionMatrix), Ct.logarithmicDepthBuffer && c.setValue(At, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), rt !== (st || t) && (rt = st || t, o = !0, h = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                    var p = c.map.cameraPosition;
                    void 0 !== p && p.setValue(At, Mt.setFromMatrixPosition(t.matrixWorld))
                }(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && c.setValue(At, "viewMatrix", t.matrixWorldInverse)
            }
            if (i.skinning) {
                c.setOptional(At, n, "bindMatrix"), c.setOptional(At, n, "bindMatrixInverse");
                var f = n.skeleton;
                if (f) {
                    var m = f.bones;
                    if (Ct.floatVertexTextures) {
                        if (void 0 === f.boneTexture) {
                            var v = Math.sqrt(4 * m.length);
                            v = Oo.nextPowerOfTwo(Math.ceil(v)), v = Math.max(v, 4);
                            var g = new Float32Array(v * v * 4);
                            g.set(f.boneMatrices);
                            var y = new d(g, v, v, Ya, Ba);
                            f.boneMatrices = g, f.boneTexture = y, f.boneTextureSize = v
                        }
                        c.setValue(At, "boneTexture", f.boneTexture), c.setValue(At, "boneTextureSize", f.boneTextureSize)
                    } else c.setOptional(At, f, "boneMatrices")
                }
            }
            return o && (c.setValue(At, "toneMappingExposure", Q.toneMappingExposure), c.setValue(At, "toneMappingWhitePoint", Q.toneMappingWhitePoint), i.lights && D(u, h), e && i.fog && E(u, e), i.isMeshBasicMaterial ? b(u, i) : i.isMeshLambertMaterial ? (b(u, i), S(u, i)) : i.isMeshPhongMaterial ? (b(u, i), i.isMeshToonMaterial ? P(u, i) : A(u, i)) : i.isMeshStandardMaterial ? (b(u, i), i.isMeshPhysicalMaterial ? C(u, i) : R(u, i)) : i.isMeshDepthMaterial ? (b(u, i), L(u, i)) : i.isMeshDistanceMaterial ? (b(u, i), O(u, i)) : i.isMeshNormalMaterial ? (b(u, i), I(u, i)) : i.isLineBasicMaterial ? (w(u, i), i.isLineDashedMaterial && T(u, i)) : i.isPointsMaterial ? M(u, i) : i.isShadowMaterial && (u.color.value = i.color, u.opacity.value = i.opacity), void 0 !== u.ltcMat && (u.ltcMat.value = Ho.LTC_MAT_TEXTURE), void 0 !== u.ltcMag && (u.ltcMag.value = Ho.LTC_MAG_TEXTURE), q.upload(At, r.uniformsList, u, Q)), c.setValue(At, "modelViewMatrix", n.modelViewMatrix), c.setValue(At, "normalMatrix", n.normalMatrix), c.setValue(At, "modelMatrix", n.matrixWorld), l
        }

        function b(t, e) {
            t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity);
            var i;
            if (e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i) {
                i.isWebGLRenderTarget && (i = i.texture);
                var n = i.offset,
                    r = i.repeat;
                t.offsetRepeat.value.set(n.x, n.y, r.x, r.y)
            }
        }

        function w(t, e) {
            t.diffuse.value = e.color, t.opacity.value = e.opacity
        }

        function T(t, e) {
            t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
        }

        function M(t, e) {
            if (t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * mt, t.scale.value = .5 * ft, t.map.value = e.map, null !== e.map) {
                var i = e.map.offset,
                    n = e.map.repeat;
                t.offsetRepeat.value.set(i.x, i.y, n.x, n.y)
            }
        }

        function E(t, e) {
            t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
        }

        function S(t, e) {
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
        }

        function A(t, e) {
            t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }

        function P(t, e) {
            A(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
        }

        function R(t, e) {
            t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
        }

        function C(t, e) {
            t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness, R(t, e)
        }

        function L(t, e) {
            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }

        function O(t, e) {
            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
        }

        function I(t, e) {
            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }

        function D(t, e) {
            t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
        }

        function z() {
            var t = dt;
            return t >= Ct.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + Ct.maxTextures), dt += 1, t
        }
        console.log("THREE.WebGLRenderer", fs), t = t || {};
        var U = void 0 !== t.canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            N = void 0 !== t.context ? t.context : null,
            k = void 0 !== t.alpha && t.alpha,
            F = void 0 === t.depth || t.depth,
            B = void 0 === t.stencil || t.stencil,
            G = void 0 !== t.antialias && t.antialias,
            H = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            j = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            V = [],
            W = [],
            X = null,
            Y = [],
            Z = [];
        this.domElement = U, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = pa, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var Q = this,
            K = !1,
            tt = null,
            et = null,
            it = -1,
            nt = "",
            rt = null,
            st = null,
            at = new a,
            ct = new a,
            ut = null,
            dt = 0,
            pt = U.width,
            ft = U.height,
            mt = 1,
            vt = new a(0, 0, pt, ft),
            gt = new a(0, 0, pt, ft),
            yt = !1,
            _t = new ot,
            xt = new we,
            bt = !1,
            wt = !1,
            Tt = new u,
            Mt = new c,
            Et = {
                geometries: 0,
                textures: 0
            },
            St = {
                frame: 0,
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            };
        this.info = {
            render: St,
            memory: Et,
            programs: null
        };
        var At;
        try {
            var Pt = {
                alpha: k,
                depth: F,
                stencil: B,
                antialias: G,
                premultipliedAlpha: H,
                preserveDrawingBuffer: j
            };
            if (null === (At = N || U.getContext("webgl", Pt) || U.getContext("experimental-webgl", Pt))) throw null !== U.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
            void 0 === At.getShaderPrecisionFormat && (At.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }), U.addEventListener("webglcontextlost", n, !1), U.addEventListener("webglcontextrestored", r, !1)
        } catch (t) {
            console.error("THREE.WebGLRenderer: " + t)
        }
        var Rt, Ct, Ot, It, Dt, zt, Ut, Nt, kt, Ft, Bt, Ht, jt, Vt, Xt, Qt, te, ee;
        i();
        var ie = new xe(Q);
        this.vr = ie;
        var ne = new ht(Q, Nt, Ct.maxTextureSize);
        this.shadowMap = ne, this.getContext = function() {
            return At
        }, this.getContextAttributes = function() {
            return At.getContextAttributes()
        }, this.forceContextLoss = function() {
            var t = Rt.get("WEBGL_lose_context");
            t && t.loseContext()
        }, this.forceContextRestore = function() {
            var t = Rt.get("WEBGL_lose_context");
            t && t.restoreContext()
        }, this.getPixelRatio = function() {
            return mt
        }, this.setPixelRatio = function(t) {
            void 0 !== t && (mt = t, this.setSize(pt, ft, !1))
        }, this.getSize = function() {
            return {
                width: pt,
                height: ft
            }
        }, this.setSize = function(t, e, i) {
            var n = ie.getDevice();
            if (n && n.isPresenting) return void console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            pt = t, ft = e, U.width = t * mt, U.height = e * mt, !1 !== i && (U.style.width = t + "px", U.style.height = e + "px"), this.setViewport(0, 0, t, e)
        }, this.getDrawingBufferSize = function() {
            return {
                width: pt * mt,
                height: ft * mt
            }
        }, this.setDrawingBufferSize = function(t, e, i) {
            pt = t, ft = e, mt = i, U.width = t * i, U.height = e * i, this.setViewport(0, 0, t, e)
        }, this.setViewport = function(t, e, i, n) {
            vt.set(t, ft - e - n, i, n), Ot.viewport(at.copy(vt).multiplyScalar(mt))
        }, this.setScissor = function(t, e, i, n) {
            gt.set(t, ft - e - n, i, n), Ot.scissor(ct.copy(gt).multiplyScalar(mt))
        }, this.setScissorTest = function(t) {
            Ot.setScissorTest(yt = t)
        }, this.getClearColor = Ht.getClearColor, this.setClearColor = Ht.setClearColor, this.getClearAlpha = Ht.getClearAlpha, this.setClearAlpha = Ht.setClearAlpha, this.clear = function(t, e, i) {
            var n = 0;
            (void 0 === t || t) && (n |= At.COLOR_BUFFER_BIT), (void 0 === e || e) && (n |= At.DEPTH_BUFFER_BIT), (void 0 === i || i) && (n |= At.STENCIL_BUFFER_BIT), At.clear(n)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.clearTarget = function(t, e, i, n) {
            this.setRenderTarget(t), this.clear(e, i, n)
        }, this.dispose = function() {
            U.removeEventListener("webglcontextlost", n, !1), U.removeEventListener("webglcontextrestored", r, !1), Bt.dispose(), ie.dispose()
        }, this.renderBufferImmediate = function(t, e, i) {
            Ot.initAttributes();
            var n = It.get(t);
            t.hasPositions && !n.position && (n.position = At.createBuffer()), t.hasNormals && !n.normal && (n.normal = At.createBuffer()), t.hasUvs && !n.uv && (n.uv = At.createBuffer()), t.hasColors && !n.color && (n.color = At.createBuffer());
            var r = e.getAttributes();
            if (t.hasPositions && (At.bindBuffer(At.ARRAY_BUFFER, n.position), At.bufferData(At.ARRAY_BUFFER, t.positionArray, At.DYNAMIC_DRAW), Ot.enableAttribute(r.position), At.vertexAttribPointer(r.position, 3, At.FLOAT, !1, 0, 0)), t.hasNormals) {
                if (At.bindBuffer(At.ARRAY_BUFFER, n.normal), !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && !i.isMeshNormalMaterial && !0 === i.flatShading)
                    for (var s = 0, a = 3 * t.count; s < a; s += 9) {
                        var o = t.normalArray,
                            h = (o[s + 0] + o[s + 3] + o[s + 6]) / 3,
                            l = (o[s + 1] + o[s + 4] + o[s + 7]) / 3,
                            c = (o[s + 2] + o[s + 5] + o[s + 8]) / 3;
                        o[s + 0] = h, o[s + 1] = l, o[s + 2] = c, o[s + 3] = h, o[s + 4] = l, o[s + 5] = c, o[s + 6] = h, o[s + 7] = l, o[s + 8] = c
                    }
                At.bufferData(At.ARRAY_BUFFER, t.normalArray, At.DYNAMIC_DRAW), Ot.enableAttribute(r.normal), At.vertexAttribPointer(r.normal, 3, At.FLOAT, !1, 0, 0)
            }
            t.hasUvs && i.map && (At.bindBuffer(At.ARRAY_BUFFER, n.uv), At.bufferData(At.ARRAY_BUFFER, t.uvArray, At.DYNAMIC_DRAW), Ot.enableAttribute(r.uv), At.vertexAttribPointer(r.uv, 2, At.FLOAT, !1, 0, 0)), t.hasColors && i.vertexColors !== Cs && (At.bindBuffer(At.ARRAY_BUFFER, n.color), At.bufferData(At.ARRAY_BUFFER, t.colorArray, At.DYNAMIC_DRAW), Ot.enableAttribute(r.color), At.vertexAttribPointer(r.color, 3, At.FLOAT, !1, 0, 0)), Ot.disableUnusedAttributes(), At.drawArrays(At.TRIANGLES, 0, t.count), t.count = 0
        }, this.renderBufferDirect = function(t, i, n, r, s, a) {
            Ot.setMaterial(r);
            var o = x(t, i, r, s),
                h = n.id + "_" + o.id + "_" + (!0 === r.wireframe),
                l = !1;
            h !== nt && (nt = h, l = !0), s.morphTargetInfluences && (jt.update(s, n, r, o), l = !0);
            var c = n.index,
                u = n.attributes.position,
                d = 1;
            !0 === r.wireframe && (c = Ut.getWireframeAttribute(n), d = 2);
            var f, m = Vt;
            null !== c && (f = zt.get(c), m = Xt, m.setIndex(f)), l && (p(r, o, n), null !== c && At.bindBuffer(At.ELEMENT_ARRAY_BUFFER, f.buffer));
            var v = 0;
            null !== c ? v = c.count : void 0 !== u && (v = u.count);
            var g = n.drawRange.start * d,
                y = n.drawRange.count * d,
                _ = null !== a ? a.start * d : 0,
                b = null !== a ? a.count * d : 1 / 0,
                w = Math.max(g, _),
                T = Math.min(v, g + y, _ + b) - 1,
                M = Math.max(0, T - w + 1);
            if (0 !== M) {
                if (s.isMesh)
                    if (!0 === r.wireframe) Ot.setLineWidth(r.wireframeLinewidth * e()), m.setMode(At.LINES);
                    else switch (s.drawMode) {
                        case _o:
                            m.setMode(At.TRIANGLES);
                            break;
                        case xo:
                            m.setMode(At.TRIANGLE_STRIP);
                            break;
                        case bo:
                            m.setMode(At.TRIANGLE_FAN)
                    } else if (s.isLine) {
                        var E = r.linewidth;
                        void 0 === E && (E = 1), Ot.setLineWidth(E * e()), s.isLineSegments ? m.setMode(At.LINES) : s.isLineLoop ? m.setMode(At.LINE_LOOP) : m.setMode(At.LINE_STRIP)
                    } else s.isPoints && m.setMode(At.POINTS);
                n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && m.renderInstances(n, w, M) : m.render(w, M)
            }
        }, this.compile = function(t, e) {
            V.length = 0, W.length = 0, t.traverse(function(t) {
                t.isLight && (V.push(t), t.castShadow && W.push(t))
            }), kt.setup(V, W, e), t.traverse(function(e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var i = 0; i < e.material.length; i++) _(e.material[i], t.fog, e);
                    else _(e.material, t.fog, e)
            })
        };
        var re = !1,
            se = null;
        this.animate = function(t) {
            se = t, f()
        }, this.render = function(t, e, i, n) {
            if (!e || !e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!K) {
                nt = "", it = -1, rt = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), ie.enabled && (e = ie.getCamera(e)), Tt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), _t.setFromMatrix(Tt), V.length = 0, W.length = 0, Y.length = 0, Z.length = 0, wt = this.localClippingEnabled, bt = xt.init(this.clippingPlanes, wt, e), X = Bt.get(t, e), X.init(), v(t, e, Q.sortObjects), !0 === Q.sortObjects && X.sort(), bt && xt.beginShadows(), ne.render(W, t, e), kt.setup(V, W, e), bt && xt.endShadows(), St.frame++, St.calls = 0, St.vertices = 0, St.faces = 0, St.points = 0, void 0 === i && (i = null), this.setRenderTarget(i), Ht.render(X, t, e, n);
                var r = X.opaque,
                    s = X.transparent;
                if (t.overrideMaterial) {
                    var a = t.overrideMaterial;
                    r.length && g(r, t, e, a), s.length && g(s, t, e, a)
                } else r.length && g(r, t, e), s.length && g(s, t, e);
                te.render(Y, t, e), Qt.render(Z, t, e, at), i && Dt.updateRenderTargetMipmap(i), Ot.buffers.depth.setTest(!0), Ot.buffers.depth.setMask(!0), Ot.buffers.color.setMask(!0), Ot.setPolygonOffset(!1), ie.enabled && ie.submitFrame()
            }
        }, this.setFaceCulling = function(t, e) {
            Ot.setCullFace(t), Ot.setFlipSided(e === xs)
        }, this.allocTextureUnit = z, this.setTexture2D = function() {
            var t = !1;
            return function(e, i) {
                e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), Dt.setTexture2D(e, i)
            }
        }(), this.setTexture = function() {
            var t = !1;
            return function(e, i) {
                t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), Dt.setTexture2D(e, i)
            }
        }(), this.setTextureCube = function() {
            var t = !1;
            return function(e, i) {
                e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? Dt.setTextureCube(e, i) : Dt.setTextureCubeDynamic(e, i)
            }
        }(), this.getRenderTarget = function() {
            return tt
        }, this.setRenderTarget = function(t) {
            tt = t, t && void 0 === It.get(t).__webglFramebuffer && Dt.setupRenderTarget(t);
            var e = null,
                i = !1;
            if (t) {
                var n = It.get(t).__webglFramebuffer;
                t.isWebGLRenderTargetCube ? (e = n[t.activeCubeFace], i = !0) : e = n, at.copy(t.viewport), ct.copy(t.scissor), ut = t.scissorTest
            } else at.copy(vt).multiplyScalar(mt), ct.copy(gt).multiplyScalar(mt), ut = yt;
            if (et !== e && (At.bindFramebuffer(At.FRAMEBUFFER, e), et = e), Ot.viewport(at), Ot.scissor(ct), Ot.setScissorTest(ut), i) {
                var r = It.get(t.texture);
                At.framebufferTexture2D(At.FRAMEBUFFER, At.COLOR_ATTACHMENT0, At.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
            }
        }, this.readRenderTargetPixels = function(t, e, i, n, r, s) {
            if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            var a = It.get(t).__webglFramebuffer;
            if (a) {
                var o = !1;
                a !== et && (At.bindFramebuffer(At.FRAMEBUFFER, a), o = !0);
                try {
                    var h = t.texture,
                        l = h.format,
                        c = h.type;
                    if (l !== Ya && ee.convert(l) !== At.getParameter(At.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    if (!(c === Da || ee.convert(c) === At.getParameter(At.IMPLEMENTATION_COLOR_READ_TYPE) || c === Ba && (Rt.get("OES_texture_float") || Rt.get("WEBGL_color_buffer_float")) || c === Ga && Rt.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    At.checkFramebufferStatus(At.FRAMEBUFFER) === At.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && At.readPixels(e, i, n, r, ee.convert(l), ee.convert(c), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                } finally {
                    o && At.bindFramebuffer(At.FRAMEBUFFER, et)
                }
            }
        }
    }

    function Ee(t, e) {
        this.name = "", this.color = new Y(t), this.density = void 0 !== e ? e : 25e-5
    }

    function Se(t, e, i) {
        this.name = "", this.color = new Y(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
    }

    function Ae() {
        dt.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
    }

    function Pe(t, e, i, n, r) {
        dt.call(this), this.lensFlares = [], this.positionScreen = new c, this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, i, n, r)
    }

    function Re(t) {
        K.call(this), this.type = "SpriteMaterial", this.color = new Y(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(t)
    }

    function Ce(t) {
        dt.call(this), this.type = "Sprite", this.material = void 0 !== t ? t : new Re
    }

    function Le() {
        dt.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }

    function Oe(t, e) {
        if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new u)
        }
    }

    function Ie() {
        dt.call(this), this.type = "Bone"
    }

    function De(t, e) {
        Bt.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new u, this.bindMatrixInverse = new u;
        var i = this.initBones(),
            n = new Oe(i);
        this.bind(n, this.matrixWorld), this.normalizeSkinWeights()
    }

    function ze(t) {
        K.call(this), this.type = "LineBasicMaterial", this.color = new Y(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
    }

    function Ue(t, e, i) {
        if (1 === i) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new Ne(t, e);
        dt.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Lt, this.material = void 0 !== e ? e : new ze({
            color: 16777215 * Math.random()
        })
    }

    function Ne(t, e) {
        Ue.call(this, t, e), this.type = "LineSegments"
    }

    function ke(t, e) {
        Ue.call(this, t, e), this.type = "LineLoop"
    }

    function Fe(t) {
        K.call(this), this.type = "PointsMaterial", this.color = new Y(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t)
    }

    function Be(t, e) {
        dt.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Lt, this.material = void 0 !== e ? e : new Fe({
            color: 16777215 * Math.random()
        })
    }

    function Ge() {
        dt.call(this), this.type = "Group"
    }

    function He(t, e, i, n, r, a, o, h, l) {
        function c() {
            requestAnimationFrame(c), t.readyState >= t.HAVE_CURRENT_DATA && (u.needsUpdate = !0)
        }
        s.call(this, t, e, i, n, r, a, o, h, l), this.generateMipmaps = !1;
        var u = this;
        c()
    }

    function je(t, e, i, n, r, a, o, h, l, c, u, d) {
        s.call(this, null, a, o, h, l, c, n, r, u, d), this.image = {
            width: e,
            height: i
        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
    }

    function Ve(t, e, i, n, r, a, o, h, l, c) {
        if ((c = void 0 !== c ? c : Ja) !== Ja && c !== Ka) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && c === Ja && (i = Na), void 0 === i && c === Ka && (i = Wa), s.call(this, null, n, r, a, o, h, c, i, l), this.image = {
            width: t,
            height: e
        }, this.magFilter = void 0 !== o ? o : Pa, this.minFilter = void 0 !== h ? h : Pa, this.flipY = !1, this.generateMipmaps = !1
    }

    function We(t) {
        Lt.call(this), this.type = "WireframeGeometry";
        var e, i, n, r, s, a, o, h, l, u, d = [],
            p = [0, 0],
            f = {},
            m = ["a", "b", "c"];
        if (t && t.isGeometry) {
            var v = t.faces;
            for (e = 0, n = v.length; e < n; e++) {
                var g = v[e];
                for (i = 0; i < 3; i++) o = g[m[i]], h = g[m[(i + 1) % 3]], p[0] = Math.min(o, h), p[1] = Math.max(o, h), l = p[0] + "," + p[1], void 0 === f[l] && (f[l] = {
                    index1: p[0],
                    index2: p[1]
                })
            }
            for (l in f) a = f[l], u = t.vertices[a.index1], d.push(u.x, u.y, u.z), u = t.vertices[a.index2], d.push(u.x, u.y, u.z)
        } else if (t && t.isBufferGeometry) {
            var y, _, x, b, w, T, M, E;
            if (u = new c, null !== t.index) {
                for (y = t.attributes.position, _ = t.index, x = t.groups, 0 === x.length && (x = [{
                        start: 0,
                        count: _.count,
                        materialIndex: 0
                    }]), r = 0, s = x.length; r < s; ++r)
                    for (b = x[r], w = b.start, T = b.count, e = w, n = w + T; e < n; e += 3)
                        for (i = 0; i < 3; i++) o = _.getX(e + i), h = _.getX(e + (i + 1) % 3), p[0] = Math.min(o, h), p[1] = Math.max(o, h), l = p[0] + "," + p[1], void 0 === f[l] && (f[l] = {
                            index1: p[0],
                            index2: p[1]
                        });
                for (l in f) a = f[l], u.fromBufferAttribute(y, a.index1), d.push(u.x, u.y, u.z), u.fromBufferAttribute(y, a.index2), d.push(u.x, u.y, u.z)
            } else
                for (y = t.attributes.position, e = 0, n = y.count / 3; e < n; e++)
                    for (i = 0; i < 3; i++) M = 3 * e + i, u.fromBufferAttribute(y, M), d.push(u.x, u.y, u.z), E = 3 * e + (i + 1) % 3, u.fromBufferAttribute(y, E), d.push(u.x, u.y, u.z)
        }
        this.addAttribute("position", new At(d, 3))
    }

    function Xe(t, e, i) {
        yt.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: i
        }, this.fromBufferGeometry(new qe(t, e, i)), this.mergeVertices()
    }

    function qe(t, e, i) {
        Lt.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: i
        };
        var n, r, s = [],
            a = [],
            o = [],
            h = [],
            l = new c,
            u = new c,
            d = new c,
            p = new c,
            f = new c,
            m = e + 1;
        for (n = 0; n <= i; n++) {
            var v = n / i;
            for (r = 0; r <= e; r++) {
                var g = r / e;
                u = t(g, v, u), a.push(u.x, u.y, u.z), g - 1e-5 >= 0 ? (d = t(g - 1e-5, v, d), p.subVectors(u, d)) : (d = t(g + 1e-5, v, d), p.subVectors(d, u)), v - 1e-5 >= 0 ? (d = t(g, v - 1e-5, d), f.subVectors(u, d)) : (d = t(g, v + 1e-5, d), f.subVectors(d, u)), l.crossVectors(p, f).normalize(), o.push(l.x, l.y, l.z), h.push(g, v)
            }
        }
        for (n = 0; n < i; n++)
            for (r = 0; r < e; r++) {
                var y = n * m + r,
                    _ = n * m + r + 1,
                    x = (n + 1) * m + r + 1,
                    b = (n + 1) * m + r;
                s.push(y, _, b), s.push(_, x, b)
            }
        this.setIndex(s), this.addAttribute("position", new At(a, 3)), this.addAttribute("normal", new At(o, 3)), this.addAttribute("uv", new At(h, 2))
    }

    function Ye(t, e, i, n) {
        yt.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: i,
            detail: n
        }, this.fromBufferGeometry(new Ze(t, e, i, n)), this.mergeVertices()
    }

    function Ze(t, e, i, n) {
        function s(t, e, i, n) {
            var r, s, a = Math.pow(2, n),
                h = [];
            for (r = 0; r <= a; r++) {
                h[r] = [];
                var l = t.clone().lerp(i, r / a),
                    c = e.clone().lerp(i, r / a),
                    u = a - r;
                for (s = 0; s <= u; s++) h[r][s] = 0 === s && r === a ? l : l.clone().lerp(c, s / u)
            }
            for (r = 0; r < a; r++)
                for (s = 0; s < 2 * (a - r) - 1; s++) {
                    var d = Math.floor(s / 2);
                    s % 2 == 0 ? (o(h[r][d + 1]), o(h[r + 1][d]), o(h[r][d])) : (o(h[r][d + 1]), o(h[r + 1][d + 1]), o(h[r + 1][d]))
                }
        }

        function a() {
            for (var t = 0; t < m.length; t += 6) {
                var e = m[t + 0],
                    i = m[t + 2],
                    n = m[t + 4],
                    r = Math.max(e, i, n),
                    s = Math.min(e, i, n);
                r > .9 && s < .1 && (e < .2 && (m[t + 0] += 1), i < .2 && (m[t + 2] += 1), n < .2 && (m[t + 4] += 1))
            }
        }

        function o(t) {
            f.push(t.x, t.y, t.z)
        }

        function h(e, i) {
            var n = 3 * e;
            i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
        }

        function l() {
            for (var t = new c, e = new c, i = new c, n = new c, s = new r, a = new r, o = new r, h = 0, l = 0; h < f.length; h += 9, l += 6) {
                t.set(f[h + 0], f[h + 1], f[h + 2]), e.set(f[h + 3], f[h + 4], f[h + 5]), i.set(f[h + 6], f[h + 7], f[h + 8]), s.set(m[l + 0], m[l + 1]), a.set(m[l + 2], m[l + 3]), o.set(m[l + 4], m[l + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                var p = d(n);
                u(s, l + 0, t, p), u(a, l + 2, e, p), u(o, l + 4, i, p)
            }
        }

        function u(t, e, i, n) {
            n < 0 && 1 === t.x && (m[e] = t.x - 1), 0 === i.x && 0 === i.z && (m[e] = n / 2 / Math.PI + .5)
        }

        function d(t) {
            return Math.atan2(t.z, -t.x)
        }

        function p(t) {
            return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
        }
        Lt.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: i,
            detail: n
        }, i = i || 1, n = n || 0;
        var f = [],
            m = [];
        ! function(t) {
            for (var i = new c, n = new c, r = new c, a = 0; a < e.length; a += 3) h(e[a + 0], i), h(e[a + 1], n), h(e[a + 2], r), s(i, n, r, t)
        }(n),
        function(t) {
            for (var e = new c, i = 0; i < f.length; i += 3) e.x = f[i + 0], e.y = f[i + 1], e.z = f[i + 2], e.normalize().multiplyScalar(t), f[i + 0] = e.x, f[i + 1] = e.y, f[i + 2] = e.z
        }(i),
        function() {
            for (var t = new c, e = 0; e < f.length; e += 3) {
                t.x = f[e + 0], t.y = f[e + 1], t.z = f[e + 2];
                var i = d(t) / 2 / Math.PI + .5,
                    n = p(t) / Math.PI + .5;
                m.push(i, 1 - n)
            }
            l(), a()
        }(), this.addAttribute("position", new At(f, 3)), this.addAttribute("normal", new At(f.slice(), 3)), this.addAttribute("uv", new At(m, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function $e(t, e) {
        yt.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new Qe(t, e)), this.mergeVertices()
    }

    function Qe(t, e) {
        var i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            n = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        Ze.call(this, i, n, t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function Je(t, e) {
        yt.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new Ke(t, e)), this.mergeVertices()
    }

    function Ke(t, e) {
        var i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            n = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        Ze.call(this, i, n, t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function ti(t, e) {
        yt.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new ei(t, e)), this.mergeVertices()
    }

    function ei(t, e) {
        var i = (1 + Math.sqrt(5)) / 2,
            n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1],
            r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        Ze.call(this, n, r, t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function ii(t, e) {
        yt.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new ni(t, e)), this.mergeVertices()
    }

    function ni(t, e) {
        var i = (1 + Math.sqrt(5)) / 2,
            n = 1 / i,
            r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n],
            s = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        Ze.call(this, r, s, t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function ri(t, e, i, n, r, s) {
        yt.call(this), this.type = "TubeGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: i,
            radialSegments: n,
            closed: r
        }, void 0 !== s && console.warn("THREE.TubeGeometry: taper has been removed.");
        var a = new si(t, e, i, n, r);
        this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
    }

    function si(t, e, i, n, s) {
        function a(r) {
            var s = t.getPointAt(r / e),
                a = l.normals[r],
                o = l.binormals[r];
            for (d = 0; d <= n; d++) {
                var h = d / n * Math.PI * 2,
                    c = Math.sin(h),
                    u = -Math.cos(h);
                f.x = u * a.x + c * o.x, f.y = u * a.y + c * o.y, f.z = u * a.z + c * o.z, f.normalize(), g.push(f.x, f.y, f.z), p.x = s.x + i * f.x, p.y = s.y + i * f.y, p.z = s.z + i * f.z, v.push(p.x, p.y, p.z)
            }
        }

        function o() {
            for (d = 1; d <= e; d++)
                for (u = 1; u <= n; u++) {
                    var t = (n + 1) * (d - 1) + (u - 1),
                        i = (n + 1) * d + (u - 1),
                        r = (n + 1) * d + u,
                        s = (n + 1) * (d - 1) + u;
                    _.push(t, i, s), _.push(i, r, s)
                }
        }

        function h() {
            for (u = 0; u <= e; u++)
                for (d = 0; d <= n; d++) m.x = u / e, m.y = d / n, y.push(m.x, m.y)
        }
        Lt.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: i,
            radialSegments: n,
            closed: s
        }, e = e || 64, i = i || 1, n = n || 8, s = s || !1;
        var l = t.computeFrenetFrames(e, s);
        this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
        var u, d, p = new c,
            f = new c,
            m = new r,
            v = [],
            g = [],
            y = [],
            _ = [];
        ! function() {
            for (u = 0; u < e; u++) a(u);
            a(!1 === s ? e : 0), h(), o()
        }(), this.setIndex(_), this.addAttribute("position", new At(v, 3)), this.addAttribute("normal", new At(g, 3)), this.addAttribute("uv", new At(y, 2))
    }

    function ai(t, e, i, n, r, s, a) {
        yt.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: s
        }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new oi(t, e, i, n, r, s)), this.mergeVertices()
    }

    function oi(t, e, i, n, r, s) {
        function a(t, e, i, n, r) {
            var s = Math.cos(t),
                a = Math.sin(t),
                o = i / e * t,
                h = Math.cos(o);
            r.x = n * (2 + h) * .5 * s, r.y = n * (2 + h) * a * .5, r.z = n * Math.sin(o) * .5
        }
        Lt.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: s
        }, t = t || 100, e = e || 40, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, s = s || 3;
        var o, h, l = [],
            u = [],
            d = [],
            p = [],
            f = new c,
            m = new c,
            v = new c,
            g = new c,
            y = new c,
            _ = new c,
            x = new c;
        for (o = 0; o <= i; ++o) {
            var b = o / i * r * Math.PI * 2;
            for (a(b, r, s, t, v), a(b + .01, r, s, t, g), _.subVectors(g, v), x.addVectors(g, v), y.crossVectors(_, x), x.crossVectors(y, _), y.normalize(), x.normalize(), h = 0; h <= n; ++h) {
                var w = h / n * Math.PI * 2,
                    T = -e * Math.cos(w),
                    M = e * Math.sin(w);
                f.x = v.x + (T * x.x + M * y.x), f.y = v.y + (T * x.y + M * y.y), f.z = v.z + (T * x.z + M * y.z), u.push(f.x, f.y, f.z), m.subVectors(f, v).normalize(), d.push(m.x, m.y, m.z), p.push(o / i), p.push(h / n)
            }
        }
        for (h = 1; h <= i; h++)
            for (o = 1; o <= n; o++) {
                var E = (n + 1) * (h - 1) + (o - 1),
                    S = (n + 1) * h + (o - 1),
                    A = (n + 1) * h + o,
                    P = (n + 1) * (h - 1) + o;
                l.push(E, S, P), l.push(S, A, P)
            }
        this.setIndex(l), this.addAttribute("position", new At(u, 3)), this.addAttribute("normal", new At(d, 3)), this.addAttribute("uv", new At(p, 2))
    }

    function hi(t, e, i, n, r) {
        yt.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, this.fromBufferGeometry(new li(t, e, i, n, r)), this.mergeVertices()
    }

    function li(t, e, i, n, r) {
        Lt.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, t = t || 100, e = e || 40, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
        var s, a, o = [],
            h = [],
            l = [],
            u = [],
            d = new c,
            p = new c,
            f = new c;
        for (s = 0; s <= i; s++)
            for (a = 0; a <= n; a++) {
                var m = a / n * r,
                    v = s / i * Math.PI * 2;
                p.x = (t + e * Math.cos(v)) * Math.cos(m), p.y = (t + e * Math.cos(v)) * Math.sin(m), p.z = e * Math.sin(v), h.push(p.x, p.y, p.z), d.x = t * Math.cos(m), d.y = t * Math.sin(m), f.subVectors(p, d).normalize(), l.push(f.x, f.y, f.z), u.push(a / n), u.push(s / i)
            }
        for (s = 1; s <= i; s++)
            for (a = 1; a <= n; a++) {
                var g = (n + 1) * s + a - 1,
                    y = (n + 1) * (s - 1) + a - 1,
                    _ = (n + 1) * (s - 1) + a,
                    x = (n + 1) * s + a;
                o.push(g, y, x), o.push(y, _, x)
            }
        this.setIndex(o), this.addAttribute("position", new At(h, 3)), this.addAttribute("normal", new At(l, 3)), this.addAttribute("uv", new At(u, 2))
    }

    function ci(t, e) {
        yt.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: t,
            options: e
        }, this.fromBufferGeometry(new ui(t, e)), this.mergeVertices()
    }

    function ui(t, e) {
        void 0 !== t && (Lt.call(this), this.type = "ExtrudeBufferGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeVertexNormals())
    }

    function di(t, e) {
        yt.call(this), this.type = "TextGeometry", this.parameters = {
            text: t,
            parameters: e
        }, this.fromBufferGeometry(new pi(t, e)), this.mergeVertices()
    }

    function pi(t, e) {
        e = e || {};
        var i = e.font;
        if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new yt;
        var n = i.generateShapes(t, e.size, e.curveSegments);
        e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), ui.call(this, n, e), this.type = "TextBufferGeometry"
    }

    function fi(t, e, i, n, r, s, a) {
        yt.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: s,
            thetaLength: a
        }, this.fromBufferGeometry(new mi(t, e, i, n, r, s, a)), this.mergeVertices()
    }

    function mi(t, e, i, n, r, s, a) {
        Lt.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: s,
            thetaLength: a
        }, t = t || 50, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : Math.PI;
        var o, h, l = s + a,
            u = 0,
            d = [],
            p = new c,
            f = new c,
            m = [],
            v = [],
            g = [],
            y = [];
        for (h = 0; h <= i; h++) {
            var _ = [],
                x = h / i;
            for (o = 0; o <= e; o++) {
                var b = o / e;
                p.x = -t * Math.cos(n + b * r) * Math.sin(s + x * a), p.y = t * Math.cos(s + x * a), p.z = t * Math.sin(n + b * r) * Math.sin(s + x * a), v.push(p.x, p.y, p.z), f.set(p.x, p.y, p.z).normalize(), g.push(f.x, f.y, f.z), y.push(b, 1 - x), _.push(u++)
            }
            d.push(_)
        }
        for (h = 0; h < i; h++)
            for (o = 0; o < e; o++) {
                var w = d[h][o + 1],
                    T = d[h][o],
                    M = d[h + 1][o],
                    E = d[h + 1][o + 1];
                (0 !== h || s > 0) && m.push(w, T, E), (h !== i - 1 || l < Math.PI) && m.push(T, M, E)
            }
        this.setIndex(m), this.addAttribute("position", new At(v, 3)), this.addAttribute("normal", new At(g, 3)), this.addAttribute("uv", new At(y, 2))
    }

    function vi(t, e, i, n, r, s) {
        yt.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: s
        }, this.fromBufferGeometry(new gi(t, e, i, n, r, s)), this.mergeVertices()
    }

    function gi(t, e, i, n, s, a) {
        Lt.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: s,
            thetaLength: a
        }, t = t || 20, e = e || 50, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8, n = void 0 !== n ? Math.max(1, n) : 1;
        var o, h, l, u = [],
            d = [],
            p = [],
            f = [],
            m = t,
            v = (e - t) / n,
            g = new c,
            y = new r;
        for (h = 0; h <= n; h++) {
            for (l = 0; l <= i; l++) o = s + l / i * a, g.x = m * Math.cos(o), g.y = m * Math.sin(o), d.push(g.x, g.y, g.z), p.push(0, 0, 1), y.x = (g.x / e + 1) / 2, y.y = (g.y / e + 1) / 2, f.push(y.x, y.y);
            m += v
        }
        for (h = 0; h < n; h++) {
            var _ = h * (i + 1);
            for (l = 0; l < i; l++) {
                o = l + _;
                var x = o,
                    b = o + i + 1,
                    w = o + i + 2,
                    T = o + 1;
                u.push(x, b, T), u.push(b, w, T)
            }
        }
        this.setIndex(u), this.addAttribute("position", new At(d, 3)), this.addAttribute("normal", new At(p, 3)), this.addAttribute("uv", new At(f, 2))
    }

    function yi(t, e, i, n) {
        yt.call(this), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: i,
            phiLength: n
        }, this.fromBufferGeometry(new _i(t, e, i, n)), this.mergeVertices()
    }

    function _i(t, e, i, n) {
        Lt.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: i,
            phiLength: n
        }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = Oo.clamp(n, 0, 2 * Math.PI);
        var s, a, o, h = [],
            l = [],
            u = [],
            d = 1 / e,
            p = new c,
            f = new r;
        for (a = 0; a <= e; a++) {
            var m = i + a * d * n,
                v = Math.sin(m),
                g = Math.cos(m);
            for (o = 0; o <= t.length - 1; o++) p.x = t[o].x * v, p.y = t[o].y, p.z = t[o].x * g, l.push(p.x, p.y, p.z), f.x = a / e, f.y = o / (t.length - 1), u.push(f.x, f.y)
        }
        for (a = 0; a < e; a++)
            for (o = 0; o < t.length - 1; o++) {
                s = o + a * t.length;
                var y = s,
                    _ = s + t.length,
                    x = s + t.length + 1,
                    b = s + 1;
                h.push(y, _, b), h.push(_, x, b)
            }
        if (this.setIndex(h), this.addAttribute("position", new At(l, 3)), this.addAttribute("uv", new At(u, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
            var w = this.attributes.normal.array,
                T = new c,
                M = new c,
                E = new c;
            for (s = e * t.length * 3, a = 0, o = 0; a < t.length; a++, o += 3) T.x = w[o + 0], T.y = w[o + 1], T.z = w[o + 2], M.x = w[s + o + 0], M.y = w[s + o + 1], M.z = w[s + o + 2], E.addVectors(T, M).normalize(), w[o + 0] = w[s + o + 0] = E.x, w[o + 1] = w[s + o + 1] = E.y, w[o + 2] = w[s + o + 2] = E.z
        }
    }

    function xi(t, e) {
        yt.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
            shapes: t,
            curveSegments: e
        }, this.fromBufferGeometry(new bi(t, e)), this.mergeVertices()
    }

    function bi(t, e) {
        function i(t) {
            var i, o, l, c = r.length / 3,
                u = t.extractPoints(e),
                d = u.shape,
                p = u.holes;
            if (!1 === $o.isClockWise(d))
                for (d = d.reverse(), i = 0, o = p.length; i < o; i++) l = p[i], !0 === $o.isClockWise(l) && (p[i] = l.reverse());
            var f = $o.triangulateShape(d, p);
            for (i = 0, o = p.length; i < o; i++) l = p[i], d = d.concat(l);
            for (i = 0, o = d.length; i < o; i++) {
                var m = d[i];
                r.push(m.x, m.y, 0), s.push(0, 0, 1), a.push(m.x, m.y)
            }
            for (i = 0, o = f.length; i < o; i++) {
                var v = f[i],
                    g = v[0] + c,
                    y = v[1] + c,
                    _ = v[2] + c;
                n.push(g, y, _), h += 3
            }
        }
        Lt.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: t,
            curveSegments: e
        }, e = e || 12;
        var n = [],
            r = [],
            s = [],
            a = [],
            o = 0,
            h = 0;
        if (!1 === Array.isArray(t)) i(t);
        else
            for (var l = 0; l < t.length; l++) i(t[l]), this.addGroup(o, h, l), o += h, h = 0;
        this.setIndex(n), this.addAttribute("position", new At(r, 3)), this.addAttribute("normal", new At(s, 3)), this.addAttribute("uv", new At(a, 2))
    }

    function wi(t, e) {
        Lt.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: e
        }, e = void 0 !== e ? e : 1;
        var i, n, r, s, a = [],
            o = Math.cos(Oo.DEG2RAD * e),
            h = [0, 0],
            l = {},
            c = ["a", "b", "c"];
        t.isBufferGeometry ? (s = new yt, s.fromBufferGeometry(t)) : s = t.clone(), s.mergeVertices(), s.computeFaceNormals();
        for (var u = s.vertices, d = s.faces, p = 0, f = d.length; p < f; p++)
            for (var m = d[p], v = 0; v < 3; v++) i = m[c[v]], n = m[c[(v + 1) % 3]], h[0] = Math.min(i, n), h[1] = Math.max(i, n), r = h[0] + "," + h[1], void 0 === l[r] ? l[r] = {
                index1: h[0],
                index2: h[1],
                face1: p,
                face2: void 0
            } : l[r].face2 = p;
        for (r in l) {
            var g = l[r];
            if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= o) {
                var y = u[g.index1];
                a.push(y.x, y.y, y.z), y = u[g.index2], a.push(y.x, y.y, y.z)
            }
        }
        this.addAttribute("position", new At(a, 3))
    }

    function Ti(t, e, i, n, r, s, a, o) {
        yt.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: s,
            thetaStart: a,
            thetaLength: o
        }, this.fromBufferGeometry(new Mi(t, e, i, n, r, s, a, o)), this.mergeVertices()
    }

    function Mi(t, e, i, n, s, a, o, h) {
        function l(i) {
            var s, a, l, g = new r,
                x = new c,
                b = 0,
                w = !0 === i ? t : e,
                T = !0 === i ? 1 : -1;
            for (a = v, s = 1; s <= n; s++) p.push(0, y * T, 0), f.push(0, T, 0), m.push(.5, .5), v++;
            for (l = v, s = 0; s <= n; s++) {
                var M = s / n,
                    E = M * h + o,
                    S = Math.cos(E),
                    A = Math.sin(E);
                x.x = w * A, x.y = y * T, x.z = w * S, p.push(x.x, x.y, x.z), f.push(0, T, 0), g.x = .5 * S + .5, g.y = .5 * A * T + .5, m.push(g.x, g.y), v++
            }
            for (s = 0; s < n; s++) {
                var P = a + s,
                    R = l + s;
                !0 === i ? d.push(R, R + 1, P) : d.push(R + 1, R, P), b += 3
            }
            u.addGroup(_, b, !0 === i ? 1 : 2), _ += b
        }
        Lt.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: i,
            radialSegments: n,
            heightSegments: s,
            openEnded: a,
            thetaStart: o,
            thetaLength: h
        };
        var u = this;
        t = void 0 !== t ? t : 20, e = void 0 !== e ? e : 20, i = void 0 !== i ? i : 100, n = Math.floor(n) || 8, s = Math.floor(s) || 1, a = void 0 !== a && a, o = void 0 !== o ? o : 0, h = void 0 !== h ? h : 2 * Math.PI;
        var d = [],
            p = [],
            f = [],
            m = [],
            v = 0,
            g = [],
            y = i / 2,
            _ = 0;
        ! function() {
            var r, a, l = new c,
                x = new c,
                b = 0,
                w = (e - t) / i;
            for (a = 0; a <= s; a++) {
                var T = [],
                    M = a / s,
                    E = M * (e - t) + t;
                for (r = 0; r <= n; r++) {
                    var S = r / n,
                        A = S * h + o,
                        P = Math.sin(A),
                        R = Math.cos(A);
                    x.x = E * P, x.y = -M * i + y, x.z = E * R, p.push(x.x, x.y, x.z), l.set(P, w, R).normalize(), f.push(l.x, l.y, l.z), m.push(S, 1 - M), T.push(v++)
                }
                g.push(T)
            }
            for (r = 0; r < n; r++)
                for (a = 0; a < s; a++) {
                    var C = g[a][r],
                        L = g[a + 1][r],
                        O = g[a + 1][r + 1],
                        I = g[a][r + 1];
                    d.push(C, L, I), d.push(L, O, I), b += 6
                }
            u.addGroup(_, b, 0), _ += b
        }(), !1 === a && (t > 0 && l(!0), e > 0 && l(!1)), this.setIndex(d), this.addAttribute("position", new At(p, 3)), this.addAttribute("normal", new At(f, 3)), this.addAttribute("uv", new At(m, 2))
    }

    function Ei(t, e, i, n, r, s, a) {
        Ti.call(this, 0, t, e, i, n, r, s, a), this.type = "ConeGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: s,
            thetaLength: a
        }
    }

    function Si(t, e, i, n, r, s, a) {
        Mi.call(this, 0, t, e, i, n, r, s, a), this.type = "ConeBufferGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: s,
            thetaLength: a
        }
    }

    function Ai(t, e, i, n) {
        yt.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: i,
            thetaLength: n
        }, this.fromBufferGeometry(new Pi(t, e, i, n)), this.mergeVertices()
    }

    function Pi(t, e, i, n) {
        Lt.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: i,
            thetaLength: n
        }, t = t || 50, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
        var s, a, o = [],
            h = [],
            l = [],
            u = [],
            d = new c,
            p = new r;
        for (h.push(0, 0, 0), l.push(0, 0, 1), u.push(.5, .5), a = 0, s = 3; a <= e; a++, s += 3) {
            var f = i + a / e * n;
            d.x = t * Math.cos(f), d.y = t * Math.sin(f), h.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (h[s] / t + 1) / 2, p.y = (h[s + 1] / t + 1) / 2, u.push(p.x, p.y)
        }
        for (s = 1; s <= e; s++) o.push(s, s + 1, 0);
        this.setIndex(o), this.addAttribute("position", new At(h, 3)), this.addAttribute("normal", new At(l, 3)), this.addAttribute("uv", new At(u, 2))
    }

    function Ri(t) {
        K.call(this), this.type = "ShadowMaterial", this.color = new Y(0), this.opacity = 1, this.lights = !0, this.transparent = !0, this.setValues(t)
    }

    function Ci(t) {
        tt.call(this, t), this.type = "RawShaderMaterial"
    }

    function Li(t) {
        K.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Y(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new r(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Oi(t) {
        Li.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
    }

    function Ii(t) {
        K.call(this), this.type = "MeshPhongMaterial", this.color = new Y(16777215), this.specular = new Y(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new r(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = la, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Di(t) {
        Ii.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
    }

    function zi(t) {
        K.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new r(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Ui(t) {
        K.call(this), this.type = "MeshLambertMaterial", this.color = new Y(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = la, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Ni(t) {
        ze.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
    }

    function ki(t, e, i) {
        var n = this,
            r = !1,
            s = 0,
            a = 0;
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
            a++, !1 === r && void 0 !== n.onStart && n.onStart(t, s, a), r = !0
        }, this.itemEnd = function(t) {
            s++, void 0 !== n.onProgress && n.onProgress(t, s, a), s === a && (r = !1, void 0 !== n.onLoad && n.onLoad())
        }, this.itemError = function(t) {
            void 0 !== n.onError && n.onError(t)
        }
    }

    function Fi(t) {
        this.manager = void 0 !== t ? t : th
    }

    function Bi(t) {
        this.manager = void 0 !== t ? t : th, this._parser = null
    }

    function Gi(t) {
        this.manager = void 0 !== t ? t : th, this._parser = null
    }

    function Hi(t) {
        this.manager = void 0 !== t ? t : th
    }

    function ji(t) {
        this.manager = void 0 !== t ? t : th
    }

    function Vi(t) {
        this.manager = void 0 !== t ? t : th
    }

    function Wi(t, e) {
        dt.call(this), this.type = "Light", this.color = new Y(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
    }

    function Xi(t, e, i) {
        Wi.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(dt.DefaultUp), this.updateMatrix(), this.groundColor = new Y(e)
    }

    function qi(t) {
        this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new r(512, 512), this.map = null, this.matrix = new u
    }

    function Yi() {
        qi.call(this, new mt(50, 1, .5, 500))
    }

    function Zi(t, e, i, n, r, s) {
        Wi.call(this, t, e), this.type = "SpotLight", this.position.copy(dt.DefaultUp), this.updateMatrix(), this.target = new dt, Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== s ? s : 1, this.shadow = new Yi
    }

    function $i(t, e, i, n) {
        Wi.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new qi(new mt(90, 1, .5, 500))
    }

    function Qi() {
        qi.call(this, new ft(-5, 5, 5, -5, .5, 500))
    }

    function Ji(t, e) {
        Wi.call(this, t, e), this.type = "DirectionalLight", this.position.copy(dt.DefaultUp), this.updateMatrix(), this.target = new dt, this.shadow = new Qi
    }

    function Ki(t, e) {
        Wi.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
    }

    function tn(t, e, i, n) {
        Wi.call(this, t, e), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
    }

    function en(t, e, i, n) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
    }

    function nn(t, e, i, n) {
        en.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function rn(t, e, i, n) {
        en.call(this, t, e, i, n)
    }

    function sn(t, e, i, n) {
        en.call(this, t, e, i, n)
    }

    function an(t, e, i, n) {
        if (void 0 === t) throw new Error("track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("no keyframes in track named " + t);
        this.name = t, this.times = eh.convertArray(e, this.TimeBufferType), this.values = eh.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation), this.validate(), this.optimize()
    }

    function on(t, e, i, n) {
        an.call(this, t, e, i, n)
    }

    function hn(t, e, i, n) {
        en.call(this, t, e, i, n)
    }

    function ln(t, e, i, n) {
        an.call(this, t, e, i, n)
    }

    function cn(t, e, i, n) {
        an.call(this, t, e, i, n)
    }

    function un(t, e, i, n) {
        an.call(this, t, e, i, n)
    }

    function dn(t, e, i) {
        an.call(this, t, e, i)
    }

    function pn(t, e, i, n) {
        an.call(this, t, e, i, n)
    }

    function fn(t, e, i, n) {
        an.apply(this, arguments)
    }

    function mn(t, e, i) {
        this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = Oo.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
    }

    function vn(t) {
        this.manager = void 0 !== t ? t : th, this.textures = {}
    }

    function gn(t) {
        this.manager = void 0 !== t ? t : th
    }

    function yn() {
        this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
    }

    function _n(t) {
        "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : th, this.withCredentials = !1
    }

    function xn(t) {
        this.manager = void 0 !== t ? t : th, this.texturePath = ""
    }

    function bn(t, e, i, n, r) {
        var s = .5 * (n - e),
            a = .5 * (r - i),
            o = t * t;
        return (2 * i - 2 * n + s + a) * (t * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * t + i
    }

    function wn(t, e) {
        var i = 1 - t;
        return i * i * e
    }

    function Tn(t, e) {
        return 2 * (1 - t) * t * e
    }

    function Mn(t, e) {
        return t * t * e
    }

    function En(t, e, i, n) {
        return wn(t, e) + Tn(t, i) + Mn(t, n)
    }

    function Sn(t, e) {
        var i = 1 - t;
        return i * i * i * e
    }

    function An(t, e) {
        var i = 1 - t;
        return 3 * i * i * t * e
    }

    function Pn(t, e) {
        return 3 * (1 - t) * t * t * e
    }

    function Rn(t, e) {
        return t * t * t * e
    }

    function Cn(t, e, i, n, r) {
        return Sn(t, e) + An(t, i) + Pn(t, n) + Rn(t, r)
    }

    function Ln() {
        this.arcLengthDivisions = 200
    }

    function On(t, e) {
        Ln.call(this), this.v1 = t, this.v2 = e
    }

    function In() {
        Ln.call(this), this.curves = [], this.autoClose = !1
    }

    function Dn(t, e, i, n, r, s, a, o) {
        Ln.call(this), this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o || 0
    }

    function zn(t) {
        Ln.call(this), this.points = void 0 === t ? [] : t
    }

    function Un(t, e, i, n) {
        Ln.call(this), this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
    }

    function Nn(t, e, i) {
        Ln.call(this), this.v0 = t, this.v1 = e, this.v2 = i
    }

    function kn(t) {
        In.call(this), this.currentPoint = new r, t && this.fromPoints(t)
    }

    function Fn() {
        kn.apply(this, arguments), this.holes = []
    }

    function Bn() {
        this.subPaths = [], this.currentPath = null
    }

    function Gn(t) {
        this.data = t
    }

    function Hn(t) {
        this.manager = void 0 !== t ? t : th
    }

    function jn(t) {
        this.manager = void 0 !== t ? t : th
    }

    function Vn() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new mt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new mt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }

    function Wn(t, e, i) {
        dt.call(this), this.type = "CubeCamera";
        var n = new mt(90, 1, t, e);
        n.up.set(0, -1, 0), n.lookAt(new c(1, 0, 0)), this.add(n);
        var r = new mt(90, 1, t, e);
        r.up.set(0, -1, 0), r.lookAt(new c(-1, 0, 0)), this.add(r);
        var s = new mt(90, 1, t, e);
        s.up.set(0, 0, 1), s.lookAt(new c(0, 1, 0)), this.add(s);
        var a = new mt(90, 1, t, e);
        a.up.set(0, 0, -1), a.lookAt(new c(0, -1, 0)), this.add(a);
        var o = new mt(90, 1, t, e);
        o.up.set(0, -1, 0), o.lookAt(new c(0, 0, 1)), this.add(o);
        var l = new mt(90, 1, t, e);
        l.up.set(0, -1, 0), l.lookAt(new c(0, 0, -1)), this.add(l);
        var u = {
            format: qa,
            magFilter: La,
            minFilter: La
        };
        this.renderTarget = new h(i, i, u), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var i = this.renderTarget,
                h = i.texture.generateMipmaps;
            i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, n, i), i.activeCubeFace = 1, t.render(e, r, i), i.activeCubeFace = 2, t.render(e, s, i), i.activeCubeFace = 3, t.render(e, a, i), i.activeCubeFace = 4, t.render(e, o, i), i.texture.generateMipmaps = h, i.activeCubeFace = 5, t.render(e, l, i), t.setRenderTarget(null)
        }, this.clear = function(t, e, i, n) {
            for (var r = this.renderTarget, s = 0; s < 6; s++) r.activeCubeFace = s, t.setRenderTarget(r), t.clear(e, i, n);
            t.setRenderTarget(null)
        }
    }

    function Xn() {
        dt.call(this), this.type = "AudioListener", this.context = lh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
    }

    function qn(t) {
        dt.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function Yn(t) {
        qn.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
    }

    function Zn(t, e) {
        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
    }

    function $n(t, e, i) {
        this.binding = t, this.valueSize = i;
        var n, r = Float64Array;
        switch (e) {
            case "quaternion":
                n = this._slerp;
                break;
            case "string":
            case "bool":
                r = Array, n = this._select;
                break;
            default:
                n = this._lerp
        }
        this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
    }

    function Qn(t, e, i) {
        var n = i || Jn.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, n)
    }

    function Jn(t, e, i) {
        this.path = e, this.parsedPath = i || Jn.parseTrackName(e), this.node = Jn.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
    }

    function Kn(t) {
        this.uuid = Oo.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var i = 0, n = arguments.length; i !== n; ++i) e[arguments[i].uuid] = i;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var r = this;
        this.stats = {
            objects: {
                get total() {
                    return r._objects.length
                },
                get inUse() {
                    return this.total - r.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return r._bindings.length
            }
        }
    }

    function tr(t, e, i) {
        this._mixer = t, this._clip = e, this._localRoot = i || null;
        for (var n = e.tracks, r = n.length, s = new Array(r), a = {
                endingStart: vo,
                endingEnd: vo
            }, o = 0; o !== r; ++o) {
            var h = n[o].createInterpolant(null);
            s[o] = h, h.settings = a
        }
        this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = co, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function er(t) {
        this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    function ir(t) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
    }

    function nr() {
        Lt.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function rr(t, e, i, n) {
        this.uuid = Oo.generateUUID(), this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
    }

    function sr(t, e) {
        this.uuid = Oo.generateUUID(), this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function() {}, this.version = 0
    }

    function ar(t, e, i) {
        sr.call(this, t, e), this.meshPerAttribute = i || 1
    }

    function or(t, e, i) {
        _t.call(this, t, e), this.meshPerAttribute = i || 1
    }

    function hr(t, e, i, n) {
        this.ray = new Nt(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function lr(t, e) {
        return t.distance - e.distance
    }

    function cr(t, e, i, n) {
        if (!1 !== t.visible && (t.raycast(e, i), !0 === n))
            for (var r = t.children, s = 0, a = r.length; s < a; s++) cr(r[s], e, i, !0)
    }

    function ur(t) {
        this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }

    function dr(t, e, i) {
        return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
    }

    function pr(t, e, i) {
        return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
    }

    function fr(t) {
        dt.call(this), this.material = t, this.render = function(t) {}
    }

    function mr(t, e, i, n) {
        this.object = t, this.size = void 0 !== e ? e : 1;
        var r = void 0 !== i ? i : 16711680,
            s = void 0 !== n ? n : 1,
            a = 0,
            o = this.object.geometry;
        o && o.isGeometry ? a = 3 * o.faces.length : o && o.isBufferGeometry && (a = o.attributes.normal.count);
        var h = new Lt,
            l = new At(2 * a * 3, 3);
        h.addAttribute("position", l), Ne.call(this, h, new ze({
            color: r,
            linewidth: s
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function vr(t, e) {
        dt.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
        for (var i = new Lt, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, s = 1; r < 32; r++, s++) {
            var a = r / 32 * Math.PI * 2,
                o = s / 32 * Math.PI * 2;
            n.push(Math.cos(a), Math.sin(a), 1, Math.cos(o), Math.sin(o), 1)
        }
        i.addAttribute("position", new At(n, 3));
        var h = new ze({
            fog: !1
        });
        this.cone = new Ne(i, h), this.add(this.cone), this.update()
    }

    function gr(t) {
        var e = [];
        t && t.isBone && e.push(t);
        for (var i = 0; i < t.children.length; i++) e.push.apply(e, gr(t.children[i]));
        return e
    }

    function yr(t) {
        for (var e = gr(t), i = new Lt, n = [], r = [], s = new Y(0, 0, 1), a = new Y(0, 1, 0), o = 0; o < e.length; o++) {
            var h = e[o];
            h.parent && h.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
        }
        i.addAttribute("position", new At(n, 3)), i.addAttribute("color", new At(r, 3));
        var l = new ze({
            vertexColors: Os,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        Ne.call(this, i, l), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.onBeforeRender()
    }

    function _r(t, e, i) {
        this.light = t, this.light.updateMatrixWorld(), this.color = i;
        var n = new mi(e, 4, 2),
            r = new Ut({
                wireframe: !0,
                fog: !1
            });
        Bt.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function xr(t, e) {
        dt.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
        var i = new ze({
                fog: !1
            }),
            n = new Lt;
        n.addAttribute("position", new _t(new Float32Array(15), 3)), this.line = new Ue(n, i), this.add(this.line), this.update()
    }

    function br(t, e, i) {
        dt.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
        var n = new Ke(e);
        n.rotateY(.5 * Math.PI), this.material = new Ut({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = Os);
        var r = n.getAttribute("position"),
            s = new Float32Array(3 * r.count);
        n.addAttribute("color", new _t(s, 3)), this.add(new Bt(n, this.material)), this.update()
    }

    function wr(t, e, i, n) {
        t = t || 10, e = e || 10, i = new Y(void 0 !== i ? i : 4473924), n = new Y(void 0 !== n ? n : 8947848);
        for (var r = e / 2, s = t / e, a = t / 2, o = [], h = [], l = 0, c = 0, u = -a; l <= e; l++, u += s) {
            o.push(-a, 0, u, a, 0, u), o.push(u, 0, -a, u, 0, a);
            var d = l === r ? i : n;
            d.toArray(h, c), c += 3, d.toArray(h, c), c += 3, d.toArray(h, c), c += 3, d.toArray(h, c), c += 3
        }
        var p = new Lt;
        p.addAttribute("position", new At(o, 3)), p.addAttribute("color", new At(h, 3));
        var f = new ze({
            vertexColors: Os
        });
        Ne.call(this, p, f)
    }

    function Tr(t, e, i, n, r, s) {
        t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new Y(void 0 !== r ? r : 4473924), s = new Y(void 0 !== s ? s : 8947848);
        var a, o, h, l, c, u, d, p = [],
            f = [];
        for (l = 0; l <= e; l++) h = l / e * (2 * Math.PI), a = Math.sin(h) * t, o = Math.cos(h) * t, p.push(0, 0, 0), p.push(a, 0, o), d = 1 & l ? r : s, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
        for (l = 0; l <= i; l++)
            for (d = 1 & l ? r : s, u = t - t / i * l, c = 0; c < n; c++) h = c / n * (2 * Math.PI), a = Math.sin(h) * u, o = Math.cos(h) * u, p.push(a, 0, o), f.push(d.r, d.g, d.b), h = (c + 1) / n * (2 * Math.PI), a = Math.sin(h) * u, o = Math.cos(h) * u, p.push(a, 0, o), f.push(d.r, d.g, d.b);
        var m = new Lt;
        m.addAttribute("position", new At(p, 3)), m.addAttribute("color", new At(f, 3));
        var v = new ze({
            vertexColors: Os
        });
        Ne.call(this, m, v)
    }

    function Mr(t, e, i, n) {
        this.object = t, this.size = void 0 !== e ? e : 1;
        var r = void 0 !== i ? i : 16776960,
            s = void 0 !== n ? n : 1,
            a = 0,
            o = this.object.geometry;
        o && o.isGeometry ? a = o.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var h = new Lt,
            l = new At(2 * a * 3, 3);
        h.addAttribute("position", l), Ne.call(this, h, new ze({
            color: r,
            linewidth: s
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Er(t, e, i) {
        dt.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
        var n = new Lt;
        n.addAttribute("position", new At([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
        var r = new ze({
            fog: !1
        });
        this.lightPlane = new Ue(n, r), this.add(this.lightPlane), n = new Lt, n.addAttribute("position", new At([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ue(n, r), this.add(this.targetLine), this.update()
    }

    function Sr(t) {
        function e(t, e, n) {
            i(t, n), i(e, n)
        }

        function i(t, e) {
            s.push(0, 0, 0), a.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(s.length / 3 - 1)
        }
        var n = new Lt,
            r = new ze({
                color: 16777215,
                vertexColors: Ls
            }),
            s = [],
            a = [],
            o = {},
            h = new Y(16755200),
            l = new Y(16711680),
            c = new Y(43775),
            u = new Y(16777215),
            d = new Y(3355443);
        e("n1", "n2", h), e("n2", "n4", h), e("n4", "n3", h), e("n3", "n1", h), e("f1", "f2", h), e("f2", "f4", h), e("f4", "f3", h), e("f3", "f1", h), e("n1", "f1", h), e("n2", "f2", h), e("n3", "f3", h), e("n4", "f4", h), e("p", "n1", l), e("p", "n2", l), e("p", "n3", l), e("p", "n4", l), e("u1", "u2", c), e("u2", "u3", c), e("u3", "u1", c), e("c", "t", u), e("p", "c", d), e("cn1", "cn2", d), e("cn3", "cn4", d), e("cf1", "cf2", d), e("cf3", "cf4", d), n.addAttribute("position", new At(s, 3)), n.addAttribute("color", new At(a, 3)), Ne.call(this, n, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }

    function Ar(t, e) {
        this.object = t, void 0 === e && (e = 16776960);
        var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            n = new Float32Array(24),
            r = new Lt;
        r.setIndex(new _t(i, 1)), r.addAttribute("position", new _t(n, 3)), Ne.call(this, r, new ze({
            color: e
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Pr(t, e) {
        this.type = "Box3Helper", this.box = t;
        var i = void 0 !== e ? e : 16776960,
            n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
            s = new Lt;
        s.setIndex(new _t(n, 1)), s.addAttribute("position", new At(r, 3)), Ne.call(this, s, new ze({
            color: i
        })), this.geometry.computeBoundingSphere(), this.onBeforeRender()
    }

    function Rr(t, e, i) {
        this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
        var n = void 0 !== i ? i : 16776960,
            r = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],
            s = new Lt;
        s.addAttribute("position", new At(r, 3)), s.computeBoundingSphere(), Ue.call(this, s, new ze({
            color: n
        }));
        var a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
            o = new Lt;
        o.addAttribute("position", new At(a, 3)), o.computeBoundingSphere(), this.add(new Bt(o, new Ut({
            color: n,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        }))), this.onBeforeRender()
    }

    function Cr(t, e, i, n, r, s) {
        dt.call(this), void 0 === n && (n = 16776960), void 0 === i && (i = 1), void 0 === r && (r = .2 * i), void 0 === s && (s = .2 * r), void 0 === ch && (ch = new Lt, ch.addAttribute("position", new At([0, 0, 0, 0, 1, 0], 3)), uh = new Mi(0, .5, 1, 5, 1), uh.translate(0, -.5, 0)), this.position.copy(e), this.line = new Ue(ch, new ze({
            color: n
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Bt(uh, new Ut({
            color: n
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, s)
    }

    function Lr(t) {
        t = t || 1;
        var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
            n = new Lt;
        n.addAttribute("position", new At(e, 3)), n.addAttribute("color", new At(i, 3));
        var r = new ze({
            vertexColors: Os
        });
        Ne.call(this, n, r)
    }

    function Or() {
        function t(t, s, a, o) {
            e = t, i = a, n = -3 * t + 3 * s - 2 * a - o, r = 2 * t - 2 * s + a + o
        }
        var e = 0,
            i = 0,
            n = 0,
            r = 0;
        return {
            initCatmullRom: function(e, i, n, r, s) {
                t(i, n, s * (n - e), s * (r - i))
            },
            initNonuniformCatmullRom: function(e, i, n, r, s, a, o) {
                var h = (i - e) / s - (n - e) / (s + a) + (n - i) / a,
                    l = (n - i) / a - (r - i) / (a + o) + (r - n) / o;
                h *= a, l *= a, t(i, n, h, l)
            },
            calc: function(t) {
                var s = t * t;
                return e + i * t + n * s + r * (s * t)
            }
        }
    }

    function Ir(t) {
        Ln.call(this), t.length < 2 && console.warn("THREE.CatmullRomCurve3: Points array needs at least two entries."), this.points = t || [], this.closed = !1
    }

    function Dr(t, e, i, n) {
        Ln.call(this), this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
    }

    function zr(t, e, i) {
        Ln.call(this), this.v0 = t, this.v1 = e, this.v2 = i
    }

    function Ur(t, e) {
        Ln.call(this), this.v1 = t, this.v2 = e
    }

    function Nr(t, e, i, n, r, s) {
        Dn.call(this, t, e, i, i, n, r, s)
    }

    function kr(t, e, i, n, r, s, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new vt(t, e, i, r, s, a)
    }

    function Fr(t) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
    }

    function Br(t) {
        return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
            return t.slice()
        }, t
    }

    function Gr(t, e) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Be(t, e)
    }

    function Hr(t) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ce(t)
    }

    function jr(t, e) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Be(t, e)
    }

    function Vr(t) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Fe(t)
    }

    function Wr(t) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Fe(t)
    }

    function Xr(t) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Fe(t)
    }

    function qr(t, e, i) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new c(t, e, i)
    }

    function Yr(t, e) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new _t(t, e).setDynamic(!0)
    }

    function Zr(t, e) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new xt(t, e)
    }

    function $r(t, e) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new bt(t, e)
    }

    function Qr(t, e) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new wt(t, e)
    }

    function Jr(t, e) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Tt(t, e)
    }

    function Kr(t, e) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Mt(t, e)
    }

    function ts(t, e) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Et(t, e)
    }

    function es(t, e) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new St(t, e)
    }

    function is(t, e) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new At(t, e)
    }

    function ns(t, e) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Pt(t, e)
    }

    function rs(t) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Ir.call(this, t), this.type = "catmullrom", this.closed = !0
    }

    function ss(t) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Ir.call(this, t), this.type = "catmullrom"
    }

    function as(t) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Ir.call(this, t), this.type = "catmullrom"
    }

    function os(t, e) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Ar(t, e)
    }

    function hs(t, e) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ne(new wi(t.geometry), new ze({
            color: void 0 !== e ? e : 16777215
        }))
    }

    function ls(t, e) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ne(new We(t.geometry), new ze({
            color: void 0 !== e ? e : 16777215
        }))
    }

    function cs(t) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Fi(t)
    }

    function us(t) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Gi(t)
    }

    function ds() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
        }, this.unprojectVector = function(t, e) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
        }, this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }

    function ps() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i.d(e, "WebGLRenderTargetCube", function() {
        return h
    }), i.d(e, "WebGLRenderTarget", function() {
        return o
    }), i.d(e, "WebGLRenderer", function() {
        return Me
    }), i.d(e, "ShaderLib", function() {
        return Wo
    }), i.d(e, "UniformsLib", function() {
        return Ho
    }), i.d(e, "UniformsUtils", function() {
        return jo
    }), i.d(e, "ShaderChunk", function() {
        return Vo
    }), i.d(e, "FogExp2", function() {
        return Ee
    }), i.d(e, "Fog", function() {
        return Se
    }), i.d(e, "Scene", function() {
        return Ae
    }), i.d(e, "LensFlare", function() {
        return Pe
    }), i.d(e, "Sprite", function() {
        return Ce
    }), i.d(e, "LOD", function() {
        return Le
    }), i.d(e, "SkinnedMesh", function() {
        return De
    }), i.d(e, "Skeleton", function() {
        return Oe
    }), i.d(e, "Bone", function() {
        return Ie
    }), i.d(e, "Mesh", function() {
        return Bt
    }), i.d(e, "LineSegments", function() {
        return Ne
    }), i.d(e, "LineLoop", function() {
        return ke
    }), i.d(e, "Line", function() {
        return Ue
    }), i.d(e, "Points", function() {
        return Be
    }), i.d(e, "Group", function() {
        return Ge
    }), i.d(e, "VideoTexture", function() {
        return He
    }), i.d(e, "DataTexture", function() {
        return d
    }), i.d(e, "CompressedTexture", function() {
        return je
    }), i.d(e, "CubeTexture", function() {
        return p
    }), i.d(e, "CanvasTexture", function() {
        return Q
    }), i.d(e, "DepthTexture", function() {
        return Ve
    }), i.d(e, "Texture", function() {
        return s
    }), i.d(e, "CompressedTextureLoader", function() {
        return Bi
    }), i.d(e, "DataTextureLoader", function() {
        return Gi
    }), i.d(e, "CubeTextureLoader", function() {
        return ji
    }), i.d(e, "TextureLoader", function() {
        return Vi
    }), i.d(e, "ObjectLoader", function() {
        return xn
    }), i.d(e, "MaterialLoader", function() {
        return vn
    }), i.d(e, "BufferGeometryLoader", function() {
        return gn
    }), i.d(e, "DefaultLoadingManager", function() {
        return th
    }), i.d(e, "LoadingManager", function() {
        return ki
    }), i.d(e, "JSONLoader", function() {
        return _n
    }), i.d(e, "ImageLoader", function() {
        return Hi
    }), i.d(e, "FontLoader", function() {
        return Hn
    }), i.d(e, "FileLoader", function() {
        return Fi
    }), i.d(e, "Loader", function() {
        return yn
    }), i.d(e, "Cache", function() {
        return Ko
    }), i.d(e, "AudioLoader", function() {
        return jn
    }), i.d(e, "SpotLightShadow", function() {
        return Yi
    }), i.d(e, "SpotLight", function() {
        return Zi
    }), i.d(e, "PointLight", function() {
        return $i
    }), i.d(e, "RectAreaLight", function() {
        return tn
    }), i.d(e, "HemisphereLight", function() {
        return Xi
    }), i.d(e, "DirectionalLightShadow", function() {
        return Qi
    }), i.d(e, "DirectionalLight", function() {
        return Ji
    }), i.d(e, "AmbientLight", function() {
        return Ki
    }), i.d(e, "LightShadow", function() {
        return qi
    }), i.d(e, "Light", function() {
        return Wi
    }), i.d(e, "StereoCamera", function() {
        return Vn
    }), i.d(e, "PerspectiveCamera", function() {
        return mt
    }), i.d(e, "OrthographicCamera", function() {
        return ft
    }), i.d(e, "CubeCamera", function() {
        return Wn
    }), i.d(e, "ArrayCamera", function() {
        return _e
    }), i.d(e, "Camera", function() {
        return pt
    }), i.d(e, "AudioListener", function() {
        return Xn
    }), i.d(e, "PositionalAudio", function() {
        return Yn
    }), i.d(e, "AudioContext", function() {
        return lh
    }), i.d(e, "AudioAnalyser", function() {
        return Zn
    }), i.d(e, "Audio", function() {
        return qn
    }), i.d(e, "VectorKeyframeTrack", function() {
        return on
    }), i.d(e, "StringKeyframeTrack", function() {
        return un
    }), i.d(e, "QuaternionKeyframeTrack", function() {
        return ln
    }), i.d(e, "NumberKeyframeTrack", function() {
        return cn
    }), i.d(e, "ColorKeyframeTrack", function() {
        return pn
    }), i.d(e, "BooleanKeyframeTrack", function() {
        return dn
    }), i.d(e, "PropertyMixer", function() {
        return $n
    }), i.d(e, "PropertyBinding", function() {
        return Jn
    }), i.d(e, "KeyframeTrack", function() {
        return fn
    }), i.d(e, "AnimationUtils", function() {
        return eh
    }), i.d(e, "AnimationObjectGroup", function() {
        return Kn
    }), i.d(e, "AnimationMixer", function() {
        return er
    }), i.d(e, "AnimationClip", function() {
        return mn
    }), i.d(e, "Uniform", function() {
        return ir
    }), i.d(e, "InstancedBufferGeometry", function() {
        return nr
    }), i.d(e, "BufferGeometry", function() {
        return Lt
    }), i.d(e, "GeometryIdCount", function() {
        return gt
    }), i.d(e, "Geometry", function() {
        return yt
    }), i.d(e, "InterleavedBufferAttribute", function() {
        return rr
    }), i.d(e, "InstancedInterleavedBuffer", function() {
        return ar
    }), i.d(e, "InterleavedBuffer", function() {
        return sr
    }), i.d(e, "InstancedBufferAttribute", function() {
        return or
    }), i.d(e, "Face3", function() {
        return vt
    }), i.d(e, "Object3D", function() {
        return dt
    }), i.d(e, "Raycaster", function() {
        return hr
    }), i.d(e, "Layers", function() {
        return ut
    }), i.d(e, "EventDispatcher", function() {
        return n
    }), i.d(e, "Clock", function() {
        return ur
    }), i.d(e, "QuaternionLinearInterpolant", function() {
        return hn
    }), i.d(e, "LinearInterpolant", function() {
        return rn
    }), i.d(e, "DiscreteInterpolant", function() {
        return sn
    }), i.d(e, "CubicInterpolant", function() {
        return nn
    }), i.d(e, "Interpolant", function() {
        return en
    }), i.d(e, "Triangle", function() {
        return Ft
    }), i.d(e, "Math", function() {
        return Oo
    }), i.d(e, "Spherical", function() {
        return dr
    }), i.d(e, "Cylindrical", function() {
        return pr
    }), i.d(e, "Plane", function() {
        return at
    }), i.d(e, "Frustum", function() {
        return ot
    }), i.d(e, "Sphere", function() {
        return rt
    }), i.d(e, "Ray", function() {
        return Nt
    }), i.d(e, "Matrix4", function() {
        return u
    }), i.d(e, "Matrix3", function() {
        return st
    }), i.d(e, "Box3", function() {
        return nt
    }), i.d(e, "Box2", function() {
        return Z
    }), i.d(e, "Line3", function() {
        return kt
    }), i.d(e, "Euler", function() {
        return ct
    }), i.d(e, "Vector4", function() {
        return a
    }), i.d(e, "Vector3", function() {
        return c
    }), i.d(e, "Vector2", function() {
        return r
    }), i.d(e, "Quaternion", function() {
        return l
    }), i.d(e, "Color", function() {
        return Y
    }), i.d(e, "ImmediateRenderObject", function() {
        return fr
    }), i.d(e, "VertexNormalsHelper", function() {
        return mr
    }), i.d(e, "SpotLightHelper", function() {
        return vr
    }), i.d(e, "SkeletonHelper", function() {
        return yr
    }), i.d(e, "PointLightHelper", function() {
        return _r
    }), i.d(e, "RectAreaLightHelper", function() {
        return xr
    }), i.d(e, "HemisphereLightHelper", function() {
        return br
    }), i.d(e, "GridHelper", function() {
        return wr
    }), i.d(e, "PolarGridHelper", function() {
        return Tr
    }), i.d(e, "FaceNormalsHelper", function() {
        return Mr
    }), i.d(e, "DirectionalLightHelper", function() {
        return Er
    }), i.d(e, "CameraHelper", function() {
        return Sr
    }), i.d(e, "BoxHelper", function() {
        return Ar
    }), i.d(e, "Box3Helper", function() {
        return Pr
    }), i.d(e, "PlaneHelper", function() {
        return Rr
    }), i.d(e, "ArrowHelper", function() {
        return Cr
    }), i.d(e, "AxisHelper", function() {
        return Lr
    }), i.d(e, "CatmullRomCurve3", function() {
        return Ir
    }), i.d(e, "CubicBezierCurve3", function() {
        return Dr
    }), i.d(e, "QuadraticBezierCurve3", function() {
        return zr
    }), i.d(e, "LineCurve3", function() {
        return Ur
    }), i.d(e, "ArcCurve", function() {
        return Nr
    }), i.d(e, "EllipseCurve", function() {
        return Dn
    }), i.d(e, "SplineCurve", function() {
        return zn
    }), i.d(e, "CubicBezierCurve", function() {
        return Un
    }), i.d(e, "QuadraticBezierCurve", function() {
        return Nn
    }), i.d(e, "LineCurve", function() {
        return On
    }), i.d(e, "Shape", function() {
        return Fn
    }), i.d(e, "Path", function() {
        return kn
    }), i.d(e, "ShapePath", function() {
        return Bn
    }), i.d(e, "Font", function() {
        return Gn
    }), i.d(e, "CurvePath", function() {
        return In
    }), i.d(e, "Curve", function() {
        return Ln
    }), i.d(e, "ShapeUtils", function() {
        return $o
    }), i.d(e, "SceneUtils", function() {
        return vh
    }), i.d(e, "WebGLUtils", function() {
        return Te
    }), i.d(e, "WireframeGeometry", function() {
        return We
    }), i.d(e, "ParametricGeometry", function() {
        return Xe
    }), i.d(e, "ParametricBufferGeometry", function() {
        return qe
    }), i.d(e, "TetrahedronGeometry", function() {
        return $e
    }), i.d(e, "TetrahedronBufferGeometry", function() {
        return Qe
    }), i.d(e, "OctahedronGeometry", function() {
        return Je
    }), i.d(e, "OctahedronBufferGeometry", function() {
        return Ke
    }), i.d(e, "IcosahedronGeometry", function() {
        return ti
    }), i.d(e, "IcosahedronBufferGeometry", function() {
        return ei
    }), i.d(e, "DodecahedronGeometry", function() {
        return ii
    }), i.d(e, "DodecahedronBufferGeometry", function() {
        return ni
    }), i.d(e, "PolyhedronGeometry", function() {
        return Ye
    }), i.d(e, "PolyhedronBufferGeometry", function() {
        return Ze
    }), i.d(e, "TubeGeometry", function() {
        return ri
    }), i.d(e, "TubeBufferGeometry", function() {
        return si
    }), i.d(e, "TorusKnotGeometry", function() {
        return ai
    }), i.d(e, "TorusKnotBufferGeometry", function() {
        return oi
    }), i.d(e, "TorusGeometry", function() {
        return hi
    }), i.d(e, "TorusBufferGeometry", function() {
        return li
    }), i.d(e, "TextGeometry", function() {
        return di
    }), i.d(e, "TextBufferGeometry", function() {
        return pi
    }), i.d(e, "SphereGeometry", function() {
        return fi
    }), i.d(e, "SphereBufferGeometry", function() {
        return mi
    }), i.d(e, "RingGeometry", function() {
        return vi
    }), i.d(e, "RingBufferGeometry", function() {
        return gi
    }), i.d(e, "PlaneGeometry", function() {
        return Dt
    }), i.d(e, "PlaneBufferGeometry", function() {
        return zt
    }), i.d(e, "LatheGeometry", function() {
        return yi
    }), i.d(e, "LatheBufferGeometry", function() {
        return _i
    }), i.d(e, "ShapeGeometry", function() {
        return xi
    }), i.d(e, "ShapeBufferGeometry", function() {
        return bi
    }), i.d(e, "ExtrudeGeometry", function() {
        return ci
    }), i.d(e, "ExtrudeBufferGeometry", function() {
        return ui
    }), i.d(e, "EdgesGeometry", function() {
        return wi
    }), i.d(e, "ConeGeometry", function() {
        return Ei
    }), i.d(e, "ConeBufferGeometry", function() {
        return Si
    }), i.d(e, "CylinderGeometry", function() {
        return Ti
    }), i.d(e, "CylinderBufferGeometry", function() {
        return Mi
    }), i.d(e, "CircleGeometry", function() {
        return Ai
    }), i.d(e, "CircleBufferGeometry", function() {
        return Pi
    }), i.d(e, "BoxGeometry", function() {
        return Ot
    }), i.d(e, "BoxBufferGeometry", function() {
        return It
    }), i.d(e, "ShadowMaterial", function() {
        return Ri
    }), i.d(e, "SpriteMaterial", function() {
        return Re
    }), i.d(e, "RawShaderMaterial", function() {
        return Ci
    });
    i.d(e, "ShaderMaterial", function() {
        return tt
    }), i.d(e, "PointsMaterial", function() {
        return Fe
    }), i.d(e, "MeshPhysicalMaterial", function() {
        return Oi
    }), i.d(e, "MeshStandardMaterial", function() {
        return Li
    }), i.d(e, "MeshPhongMaterial", function() {
        return Ii
    }), i.d(e, "MeshToonMaterial", function() {
        return Di
    }), i.d(e, "MeshNormalMaterial", function() {
        return zi
    }), i.d(e, "MeshLambertMaterial", function() {
        return Ui
    }), i.d(e, "MeshDepthMaterial", function() {
        return et
    }), i.d(e, "MeshDistanceMaterial", function() {
        return it
    }), i.d(e, "MeshBasicMaterial", function() {
        return Ut
    }), i.d(e, "LineDashedMaterial", function() {
        return Ni
    }), i.d(e, "LineBasicMaterial", function() {
        return ze
    }), i.d(e, "Material", function() {
        return K
    }), i.d(e, "Float64BufferAttribute", function() {
        return Pt
    }), i.d(e, "Float32BufferAttribute", function() {
        return At
    }), i.d(e, "Uint32BufferAttribute", function() {
        return St
    }), i.d(e, "Int32BufferAttribute", function() {
        return Et
    }), i.d(e, "Uint16BufferAttribute", function() {
        return Mt
    }), i.d(e, "Int16BufferAttribute", function() {
        return Tt
    }), i.d(e, "Uint8ClampedBufferAttribute", function() {
        return wt
    }), i.d(e, "Uint8BufferAttribute", function() {
        return bt
    }), i.d(e, "Int8BufferAttribute", function() {
        return xt
    }), i.d(e, "BufferAttribute", function() {
        return _t
    }), i.d(e, "REVISION", function() {
        return fs
    }), i.d(e, "MOUSE", function() {
        return ms
    }), i.d(e, "CullFaceNone", function() {
        return vs
    }), i.d(e, "CullFaceBack", function() {
        return gs
    }), i.d(e, "CullFaceFront", function() {
        return ys
    }), i.d(e, "CullFaceFrontBack", function() {
        return _s
    }), i.d(e, "FrontFaceDirectionCW", function() {
        return xs
    }), i.d(e, "FrontFaceDirectionCCW", function() {
        return bs
    }), i.d(e, "BasicShadowMap", function() {
        return ws
    }), i.d(e, "PCFShadowMap", function() {
        return Ts
    }), i.d(e, "PCFSoftShadowMap", function() {
        return Ms
    }), i.d(e, "FrontSide", function() {
        return Es
    }), i.d(e, "BackSide", function() {
        return Ss
    }), i.d(e, "DoubleSide", function() {
        return As
    }), i.d(e, "FlatShading", function() {
        return Ps
    }), i.d(e, "SmoothShading", function() {
        return Rs
    }), i.d(e, "NoColors", function() {
        return Cs
    }), i.d(e, "FaceColors", function() {
        return Ls
    }), i.d(e, "VertexColors", function() {
        return Os
    }), i.d(e, "NoBlending", function() {
        return Is
    }), i.d(e, "NormalBlending", function() {
        return Ds
    }), i.d(e, "AdditiveBlending", function() {
        return zs
    }), i.d(e, "SubtractiveBlending", function() {
        return Us
    }), i.d(e, "MultiplyBlending", function() {
        return Ns
    }), i.d(e, "CustomBlending", function() {
        return ks
    }), i.d(e, "AddEquation", function() {
        return Fs
    }), i.d(e, "SubtractEquation", function() {
        return Bs
    }), i.d(e, "ReverseSubtractEquation", function() {
        return Gs
    }), i.d(e, "MinEquation", function() {
        return Hs
    }), i.d(e, "MaxEquation", function() {
        return js
    }), i.d(e, "ZeroFactor", function() {
        return Vs
    }), i.d(e, "OneFactor", function() {
        return Ws
    }), i.d(e, "SrcColorFactor", function() {
        return Xs
    }), i.d(e, "OneMinusSrcColorFactor", function() {
        return qs
    }), i.d(e, "SrcAlphaFactor", function() {
        return Ys
    }), i.d(e, "OneMinusSrcAlphaFactor", function() {
        return Zs
    }), i.d(e, "DstAlphaFactor", function() {
        return $s
    }), i.d(e, "OneMinusDstAlphaFactor", function() {
        return Qs
    }), i.d(e, "DstColorFactor", function() {
        return Js
    }), i.d(e, "OneMinusDstColorFactor", function() {
        return Ks
    }), i.d(e, "SrcAlphaSaturateFactor", function() {
        return ta
    }), i.d(e, "NeverDepth", function() {
        return ea
    }), i.d(e, "AlwaysDepth", function() {
        return ia
    }), i.d(e, "LessDepth", function() {
        return na
    }), i.d(e, "LessEqualDepth", function() {
        return ra
    }), i.d(e, "EqualDepth", function() {
        return sa
    }), i.d(e, "GreaterEqualDepth", function() {
        return aa
    }), i.d(e, "GreaterDepth", function() {
        return oa
    }), i.d(e, "NotEqualDepth", function() {
        return ha
    }), i.d(e, "MultiplyOperation", function() {
        return la
    }), i.d(e, "MixOperation", function() {
        return ca
    }), i.d(e, "AddOperation", function() {
        return ua
    }), i.d(e, "NoToneMapping", function() {
        return da
    }), i.d(e, "LinearToneMapping", function() {
        return pa
    }), i.d(e, "ReinhardToneMapping", function() {
        return fa
    }), i.d(e, "Uncharted2ToneMapping", function() {
        return ma
    }), i.d(e, "CineonToneMapping", function() {
        return va
    }), i.d(e, "UVMapping", function() {
        return ga
    }), i.d(e, "CubeReflectionMapping", function() {
        return ya
    }), i.d(e, "CubeRefractionMapping", function() {
        return _a
    }), i.d(e, "EquirectangularReflectionMapping", function() {
        return xa
    }), i.d(e, "EquirectangularRefractionMapping", function() {
        return ba
    }), i.d(e, "SphericalReflectionMapping", function() {
        return wa
    }), i.d(e, "CubeUVReflectionMapping", function() {
        return Ta
    }), i.d(e, "CubeUVRefractionMapping", function() {
        return Ma
    }), i.d(e, "RepeatWrapping", function() {
        return Ea
    }), i.d(e, "ClampToEdgeWrapping", function() {
        return Sa
    }), i.d(e, "MirroredRepeatWrapping", function() {
        return Aa
    }), i.d(e, "NearestFilter", function() {
        return Pa
    }), i.d(e, "NearestMipMapNearestFilter", function() {
        return Ra
    }), i.d(e, "NearestMipMapLinearFilter", function() {
        return Ca
    }), i.d(e, "LinearFilter", function() {
        return La
    }), i.d(e, "LinearMipMapNearestFilter", function() {
        return Oa
    }), i.d(e, "LinearMipMapLinearFilter", function() {
        return Ia
    }), i.d(e, "UnsignedByteType", function() {
        return Da
    }), i.d(e, "ByteType", function() {
        return za
    }), i.d(e, "ShortType", function() {
        return Ua
    }), i.d(e, "UnsignedShortType", function() {
        return Na
    }), i.d(e, "IntType", function() {
        return ka
    }), i.d(e, "UnsignedIntType", function() {
        return Fa
    }), i.d(e, "FloatType", function() {
        return Ba
    }), i.d(e, "HalfFloatType", function() {
        return Ga
    }), i.d(e, "UnsignedShort4444Type", function() {
        return Ha
    }), i.d(e, "UnsignedShort5551Type", function() {
        return ja
    }), i.d(e, "UnsignedShort565Type", function() {
        return Va
    }), i.d(e, "UnsignedInt248Type", function() {
        return Wa
    }), i.d(e, "AlphaFormat", function() {
        return Xa
    }), i.d(e, "RGBFormat", function() {
        return qa
    }), i.d(e, "RGBAFormat", function() {
        return Ya
    }), i.d(e, "LuminanceFormat", function() {
        return Za
    }), i.d(e, "LuminanceAlphaFormat", function() {
        return $a
    }), i.d(e, "RGBEFormat", function() {
        return Qa
    }), i.d(e, "DepthFormat", function() {
        return Ja
    }), i.d(e, "DepthStencilFormat", function() {
        return Ka
    }), i.d(e, "RGB_S3TC_DXT1_Format", function() {
        return to
    }), i.d(e, "RGBA_S3TC_DXT1_Format", function() {
        return eo
    }), i.d(e, "RGBA_S3TC_DXT3_Format", function() {
        return io
    }), i.d(e, "RGBA_S3TC_DXT5_Format", function() {
        return no
    }), i.d(e, "RGB_PVRTC_4BPPV1_Format", function() {
        return ro
    }), i.d(e, "RGB_PVRTC_2BPPV1_Format", function() {
        return so
    }), i.d(e, "RGBA_PVRTC_4BPPV1_Format", function() {
        return ao
    }), i.d(e, "RGBA_PVRTC_2BPPV1_Format", function() {
        return oo
    }), i.d(e, "RGB_ETC1_Format", function() {
        return ho
    }), i.d(e, "LoopOnce", function() {
        return lo
    }), i.d(e, "LoopRepeat", function() {
        return co
    }), i.d(e, "LoopPingPong", function() {
        return uo
    }), i.d(e, "InterpolateDiscrete", function() {
        return po
    }), i.d(e, "InterpolateLinear", function() {
        return fo
    }), i.d(e, "InterpolateSmooth", function() {
        return mo
    }), i.d(e, "ZeroCurvatureEnding", function() {
        return vo
    }), i.d(e, "ZeroSlopeEnding", function() {
        return go
    }), i.d(e, "WrapAroundEnding", function() {
        return yo
    }), i.d(e, "TrianglesDrawMode", function() {
        return _o
    }), i.d(e, "TriangleStripDrawMode", function() {
        return xo
    }), i.d(e, "TriangleFanDrawMode", function() {
        return bo
    }), i.d(e, "LinearEncoding", function() {
        return wo
    }), i.d(e, "sRGBEncoding", function() {
        return To
    }), i.d(e, "GammaEncoding", function() {
        return Mo
    }), i.d(e, "RGBEEncoding", function() {
        return Eo
    }), i.d(e, "LogLuvEncoding", function() {
        return So
    }), i.d(e, "RGBM7Encoding", function() {
        return Ao
    }), i.d(e, "RGBM16Encoding", function() {
        return Po
    }), i.d(e, "RGBDEncoding", function() {
        return Ro
    }), i.d(e, "BasicDepthPacking", function() {
        return Co
    }), i.d(e, "RGBADepthPacking", function() {
        return Lo
    }), i.d(e, "CubeGeometry", function() {
        return Ot
    }), i.d(e, "Face4", function() {
        return kr
    }), i.d(e, "LineStrip", function() {
        return gh
    }), i.d(e, "LinePieces", function() {
        return yh
    }), i.d(e, "MeshFaceMaterial", function() {
        return Fr
    }), i.d(e, "MultiMaterial", function() {
        return Br
    }), i.d(e, "PointCloud", function() {
        return Gr
    }), i.d(e, "Particle", function() {
        return Hr
    }), i.d(e, "ParticleSystem", function() {
        return jr
    }), i.d(e, "PointCloudMaterial", function() {
        return Vr
    }), i.d(e, "ParticleBasicMaterial", function() {
        return Wr
    }), i.d(e, "ParticleSystemMaterial", function() {
        return Xr
    }), i.d(e, "Vertex", function() {
        return qr
    }), i.d(e, "DynamicBufferAttribute", function() {
        return Yr
    }), i.d(e, "Int8Attribute", function() {
        return Zr
    }), i.d(e, "Uint8Attribute", function() {
        return $r
    }), i.d(e, "Uint8ClampedAttribute", function() {
        return Qr
    }), i.d(e, "Int16Attribute", function() {
        return Jr
    }), i.d(e, "Uint16Attribute", function() {
        return Kr
    }), i.d(e, "Int32Attribute", function() {
        return ts
    }), i.d(e, "Uint32Attribute", function() {
        return es
    }), i.d(e, "Float32Attribute", function() {
        return is
    }), i.d(e, "Float64Attribute", function() {
        return ns
    }), i.d(e, "ClosedSplineCurve3", function() {
        return rs
    }), i.d(e, "SplineCurve3", function() {
        return ss
    }), i.d(e, "Spline", function() {
        return as
    }), i.d(e, "BoundingBoxHelper", function() {
        return os
    }), i.d(e, "EdgesHelper", function() {
        return hs
    }), i.d(e, "WireframeHelper", function() {
        return ls
    }), i.d(e, "XHRLoader", function() {
        return cs
    }), i.d(e, "BinaryTextureLoader", function() {
        return us
    }), i.d(e, "GeometryUtils", function() {
        return _h
    }), i.d(e, "ImageUtils", function() {
        return xh
    }), i.d(e, "Projector", function() {
        return ds
    }), i.d(e, "CanvasRenderer", function() {
        return ps
    }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }), void 0 === Math.sign && (Math.sign = function(t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t
    }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && function() {
        Object.assign = function(t) {
            if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
            for (var e = Object(t), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (void 0 !== n && null !== n)
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }
    }(), Object.assign(n.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[t] && -1 !== i[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            if (void 0 !== this._listeners) {
                var i = this._listeners,
                    n = i[t];
                if (void 0 !== n) {
                    var r = n.indexOf(e); - 1 !== r && n.splice(r, 1)
                }
            }
        },
        dispatchEvent: function(t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners,
                    i = e[t.type];
                if (void 0 !== i) {
                    t.target = this;
                    for (var n = i.slice(0), r = 0, s = n.length; r < s; r++) n[r].call(this, t)
                }
            }
        }
    });
    var fs = "87",
        ms = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        },
        vs = 0,
        gs = 1,
        ys = 2,
        _s = 3,
        xs = 0,
        bs = 1,
        ws = 0,
        Ts = 1,
        Ms = 2,
        Es = 0,
        Ss = 1,
        As = 2,
        Ps = 1,
        Rs = 2,
        Cs = 0,
        Ls = 1,
        Os = 2,
        Is = 0,
        Ds = 1,
        zs = 2,
        Us = 3,
        Ns = 4,
        ks = 5,
        Fs = 100,
        Bs = 101,
        Gs = 102,
        Hs = 103,
        js = 104,
        Vs = 200,
        Ws = 201,
        Xs = 202,
        qs = 203,
        Ys = 204,
        Zs = 205,
        $s = 206,
        Qs = 207,
        Js = 208,
        Ks = 209,
        ta = 210,
        ea = 0,
        ia = 1,
        na = 2,
        ra = 3,
        sa = 4,
        aa = 5,
        oa = 6,
        ha = 7,
        la = 0,
        ca = 1,
        ua = 2,
        da = 0,
        pa = 1,
        fa = 2,
        ma = 3,
        va = 4,
        ga = 300,
        ya = 301,
        _a = 302,
        xa = 303,
        ba = 304,
        wa = 305,
        Ta = 306,
        Ma = 307,
        Ea = 1e3,
        Sa = 1001,
        Aa = 1002,
        Pa = 1003,
        Ra = 1004,
        Ca = 1005,
        La = 1006,
        Oa = 1007,
        Ia = 1008,
        Da = 1009,
        za = 1010,
        Ua = 1011,
        Na = 1012,
        ka = 1013,
        Fa = 1014,
        Ba = 1015,
        Ga = 1016,
        Ha = 1017,
        ja = 1018,
        Va = 1019,
        Wa = 1020,
        Xa = 1021,
        qa = 1022,
        Ya = 1023,
        Za = 1024,
        $a = 1025,
        Qa = Ya,
        Ja = 1026,
        Ka = 1027,
        to = 2001,
        eo = 2002,
        io = 2003,
        no = 2004,
        ro = 2100,
        so = 2101,
        ao = 2102,
        oo = 2103,
        ho = 2151,
        lo = 2200,
        co = 2201,
        uo = 2202,
        po = 2300,
        fo = 2301,
        mo = 2302,
        vo = 2400,
        go = 2401,
        yo = 2402,
        _o = 0,
        xo = 1,
        bo = 2,
        wo = 3e3,
        To = 3001,
        Mo = 3007,
        Eo = 3002,
        So = 3003,
        Ao = 3004,
        Po = 3005,
        Ro = 3006,
        Co = 3200,
        Lo = 3201,
        Oo = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                    i = new Array(36),
                    n = 0;
                return function() {
                    for (var r = 0; r < 36; r++) 8 === r || 13 === r || 18 === r || 23 === r ? i[r] = "-" : 14 === r ? i[r] = "4" : (n <= 2 && (n = 33554432 + 16777216 * Math.random() | 0), t = 15 & n, n >>= 4, i[r] = e[19 === r ? 3 & t | 8 : t]);
                    return i.join("")
                }
            }(),
            clamp: function(t, e, i) {
                return Math.max(e, Math.min(i, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, i, n, r) {
                return n + (t - e) * (r - n) / (i - e)
            },
            lerp: function(t, e, i) {
                return (1 - i) * t + i * e
            },
            smoothstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            degToRad: function(t) {
                return t * Oo.DEG2RAD
            },
            radToDeg: function(t) {
                return t * Oo.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 == (t & t - 1) && 0 !== t
            },
            nearestPowerOfTwo: function(t) {
                return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
            },
            nextPowerOfTwo: function(t) {
                return t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t
            }
        };
    Object.defineProperties(r.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }
    }), Object.assign(r.prototype, {
        isVector2: !0,
        set: function(t, e) {
            return this.x = t, this.y = e, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        },
        multiply: function(t) {
            return this.x *= t.x, this.y *= t.y, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        },
        clampScalar: function() {
            var t = new r,
                e = new r;
            return function(i, n) {
                return t.set(i, i), e.set(n, n), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var t = Math.atan2(this.y, this.x);
            return t < 0 && (t += 2 * Math.PI), t
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
                i = this.y - t.y;
            return e * e + i * i
        },
        distanceToManhattan: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        },
        lerpVectors: function(t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
        },
        fromBufferAttribute: function(t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
        },
        rotateAround: function(t, e) {
            var i = Math.cos(e),
                n = Math.sin(e),
                r = this.x - t.x,
                s = this.y - t.y;
            return this.x = r * i - s * n + t.x, this.y = r * n + s * i + t.y, this
        }
    });
    var Io = 0;
    s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = ga, Object.defineProperty(s.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(s.prototype, n.prototype, {
        constructor: s,
        isTexture: !0,
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
        },
        toJSON: function(t) {
            if (void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var i = this.image;
                void 0 === i.uuid && (i.uuid = Oo.generateUUID()), void 0 === t.images[i.uuid] && (t.images[i.uuid] = {
                    uuid: i.uuid,
                    url: function(t) {
                        var e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), e.width = t.width, e.height = t.height;
                            var i = e.getContext("2d");
                            t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height)
                        }
                        return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }(i)
                }), e.image = i.uuid
            }
            return t.textures[this.uuid] = e, e
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (this.mapping === ga) {
                if (t.multiply(this.repeat), t.add(this.offset), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case Ea:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case Sa:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case Aa:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case Ea:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case Sa:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case Aa:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                this.flipY && (t.y = 1 - t.y)
            }
        }
    }), Object.assign(a.prototype, {
        isVector4: !0,
        set: function(t, e, i, n) {
            return this.x = t, this.y = e, this.z = i, this.w = n, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this.z = t, this.w = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setW: function(t) {
            return this.w = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = this.w,
                s = t.elements;
            return this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r, this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r, this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r, this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e, i, n, r, s = t.elements,
                a = s[0],
                o = s[4],
                h = s[8],
                l = s[1],
                c = s[5],
                u = s[9],
                d = s[2],
                p = s[6],
                f = s[10];
            if (Math.abs(o - l) < .01 && Math.abs(h - d) < .01 && Math.abs(u - p) < .01) {
                if (Math.abs(o + l) < .1 && Math.abs(h + d) < .1 && Math.abs(u + p) < .1 && Math.abs(a + c + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                e = Math.PI;
                var m = (a + 1) / 2,
                    v = (c + 1) / 2,
                    g = (f + 1) / 2,
                    y = (o + l) / 4,
                    _ = (h + d) / 4,
                    x = (u + p) / 4;
                return m > v && m > g ? m < .01 ? (i = 0, n = .707106781, r = .707106781) : (i = Math.sqrt(m), n = y / i, r = _ / i) : v > g ? v < .01 ? (i = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(v), i = y / n, r = x / n) : g < .01 ? (i = .707106781, n = .707106781, r = 0) : (r = Math.sqrt(g), i = _ / r, n = x / r), this.set(i, n, r, e), this
            }
            var b = Math.sqrt((p - u) * (p - u) + (h - d) * (h - d) + (l - o) * (l - o));
            return Math.abs(b) < .001 && (b = 1), this.x = (p - u) / b, this.y = (h - d) / b, this.z = (l - o) / b, this.w = Math.acos((a + c + f - 1) / 2), this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
        },
        clampScalar: function() {
            var t, e;
            return function(i, n) {
                return void 0 === t && (t = new a, e = new a), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        },
        lerpVectors: function(t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
        },
        fromBufferAttribute: function(t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
        }
    }), Object.assign(o.prototype, n.prototype, {
        isWebGLRenderTarget: !0,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), h.prototype = Object.create(o.prototype), h.prototype.constructor = h, h.prototype.isWebGLRenderTargetCube = !0, Object.assign(l, {
        slerp: function(t, e, i, n) {
            return i.copy(t).slerp(e, n)
        },
        slerpFlat: function(t, e, i, n, r, s, a) {
            var o = i[n + 0],
                h = i[n + 1],
                l = i[n + 2],
                c = i[n + 3],
                u = r[s + 0],
                d = r[s + 1],
                p = r[s + 2],
                f = r[s + 3];
            if (c !== f || o !== u || h !== d || l !== p) {
                var m = 1 - a,
                    v = o * u + h * d + l * p + c * f,
                    g = v >= 0 ? 1 : -1,
                    y = 1 - v * v;
                if (y > Number.EPSILON) {
                    var _ = Math.sqrt(y),
                        x = Math.atan2(_, v * g);
                    m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                }
                var b = a * g;
                if (o = o * m + u * b, h = h * m + d * b, l = l * m + p * b, c = c * m + f * b, m === 1 - a) {
                    var w = 1 / Math.sqrt(o * o + h * h + l * l + c * c);
                    o *= w, h *= w, l *= w, c *= w
                }
            }
            t[e] = o, t[e + 1] = h, t[e + 2] = l, t[e + 3] = c
        }
    }), Object.defineProperties(l.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t, this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(t) {
                this._w = t, this.onChangeCallback()
            }
        }
    }), Object.assign(l.prototype, {
        set: function(t, e, i, n) {
            return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
        },
        setFromEuler: function(t, e) {
            if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = t._x,
                n = t._y,
                r = t._z,
                s = t.order,
                a = Math.cos,
                o = Math.sin,
                h = a(i / 2),
                l = a(n / 2),
                c = a(r / 2),
                u = o(i / 2),
                d = o(n / 2),
                p = o(r / 2);
            return "XYZ" === s ? (this._x = u * l * c + h * d * p, this._y = h * d * c - u * l * p, this._z = h * l * p + u * d * c, this._w = h * l * c - u * d * p) : "YXZ" === s ? (this._x = u * l * c + h * d * p, this._y = h * d * c - u * l * p, this._z = h * l * p - u * d * c, this._w = h * l * c + u * d * p) : "ZXY" === s ? (this._x = u * l * c - h * d * p, this._y = h * d * c + u * l * p, this._z = h * l * p + u * d * c, this._w = h * l * c - u * d * p) : "ZYX" === s ? (this._x = u * l * c - h * d * p, this._y = h * d * c + u * l * p, this._z = h * l * p - u * d * c, this._w = h * l * c + u * d * p) : "YZX" === s ? (this._x = u * l * c + h * d * p, this._y = h * d * c + u * l * p, this._z = h * l * p - u * d * c, this._w = h * l * c - u * d * p) : "XZY" === s && (this._x = u * l * c - h * d * p, this._y = h * d * c - u * l * p, this._z = h * l * p + u * d * c, this._w = h * l * c + u * d * p), !1 !== e && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(t, e) {
            var i = e / 2,
                n = Math.sin(i);
            return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t) {
            var e, i = t.elements,
                n = i[0],
                r = i[4],
                s = i[8],
                a = i[1],
                o = i[5],
                h = i[9],
                l = i[2],
                c = i[6],
                u = i[10],
                d = n + o + u;
            return d > 0 ? (e = .5 / Math.sqrt(d + 1), this._w = .25 / e, this._x = (c - h) * e, this._y = (s - l) * e, this._z = (a - r) * e) : n > o && n > u ? (e = 2 * Math.sqrt(1 + n - o - u), this._w = (c - h) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (s + l) / e) : o > u ? (e = 2 * Math.sqrt(1 + o - n - u), this._w = (s - l) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (h + c) / e) : (e = 2 * Math.sqrt(1 + u - n - o), this._w = (a - r) / e, this._x = (s + l) / e, this._y = (h + c) / e, this._z = .25 * e), this.onChangeCallback(), this
        },
        setFromUnitVectors: function() {
            var t, e = new c;
            return function(i, n) {
                return void 0 === e && (e = new c), t = i.dot(n) + 1, t < 1e-6 ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, n), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
            }
        }(),
        inverse: function() {
            return this.conjugate().normalize()
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        premultiply: function(t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function(t, e) {
            var i = t._x,
                n = t._y,
                r = t._z,
                s = t._w,
                a = e._x,
                o = e._y,
                h = e._z,
                l = e._w;
            return this._x = i * l + s * a + n * h - r * o, this._y = n * l + s * o + r * a - i * h, this._z = r * l + s * h + i * o - n * a, this._w = s * l - i * a - n * o - r * h, this.onChangeCallback(), this
        },
        slerp: function(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            var i = this._x,
                n = this._y,
                r = this._z,
                s = this._w,
                a = s * t._w + i * t._x + n * t._y + r * t._z;
            if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = i, this._y = n, this._z = r, this;
            var o = Math.sqrt(1 - a * a);
            if (Math.abs(o) < .001) return this._w = .5 * (s + this._w), this._x = .5 * (i + this._x), this._y = .5 * (n + this._y), this._z = .5 * (r + this._z), this;
            var h = Math.atan2(o, a),
                l = Math.sin((1 - e) * h) / o,
                c = Math.sin(e * h) / o;
            return this._w = s * l + this._w * c, this._x = i * l + this._x * c, this._y = n * l + this._y * c, this._z = r * l + this._z * c, this.onChangeCallback(), this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {}
    }), Object.assign(c.prototype, {
        isVector3: !0,
        set: function(t, e, i) {
            return this.x = t, this.y = e, this.z = i, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this.z = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        },
        applyEuler: function() {
            var t = new l;
            return function(e) {
                return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
            }
        }(),
        applyAxisAngle: function() {
            var t = new l;
            return function(e, i) {
                return this.applyQuaternion(t.setFromAxisAngle(e, i))
            }
        }(),
        applyMatrix3: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = t.elements,
                s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
            return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s, this
        },
        applyQuaternion: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = t.x,
                s = t.y,
                a = t.z,
                o = t.w,
                h = o * e + s * n - a * i,
                l = o * i + a * e - r * n,
                c = o * n + r * i - s * e,
                u = -r * e - s * i - a * n;
            return this.x = h * o + u * -r + l * -a - c * -s, this.y = l * o + u * -s + c * -r - h * -a, this.z = c * o + u * -a + h * -s - l * -r, this
        },
        project: function() {
            var t = new u;
            return function(e) {
                return t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyMatrix4(t)
            }
        }(),
        unproject: function() {
            var t = new u;
            return function(e) {
                return t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyMatrix4(t)
            }
        }(),
        transformDirection: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        },
        clampScalar: function() {
            var t = new c,
                e = new c;
            return function(i, n) {
                return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        },
        lerpVectors: function(t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        },
        cross: function(t, e) {
            if (void 0 !== e) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e);
            var i = this.x,
                n = this.y,
                r = this.z;
            return this.x = n * t.z - r * t.y, this.y = r * t.x - i * t.z, this.z = i * t.y - n * t.x, this
        },
        crossVectors: function(t, e) {
            var i = t.x,
                n = t.y,
                r = t.z,
                s = e.x,
                a = e.y,
                o = e.z;
            return this.x = n * o - r * a, this.y = r * s - i * o, this.z = i * a - n * s, this
        },
        projectOnVector: function(t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e)
        },
        projectOnPlane: function() {
            var t = new c;
            return function(e) {
                return t.copy(this).projectOnVector(e), this.sub(t)
            }
        }(),
        reflect: function() {
            var t = new c;
            return function(e) {
                return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        }(),
        angleTo: function(t) {
            var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
            return Math.acos(Oo.clamp(e, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
                i = this.y - t.y,
                n = this.z - t.z;
            return e * e + i * i + n * n
        },
        distanceToManhattan: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function(t) {
            var e = Math.sin(t.phi) * t.radius;
            return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this
        },
        setFromCylindrical: function(t) {
            return this.x = t.radius * Math.sin(t.theta), this.y = t.y, this.z = t.radius * Math.cos(t.theta), this
        },
        setFromMatrixPosition: function(t) {
            var e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function(t) {
            var e = this.setFromMatrixColumn(t, 0).length(),
                i = this.setFromMatrixColumn(t, 1).length(),
                n = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = i, this.z = n, this
        },
        setFromMatrixColumn: function(t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        },
        fromBufferAttribute: function(t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        }
    }), Object.assign(u.prototype, {
        isMatrix4: !0,
        set: function(t, e, i, n, r, s, a, o, h, l, c, u, d, p, f, m) {
            var v = this.elements;
            return v[0] = t, v[4] = e, v[8] = i, v[12] = n, v[1] = r, v[5] = s, v[9] = a, v[13] = o, v[2] = h, v[6] = l, v[10] = c, v[14] = u, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new u).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements,
                i = t.elements;
            return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
        },
        copyPosition: function(t) {
            var e = this.elements,
                i = t.elements;
            return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
        },
        extractBasis: function(t, e, i) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function(t, e, i) {
            return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function() {
            var t = new c;
            return function(e) {
                var i = this.elements,
                    n = e.elements,
                    r = 1 / t.setFromMatrixColumn(e, 0).length(),
                    s = 1 / t.setFromMatrixColumn(e, 1).length(),
                    a = 1 / t.setFromMatrixColumn(e, 2).length();
                return i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[4] = n[4] * s, i[5] = n[5] * s, i[6] = n[6] * s, i[8] = n[8] * a, i[9] = n[9] * a, i[10] = n[10] * a, this
            }
        }(),
        makeRotationFromEuler: function(t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e = this.elements,
                i = t.x,
                n = t.y,
                r = t.z,
                s = Math.cos(i),
                a = Math.sin(i),
                o = Math.cos(n),
                h = Math.sin(n),
                l = Math.cos(r),
                c = Math.sin(r);
            if ("XYZ" === t.order) {
                var u = s * l,
                    d = s * c,
                    p = a * l,
                    f = a * c;
                e[0] = o * l, e[4] = -o * c, e[8] = h, e[1] = d + p * h, e[5] = u - f * h, e[9] = -a * o, e[2] = f - u * h, e[6] = p + d * h, e[10] = s * o
            } else if ("YXZ" === t.order) {
                var m = o * l,
                    v = o * c,
                    g = h * l,
                    y = h * c;
                e[0] = m + y * a, e[4] = g * a - v, e[8] = s * h, e[1] = s * c, e[5] = s * l, e[9] = -a, e[2] = v * a - g, e[6] = y + m * a, e[10] = s * o
            } else if ("ZXY" === t.order) {
                var m = o * l,
                    v = o * c,
                    g = h * l,
                    y = h * c;
                e[0] = m - y * a, e[4] = -s * c, e[8] = g + v * a, e[1] = v + g * a, e[5] = s * l, e[9] = y - m * a, e[2] = -s * h, e[6] = a, e[10] = s * o
            } else if ("ZYX" === t.order) {
                var u = s * l,
                    d = s * c,
                    p = a * l,
                    f = a * c;
                e[0] = o * l, e[4] = p * h - d, e[8] = u * h + f, e[1] = o * c, e[5] = f * h + u, e[9] = d * h - p, e[2] = -h, e[6] = a * o, e[10] = s * o
            } else if ("YZX" === t.order) {
                var _ = s * o,
                    x = s * h,
                    b = a * o,
                    w = a * h;
                e[0] = o * l, e[4] = w - _ * c, e[8] = b * c + x, e[1] = c, e[5] = s * l, e[9] = -a * l, e[2] = -h * l, e[6] = x * c + b, e[10] = _ - w * c
            } else if ("XZY" === t.order) {
                var _ = s * o,
                    x = s * h,
                    b = a * o,
                    w = a * h;
                e[0] = o * l, e[4] = -c, e[8] = h * l, e[1] = _ * c + w, e[5] = s * l, e[9] = x * c - b, e[2] = b * c - x, e[6] = a * l, e[10] = w * c + _
            }
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        makeRotationFromQuaternion: function(t) {
            var e = this.elements,
                i = t._x,
                n = t._y,
                r = t._z,
                s = t._w,
                a = i + i,
                o = n + n,
                h = r + r,
                l = i * a,
                c = i * o,
                u = i * h,
                d = n * o,
                p = n * h,
                f = r * h,
                m = s * a,
                v = s * o,
                g = s * h;
            return e[0] = 1 - (d + f), e[4] = c - g, e[8] = u + v, e[1] = c + g, e[5] = 1 - (l + f), e[9] = p - m, e[2] = u - v, e[6] = p + m, e[10] = 1 - (l + d), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        lookAt: function() {
            var t = new c,
                e = new c,
                i = new c;
            return function(n, r, s) {
                var a = this.elements;
                return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), t.crossVectors(s, i), 0 === t.lengthSq() && (1 === Math.abs(s.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(s, i)), t.normalize(), e.crossVectors(i, t), a[0] = t.x, a[4] = e.x, a[8] = i.x, a[1] = t.y, a[5] = e.y, a[9] = i.y, a[2] = t.z, a[6] = e.z, a[10] = i.z, this
            }
        }(),
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var i = t.elements,
                n = e.elements,
                r = this.elements,
                s = i[0],
                a = i[4],
                o = i[8],
                h = i[12],
                l = i[1],
                c = i[5],
                u = i[9],
                d = i[13],
                p = i[2],
                f = i[6],
                m = i[10],
                v = i[14],
                g = i[3],
                y = i[7],
                _ = i[11],
                x = i[15],
                b = n[0],
                w = n[4],
                T = n[8],
                M = n[12],
                E = n[1],
                S = n[5],
                A = n[9],
                P = n[13],
                R = n[2],
                C = n[6],
                L = n[10],
                O = n[14],
                I = n[3],
                D = n[7],
                z = n[11],
                U = n[15];
            return r[0] = s * b + a * E + o * R + h * I, r[4] = s * w + a * S + o * C + h * D, r[8] = s * T + a * A + o * L + h * z, r[12] = s * M + a * P + o * O + h * U, r[1] = l * b + c * E + u * R + d * I, r[5] = l * w + c * S + u * C + d * D, r[9] = l * T + c * A + u * L + d * z, r[13] = l * M + c * P + u * O + d * U, r[2] = p * b + f * E + m * R + v * I, r[6] = p * w + f * S + m * C + v * D, r[10] = p * T + f * A + m * L + v * z, r[14] = p * M + f * P + m * O + v * U, r[3] = g * b + y * E + _ * R + x * I, r[7] = g * w + y * S + _ * C + x * D, r[11] = g * T + y * A + _ * L + x * z, r[15] = g * M + y * P + _ * O + x * U, this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        },
        applyToBufferAttribute: function() {
            var t = new c;
            return function(e) {
                for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
                return e
            }
        }(),
        determinant: function() {
            var t = this.elements,
                e = t[0],
                i = t[4],
                n = t[8],
                r = t[12],
                s = t[1],
                a = t[5],
                o = t[9],
                h = t[13],
                l = t[2],
                c = t[6],
                u = t[10],
                d = t[14];
            return t[3] * (+r * o * c - n * h * c - r * a * u + i * h * u + n * a * d - i * o * d) + t[7] * (+e * o * d - e * h * u + r * s * u - n * s * d + n * h * l - r * o * l) + t[11] * (+e * h * c - e * a * d - r * s * c + i * s * d + r * a * l - i * h * l) + t[15] * (-n * a * l - e * o * c + e * a * u + n * s * c - i * s * u + i * o * l)
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        setPosition: function(t) {
            var e = this.elements;
            return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
        },
        getInverse: function(t, e) {
            var i = this.elements,
                n = t.elements,
                r = n[0],
                s = n[1],
                a = n[2],
                o = n[3],
                h = n[4],
                l = n[5],
                c = n[6],
                u = n[7],
                d = n[8],
                p = n[9],
                f = n[10],
                m = n[11],
                v = n[12],
                g = n[13],
                y = n[14],
                _ = n[15],
                x = p * y * u - g * f * u + g * c * m - l * y * m - p * c * _ + l * f * _,
                b = v * f * u - d * y * u - v * c * m + h * y * m + d * c * _ - h * f * _,
                w = d * g * u - v * p * u + v * l * m - h * g * m - d * l * _ + h * p * _,
                T = v * p * c - d * g * c - v * l * f + h * g * f + d * l * y - h * p * y,
                M = r * x + s * b + a * w + o * T;
            if (0 === M) {
                var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === e) throw new Error(E);
                return console.warn(E), this.identity()
            }
            var S = 1 / M;
            return i[0] = x * S, i[1] = (g * f * o - p * y * o - g * a * m + s * y * m + p * a * _ - s * f * _) * S, i[2] = (l * y * o - g * c * o + g * a * u - s * y * u - l * a * _ + s * c * _) * S, i[3] = (p * c * o - l * f * o - p * a * u + s * f * u + l * a * m - s * c * m) * S, i[4] = b * S, i[5] = (d * y * o - v * f * o + v * a * m - r * y * m - d * a * _ + r * f * _) * S, i[6] = (v * c * o - h * y * o - v * a * u + r * y * u + h * a * _ - r * c * _) * S, i[7] = (h * f * o - d * c * o + d * a * u - r * f * u - h * a * m + r * c * m) * S, i[8] = w * S, i[9] = (v * p * o - d * g * o - v * s * m + r * g * m + d * s * _ - r * p * _) * S, i[10] = (h * g * o - v * l * o + v * s * u - r * g * u - h * s * _ + r * l * _) * S, i[11] = (d * l * o - h * p * o - d * s * u + r * p * u + h * s * m - r * l * m) * S, i[12] = T * S, i[13] = (d * g * a - v * p * a + v * s * f - r * g * f - d * s * y + r * p * y) * S, i[14] = (v * l * a - h * g * a - v * s * c + r * g * c + h * s * y - r * l * y) * S, i[15] = (h * p * a - d * l * a + d * s * c - r * p * c - h * s * f + r * l * f) * S, this
        },
        scale: function(t) {
            var e = this.elements,
                i = t.x,
                n = t.y,
                r = t.z;
            return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
        },
        getMaxScaleOnAxis: function() {
            var t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, i, n))
        },
        makeTranslation: function(t, e, i) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
        },
        makeRotationX: function(t) {
            var e = Math.cos(t),
                i = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(t) {
            var e = Math.cos(t),
                i = Math.sin(t);
            return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(t) {
            var e = Math.cos(t),
                i = Math.sin(t);
            return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(t, e) {
            var i = Math.cos(e),
                n = Math.sin(e),
                r = 1 - i,
                s = t.x,
                a = t.y,
                o = t.z,
                h = r * s,
                l = r * a;
            return this.set(h * s + i, h * a - n * o, h * o + n * a, 0, h * a + n * o, l * a + i, l * o - n * s, 0, h * o - n * a, l * o + n * s, r * o * o + i, 0, 0, 0, 0, 1), this
        },
        makeScale: function(t, e, i) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        },
        makeShear: function(t, e, i) {
            return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
        },
        compose: function(t, e, i) {
            return this.makeRotationFromQuaternion(e), this.scale(i), this.setPosition(t), this
        },
        decompose: function() {
            var t = new c,
                e = new u;
            return function(i, n, r) {
                var s = this.elements,
                    a = t.set(s[0], s[1], s[2]).length(),
                    o = t.set(s[4], s[5], s[6]).length(),
                    h = t.set(s[8], s[9], s[10]).length();
                this.determinant() < 0 && (a = -a), i.x = s[12], i.y = s[13], i.z = s[14], e.copy(this);
                var l = 1 / a,
                    c = 1 / o,
                    u = 1 / h;
                return e.elements[0] *= l, e.elements[1] *= l, e.elements[2] *= l, e.elements[4] *= c, e.elements[5] *= c, e.elements[6] *= c, e.elements[8] *= u, e.elements[9] *= u, e.elements[10] *= u, n.setFromRotationMatrix(e), r.x = a, r.y = o, r.z = h, this
            }
        }(),
        makePerspective: function(t, e, i, n, r, s) {
            void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements,
                o = 2 * r / (e - t),
                h = 2 * r / (i - n),
                l = (e + t) / (e - t),
                c = (i + n) / (i - n),
                u = -(s + r) / (s - r),
                d = -2 * s * r / (s - r);
            return a[0] = o, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = h, a[9] = c, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makeOrthographic: function(t, e, i, n, r, s) {
            var a = this.elements,
                o = 1 / (e - t),
                h = 1 / (i - n),
                l = 1 / (s - r),
                c = (e + t) * o,
                u = (i + n) * h,
                d = (s + r) * l;
            return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -c, a[1] = 0, a[5] = 2 * h, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        equals: function(t) {
            for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
                if (e[n] !== i[n]) return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var i = this.elements;
            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
        }
    }), d.prototype = Object.create(s.prototype), d.prototype.constructor = d, d.prototype.isDataTexture = !0, p.prototype = Object.create(s.prototype), p.prototype.constructor = p, p.prototype.isCubeTexture = !0, Object.defineProperty(p.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    });
    var Do = new s,
        zo = new p,
        Uo = [],
        No = [],
        ko = new Float32Array(16),
        Fo = new Float32Array(9);
    V.prototype.setValue = function(t, e) {
        for (var i = this.seq, n = 0, r = i.length; n !== r; ++n) {
            var s = i[n];
            s.setValue(t, e[s.id])
        }
    };
    var Bo = /([\w\d_]+)(\])?(\[|\.)?/g;
    q.prototype.setValue = function(t, e, i) {
        var n = this.map[e];
        void 0 !== n && n.setValue(t, i, this.renderer)
    }, q.prototype.setOptional = function(t, e, i) {
        var n = e[i];
        void 0 !== n && this.setValue(t, i, n)
    }, q.upload = function(t, e, i, n) {
        for (var r = 0, s = e.length; r !== s; ++r) {
            var a = e[r],
                o = i[a.id];
            !1 !== o.needsUpdate && a.setValue(t, o.value, n)
        }
    }, q.seqWithValue = function(t, e) {
        for (var i = [], n = 0, r = t.length; n !== r; ++n) {
            var s = t[n];
            s.id in e && i.push(s)
        }
        return i
    };
    var Go = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Object.assign(Y.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
        },
        setScalar: function(t) {
            return this.r = t, this.g = t, this.b = t, this
        },
        setHex: function(t) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
        },
        setRGB: function(t, e, i) {
            return this.r = t, this.g = e, this.b = i, this
        },
        setHSL: function() {
            function t(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
            }
            return function(e, i, n) {
                if (e = Oo.euclideanModulo(e, 1), i = Oo.clamp(i, 0, 1), n = Oo.clamp(n, 0, 1), 0 === i) this.r = this.g = this.b = n;
                else {
                    var r = n <= .5 ? n * (1 + i) : n + i - n * i,
                        s = 2 * n - r;
                    this.r = t(s, r, e + 1 / 3), this.g = t(s, r, e), this.b = t(s, r, e - 1 / 3)
                }
                return this
            }
        }(),
        setStyle: function(t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var n, r = i[1],
                    s = i[2];
                switch (r) {
                    case "rgb":
                    case "rgba":
                        if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                        if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s)) {
                            var a = parseFloat(n[1]) / 360,
                                o = parseInt(n[2], 10) / 100,
                                h = parseInt(n[3], 10) / 100;
                            return e(n[5]), this.setHSL(a, o, h)
                        }
                }
            } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                var l = i[1],
                    c = l.length;
                if (3 === c) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                if (6 === c) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
            }
            if (t && t.length > 0) {
                var l = Go[t];
                void 0 !== l ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t)
            }
            return this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        },
        copyGammaToLinear: function(t, e) {
            return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
        },
        copyLinearToGamma: function(t, e) {
            void 0 === e && (e = 2);
            var i = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
        },
        convertGammaToLinear: function() {
            var t = this.r,
                e = this.g,
                i = this.b;
            return this.r = t * t, this.g = e * e, this.b = i * i, this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            var e, i, n = t || {
                    h: 0,
                    s: 0,
                    l: 0
                },
                r = this.r,
                s = this.g,
                a = this.b,
                o = Math.max(r, s, a),
                h = Math.min(r, s, a),
                l = (h + o) / 2;
            if (h === o) e = 0, i = 0;
            else {
                var c = o - h;
                switch (i = l <= .5 ? c / (o + h) : c / (2 - o - h), o) {
                    case r:
                        e = (s - a) / c + (s < a ? 6 : 0);
                        break;
                    case s:
                        e = (a - r) / c + 2;
                        break;
                    case a:
                        e = (r - s) / c + 4
                }
                e /= 6
            }
            return n.h = e, n.s = i, n.l = l, n
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(t, e, i) {
            var n = this.getHSL();
            return n.h += t, n.s += e, n.l += i, this.setHSL(n.h, n.s, n.l), this
        },
        add: function(t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        },
        addScalar: function(t) {
            return this.r += t, this.g += t, this.b += t, this
        },
        sub: function(t) {
            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
        },
        multiply: function(t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        },
        multiplyScalar: function(t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        },
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var Ho = {
            common: {
                diffuse: {
                    value: new Y(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                offsetRepeat: {
                    value: new a(0, 0, 1, 1)
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new r(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Y(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new Y(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                offsetRepeat: {
                    value: new a(0, 0, 1, 1)
                }
            }
        },
        jo = {
            merge: function(t) {
                for (var e = {}, i = 0; i < t.length; i++) {
                    var n = this.clone(t[i]);
                    for (var r in n) e[r] = n[r]
                }
                return e
            },
            clone: function(t) {
                var e = {};
                for (var i in t) {
                    e[i] = {};
                    for (var n in t[i]) {
                        var r = t[i][n];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                    }
                }
                return e
            }
        },
        Vo = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
            bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
            defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
            encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
            fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
            lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
            lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
            logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
            normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
            project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
            dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
            dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
            tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
            cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
            equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
            shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
        },
        Wo = {
            basic: {
                uniforms: jo.merge([Ho.common, Ho.specularmap, Ho.envmap, Ho.aomap, Ho.lightmap, Ho.fog]),
                vertexShader: Vo.meshbasic_vert,
                fragmentShader: Vo.meshbasic_frag
            },
            lambert: {
                uniforms: jo.merge([Ho.common, Ho.specularmap, Ho.envmap, Ho.aomap, Ho.lightmap, Ho.emissivemap, Ho.fog, Ho.lights, {
                    emissive: {
                        value: new Y(0)
                    }
                }]),
                vertexShader: Vo.meshlambert_vert,
                fragmentShader: Vo.meshlambert_frag
            },
            phong: {
                uniforms: jo.merge([Ho.common, Ho.specularmap, Ho.envmap, Ho.aomap, Ho.lightmap, Ho.emissivemap, Ho.bumpmap, Ho.normalmap, Ho.displacementmap, Ho.gradientmap, Ho.fog, Ho.lights, {
                    emissive: {
                        value: new Y(0)
                    },
                    specular: {
                        value: new Y(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Vo.meshphong_vert,
                fragmentShader: Vo.meshphong_frag
            },
            standard: {
                uniforms: jo.merge([Ho.common, Ho.envmap, Ho.aomap, Ho.lightmap, Ho.emissivemap, Ho.bumpmap, Ho.normalmap, Ho.displacementmap, Ho.roughnessmap, Ho.metalnessmap, Ho.fog, Ho.lights, {
                    emissive: {
                        value: new Y(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Vo.meshphysical_vert,
                fragmentShader: Vo.meshphysical_frag
            },
            points: {
                uniforms: jo.merge([Ho.points, Ho.fog]),
                vertexShader: Vo.points_vert,
                fragmentShader: Vo.points_frag
            },
            dashed: {
                uniforms: jo.merge([Ho.common, Ho.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Vo.linedashed_vert,
                fragmentShader: Vo.linedashed_frag
            },
            depth: {
                uniforms: jo.merge([Ho.common, Ho.displacementmap]),
                vertexShader: Vo.depth_vert,
                fragmentShader: Vo.depth_frag
            },
            normal: {
                uniforms: jo.merge([Ho.common, Ho.bumpmap, Ho.normalmap, Ho.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Vo.normal_vert,
                fragmentShader: Vo.normal_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: Vo.cube_vert,
                fragmentShader: Vo.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: Vo.equirect_vert,
                fragmentShader: Vo.equirect_frag
            },
            distanceRGBA: {
                uniforms: jo.merge([Ho.common, Ho.displacementmap, {
                    referencePosition: {
                        value: new c
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: Vo.distanceRGBA_vert,
                fragmentShader: Vo.distanceRGBA_frag
            },
            shadow: {
                uniforms: jo.merge([Ho.lights, {
                    color: {
                        value: new Y(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Vo.shadow_vert,
                fragmentShader: Vo.shadow_frag
            }
        };
    Wo.physical = {
        uniforms: jo.merge([Wo.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: Vo.meshphysical_vert,
        fragmentShader: Vo.meshphysical_frag
    }, Object.assign(Z.prototype, {
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new r;
            return function(e, i) {
                var n = t.copy(i).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(t) {
            var e = t || new r;
            return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            var e = t || new r;
            return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        },
        getParameter: function(t, e) {
            return (e || new r).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        },
        clampPoint: function(t, e) {
            return (e || new r).copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new r;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }), Q.prototype = Object.create(s.prototype), Q.prototype.constructor = Q;
    var Xo = 0;
    Object.assign(K.prototype, n.prototype, {
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var i = t[e];
                    if (void 0 !== i)
                        if ("shading" !== e) {
                            var n = this[e];
                            void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = "overdraw" === e ? Number(i) : i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === Ps;
                    else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
        },
        toJSON: function(t) {
            function e(t) {
                var e = [];
                for (var i in t) {
                    var n = t[i];
                    delete n.metadata, e.push(n)
                }
                return e
            }
            var i = void 0 === t;
            i && (t = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Ds && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== Es && (n.side = this.side), this.vertexColors !== Cs && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i) {
                var r = e(t.textures),
                    s = e(t.images);
                r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s)
            }
            return n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
            var e = t.clippingPlanes,
                i = null;
            if (null !== e) {
                var n = e.length;
                i = new Array(n);
                for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
            }
            return this.clippingPlanes = i, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), tt.prototype = Object.create(K.prototype), tt.prototype.constructor = tt, tt.prototype.isShaderMaterial = !0, tt.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = jo.clone(t.uniforms), this.defines = t.defines, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
    }, tt.prototype.toJSON = function(t) {
        var e = K.prototype.toJSON.call(this, t);
        return e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
    }, et.prototype = Object.create(K.prototype), et.prototype.constructor = et, et.prototype.isMeshDepthMaterial = !0, et.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }, it.prototype = Object.create(K.prototype), it.prototype.constructor = it, it.prototype.isMeshDistanceMaterial = !0, it.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    }, Object.assign(nt.prototype, {
        isBox3: !0,
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromArray: function(t) {
            for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, h = t.length; o < h; o += 3) {
                var l = t[o],
                    c = t[o + 1],
                    u = t[o + 2];
                l < e && (e = l), c < i && (i = c), u < n && (n = u), l > r && (r = l), c > s && (s = c), u > a && (a = u)
            }
            return this.min.set(e, i, n), this.max.set(r, s, a), this
        },
        setFromBufferAttribute: function(t) {
            for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, h = t.count; o < h; o++) {
                var l = t.getX(o),
                    c = t.getY(o),
                    u = t.getZ(o);
                l < e && (e = l), c < i && (i = c), u < n && (n = u), l > r && (r = l), c > s && (s = c), u > a && (a = u)
            }
            return this.min.set(e, i, n), this.max.set(r, s, a), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new c;
            return function(e, i) {
                var n = t.copy(i).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
        }(),
        setFromObject: function(t) {
            return this.makeEmpty(), this.expandByObject(t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(t) {
            var e = t || new c;
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            var e = t || new c;
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        expandByObject: function() {
            var t = new c;
            return function(e) {
                var i = this;
                return e.updateMatrixWorld(!0), e.traverse(function(e) {
                    var n, r, s = e.geometry;
                    if (void 0 !== s)
                        if (s.isGeometry) {
                            var a = s.vertices;
                            for (n = 0, r = a.length; n < r; n++) t.copy(a[n]), t.applyMatrix4(e.matrixWorld), i.expandByPoint(t)
                        } else if (s.isBufferGeometry) {
                        var o = s.attributes.position;
                        if (void 0 !== o)
                            for (n = 0, r = o.count; n < r; n++) t.fromBufferAttribute(o, n).applyMatrix4(e.matrixWorld), i.expandByPoint(t)
                    }
                }), this
            }
        }(),
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function(t, e) {
            return (e || new c).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: function() {
            var t = new c;
            return function(e) {
                return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
            }
        }(),
        intersectsPlane: function(t) {
            var e, i;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= t.constant && i >= t.constant
        },
        clampPoint: function(t, e) {
            return (e || new c).copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new c;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        getBoundingSphere: function() {
            var t = new c;
            return function(e) {
                var i = e || new rt;
                return this.getCenter(i.center), i.radius = .5 * this.getSize(t).length(), i
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        applyMatrix4: function() {
            var t = [new c, new c, new c, new c, new c, new c, new c, new c];
            return function(e) {
                return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
            }
        }(),
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }), Object.assign(rt.prototype, {
        set: function(t, e) {
            return this.center.copy(t), this.radius = e, this
        },
        setFromPoints: function() {
            var t = new nt;
            return function(e, i) {
                var n = this.center;
                void 0 !== i ? n.copy(i) : t.setFromPoints(e).getCenter(n);
                for (var r = 0, s = 0, a = e.length; s < a; s++) r = Math.max(r, n.distanceToSquared(e[s]));
                return this.radius = Math.sqrt(r), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function(t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(t, e) {
            var i = this.center.distanceToSquared(t),
                n = e || new c;
            return n.copy(t), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
        },
        getBoundingBox: function(t) {
            var e = t || new nt;
            return e.set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
        },
        translate: function(t) {
            return this.center.add(t), this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    }), Object.assign(st.prototype, {
        isMatrix3: !0,
        set: function(t, e, i, n, r, s, a, o, h) {
            var l = this.elements;
            return l[0] = t, l[1] = n, l[2] = a, l[3] = e, l[4] = r, l[5] = o, l[6] = i, l[7] = s, l[8] = h, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements,
                i = t.elements;
            return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
        },
        setFromMatrix4: function(t) {
            var e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        applyToBufferAttribute: function() {
            var t = new c;
            return function(e) {
                for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
                return e
            }
        }(),
        multiply: function(t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var i = t.elements,
                n = e.elements,
                r = this.elements,
                s = i[0],
                a = i[3],
                o = i[6],
                h = i[1],
                l = i[4],
                c = i[7],
                u = i[2],
                d = i[5],
                p = i[8],
                f = n[0],
                m = n[3],
                v = n[6],
                g = n[1],
                y = n[4],
                _ = n[7],
                x = n[2],
                b = n[5],
                w = n[8];
            return r[0] = s * f + a * g + o * x, r[3] = s * m + a * y + o * b, r[6] = s * v + a * _ + o * w, r[1] = h * f + l * g + c * x, r[4] = h * m + l * y + c * b, r[7] = h * v + l * _ + c * w, r[2] = u * f + d * g + p * x, r[5] = u * m + d * y + p * b, r[8] = u * v + d * _ + p * w, this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        },
        determinant: function() {
            var t = this.elements,
                e = t[0],
                i = t[1],
                n = t[2],
                r = t[3],
                s = t[4],
                a = t[5],
                o = t[6],
                h = t[7],
                l = t[8];
            return e * s * l - e * a * h - i * r * l + i * a * o + n * r * h - n * s * o
        },
        getInverse: function(t, e) {
            t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var i = t.elements,
                n = this.elements,
                r = i[0],
                s = i[1],
                a = i[2],
                o = i[3],
                h = i[4],
                l = i[5],
                c = i[6],
                u = i[7],
                d = i[8],
                p = d * h - l * u,
                f = l * c - d * o,
                m = u * o - h * c,
                v = r * p + s * f + a * m;
            if (0 === v) {
                var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === e) throw new Error(g);
                return console.warn(g), this.identity()
            }
            var y = 1 / v;
            return n[0] = p * y, n[1] = (a * u - d * s) * y, n[2] = (l * s - a * h) * y, n[3] = f * y, n[4] = (d * r - a * c) * y, n[5] = (a * o - l * r) * y, n[6] = m * y, n[7] = (s * c - u * r) * y, n[8] = (h * r - s * o) * y, this
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        getNormalMatrix: function(t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        },
        equals: function(t) {
            for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
                if (e[n] !== i[n]) return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var i = this.elements;
            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
        }
    }), Object.assign(at.prototype, {
        set: function(t, e) {
            return this.normal.copy(t), this.constant = e, this
        },
        setComponents: function(t, e, i, n) {
            return this.normal.set(t, e, i), this.constant = n, this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var t = new c,
                e = new c;
            return function(i, n, r) {
                var s = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize();
                return this.setFromNormalAndCoplanarPoint(s, i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        },
        normalize: function() {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return (e || new c).copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: function() {
            var t = new c;
            return function(e, i) {
                var n = i || new c,
                    r = e.delta(t),
                    s = this.normal.dot(r);
                if (0 !== s) {
                    var a = -(e.start.dot(this.normal) + this.constant) / s;
                    if (!(a < 0 || a > 1)) return n.copy(r).multiplyScalar(a).add(e.start)
                } else if (0 === this.distanceToPoint(e.start)) return n.copy(e.start)
            }
        }(),
        intersectsLine: function(t) {
            var e = this.distanceToPoint(t.start),
                i = this.distanceToPoint(t.end);
            return e < 0 && i > 0 || i < 0 && e > 0
        },
        intersectsBox: function(t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function(t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function(t) {
            return (t || new c).copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var t = new c,
                e = new st;
            return function(i, n) {
                var r = n || e.getNormalMatrix(i),
                    s = this.coplanarPoint(t).applyMatrix4(i),
                    a = this.normal.applyMatrix3(r).normalize();
                return this.constant = -s.dot(a), this
            }
        }(),
        translate: function(t) {
            return this.constant -= t.dot(this.normal), this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    }), Object.assign(ot.prototype, {
        set: function(t, e, i, n, r, s) {
            var a = this.planes;
            return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(s), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes,
                i = t.elements,
                n = i[0],
                r = i[1],
                s = i[2],
                a = i[3],
                o = i[4],
                h = i[5],
                l = i[6],
                c = i[7],
                u = i[8],
                d = i[9],
                p = i[10],
                f = i[11],
                m = i[12],
                v = i[13],
                g = i[14],
                y = i[15];
            return e[0].setComponents(a - n, c - o, f - u, y - m).normalize(), e[1].setComponents(a + n, c + o, f + u, y + m).normalize(), e[2].setComponents(a + r, c + h, f + d, y + v).normalize(), e[3].setComponents(a - r, c - h, f - d, y - v).normalize(), e[4].setComponents(a - s, c - l, f - p, y - g).normalize(), e[5].setComponents(a + s, c + l, f + p, y + g).normalize(), this
        },
        intersectsObject: function() {
            var t = new rt;
            return function(e) {
                var i = e.geometry;
                return null === i.boundingSphere && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
            }
        }(),
        intersectsSprite: function() {
            var t = new rt;
            return function(e) {
                return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
            }
        }(),
        intersectsSphere: function(t) {
            for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
                if (e[r].distanceToPoint(i) < n) return !1
            }
            return !0
        },
        intersectsBox: function() {
            var t = new c,
                e = new c;
            return function(i) {
                for (var n = this.planes, r = 0; r < 6; r++) {
                    var s = n[r];
                    t.x = s.normal.x > 0 ? i.min.x : i.max.x, e.x = s.normal.x > 0 ? i.max.x : i.min.x, t.y = s.normal.y > 0 ? i.min.y : i.max.y, e.y = s.normal.y > 0 ? i.max.y : i.min.y, t.z = s.normal.z > 0 ? i.min.z : i.max.z, e.z = s.normal.z > 0 ? i.max.z : i.min.z;
                    var a = s.distanceToPoint(t),
                        o = s.distanceToPoint(e);
                    if (a < 0 && o < 0) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(t) {
            for (var e = this.planes, i = 0; i < 6; i++)
                if (e[i].distanceToPoint(t) < 0) return !1;
            return !0
        }
    }), ct.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], ct.DefaultOrder = "XYZ", Object.defineProperties(ct.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t, this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(t) {
                this._order = t, this.onChangeCallback()
            }
        }
    }), Object.assign(ct.prototype, {
        isEuler: !0,
        set: function(t, e, i, n) {
            return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t, e, i) {
            var n = Oo.clamp,
                r = t.elements,
                s = r[0],
                a = r[4],
                o = r[8],
                h = r[1],
                l = r[5],
                c = r[9],
                u = r[2],
                d = r[6],
                p = r[10];
            return e = e || this._order, "XYZ" === e ? (this._y = Math.asin(n(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(-c, p), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(d, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(c, -1, 1)), Math.abs(c) < .99999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-u, s), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(h, s))) : "ZYX" === e ? (this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(h, s)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === e ? (this._z = Math.asin(n(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, s)) : (this._x = 0, this._y = Math.atan2(o, p))) : "XZY" === e ? (this._z = Math.asin(-n(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-c, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
        },
        setFromQuaternion: function() {
            var t = new u;
            return function(e, i, n) {
                return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n)
            }
        }(),
        setFromVector3: function(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: function() {
            var t = new l;
            return function(e) {
                return t.setFromEuler(this), this.setFromQuaternion(t, e)
            }
        }(),
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
        },
        toVector3: function(t) {
            return t ? t.set(this._x, this._y, this._z) : new c(this._x, this._y, this._z)
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {}
    }), Object.assign(ut.prototype, {
        set: function(t) {
            this.mask = 1 << t | 0
        },
        enable: function(t) {
            this.mask |= 1 << t | 0
        },
        toggle: function(t) {
            this.mask ^= 1 << t | 0
        },
        disable: function(t) {
            this.mask &= ~(1 << t | 0)
        },
        test: function(t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var qo = 0;
    dt.DefaultUp = new c(0, 1, 0), dt.DefaultMatrixAutoUpdate = !0, Object.assign(dt.prototype, n.prototype, {
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(t) {
            this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(t) {
            return this.quaternion.premultiply(t), this
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function() {
            var t = new l;
            return function(e, i) {
                return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this
            }
        }(),
        rotateX: function() {
            var t = new c(1, 0, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateY: function() {
            var t = new c(0, 1, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateZ: function() {
            var t = new c(0, 0, 1);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        translateOnAxis: function() {
            var t = new c;
            return function(e, i) {
                return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this
            }
        }(),
        translateX: function() {
            var t = new c(1, 0, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateY: function() {
            var t = new c(0, 1, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateZ: function() {
            var t = new c(0, 0, 1);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var t = new u;
            return function(e) {
                return e.applyMatrix4(t.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var t = new u;
            return function(e) {
                this.isCamera ? t.lookAt(this.position, e, this.up) : t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t)
            }
        }(),
        add: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                type: "added"
            }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
        },
        remove: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                return this
            }
            var i = this.children.indexOf(t);
            return -1 !== i && (t.parent = null, t.dispatchEvent({
                type: "removed"
            }), this.children.splice(i, 1)), this
        },
        getObjectById: function(t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e) return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i],
                    s = r.getObjectByProperty(t, e);
                if (void 0 !== s) return s
            }
        },
        getWorldPosition: function(t) {
            var e = t || new c;
            return this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var t = new c,
                e = new c;
            return function(i) {
                var n = i || new l;
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, n, e), n
            }
        }(),
        getWorldRotation: function() {
            var t = new l;
            return function(e) {
                var i = e || new ct;
                return this.getWorldQuaternion(t), i.setFromQuaternion(t, this.rotation.order, !1)
            }
        }(),
        getWorldScale: function() {
            var t = new c,
                e = new l;
            return function(i) {
                var n = i || new c;
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n
            }
        }(),
        getWorldDirection: function() {
            var t = new l;
            return function(e) {
                var i = e || new c;
                return this.getWorldQuaternion(t), i.set(0, 0, 1).applyQuaternion(t)
            }
        }(),
        raycast: function() {},
        traverse: function(t) {
            t(this);
            for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
            }
        },
        traverseAncestors: function(t) {
            var e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
        },
        toJSON: function(t) {
            function e(e, i) {
                return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
            }

            function i(t) {
                var e = [];
                for (var i in t) {
                    var n = t[i];
                    delete n.metadata, e.push(n)
                }
                return e
            }
            var n = void 0 === t || "" === t,
                r = {};
            n && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            }, r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var s = {};
            if (s.uuid = this.uuid, s.type = this.type, "" !== this.name && (s.name = this.name), !0 === this.castShadow && (s.castShadow = !0), !0 === this.receiveShadow && (s.receiveShadow = !0), !1 === this.visible && (s.visible = !1), "{}" !== JSON.stringify(this.userData) && (s.userData = this.userData), s.matrix = this.matrix.toArray(), void 0 !== this.geometry && (s.geometry = e(t.geometries, this.geometry)), void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (var a = [], o = 0, h = this.material.length; o < h; o++) a.push(e(t.materials, this.material[o]));
                    s.material = a
                } else s.material = e(t.materials, this.material);
            if (this.children.length > 0) {
                s.children = [];
                for (var o = 0; o < this.children.length; o++) s.children.push(this.children[o].toJSON(t).object)
            }
            if (n) {
                var l = i(t.geometries),
                    c = i(t.materials),
                    u = i(t.textures),
                    d = i(t.images);
                l.length > 0 && (r.geometries = l), c.length > 0 && (r.materials = c), u.length > 0 && (r.textures = u), d.length > 0 && (r.images = d)
            }
            return r.object = s, r
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e) {
            if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                for (var i = 0; i < t.children.length; i++) {
                    var n = t.children[i];
                    this.add(n.clone())
                }
            return this
        }
    }), pt.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: pt,
        isCamera: !0,
        copy: function(t, e) {
            return dt.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
        },
        getWorldDirection: function() {
            var t = new l;
            return function(e) {
                var i = e || new c;
                return this.getWorldQuaternion(t), i.set(0, 0, -1).applyQuaternion(t)
            }
        }(),
        updateMatrixWorld: function(t) {
            dt.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), ft.prototype = Object.assign(Object.create(pt.prototype), {
        constructor: ft,
        isOrthographicCamera: !0,
        copy: function(t, e) {
            return pt.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
        },
        setViewOffset: function(t, e, i, n, r, s) {
            this.view = {
                fullWidth: t,
                fullHeight: e,
                offsetX: i,
                offsetY: n,
                width: r,
                height: s
            }, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            this.view = null, this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = (this.right - this.left) / (2 * this.zoom),
                e = (this.top - this.bottom) / (2 * this.zoom),
                i = (this.right + this.left) / 2,
                n = (this.top + this.bottom) / 2,
                r = i - t,
                s = i + t,
                a = n + e,
                o = n - e;
            if (null !== this.view) {
                var h = this.zoom / (this.view.width / this.view.fullWidth),
                    l = this.zoom / (this.view.height / this.view.fullHeight),
                    c = (this.right - this.left) / this.view.width,
                    u = (this.top - this.bottom) / this.view.height;
                r += c * (this.view.offsetX / h), s = r + c * (this.view.width / h), a -= u * (this.view.offsetY / l), o = a - u * (this.view.height / l)
            }
            this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far)
        },
        toJSON: function(t) {
            var e = dt.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }), mt.prototype = Object.assign(Object.create(pt.prototype), {
        constructor: mt,
        isPerspectiveCamera: !0,
        copy: function(t, e) {
            return pt.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
        },
        setFocalLength: function(t) {
            var e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * Oo.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var t = Math.tan(.5 * Oo.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * Oo.RAD2DEG * Math.atan(Math.tan(.5 * Oo.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, i, n, r, s) {
            this.aspect = t / e, this.view = {
                fullWidth: t,
                fullHeight: e,
                offsetX: i,
                offsetY: n,
                width: r,
                height: s
            }, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            this.view = null, this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = this.near,
                e = t * Math.tan(.5 * Oo.DEG2RAD * this.fov) / this.zoom,
                i = 2 * e,
                n = this.aspect * i,
                r = -.5 * n,
                s = this.view;
            if (null !== s) {
                var a = s.fullWidth,
                    o = s.fullHeight;
                r += s.offsetX * n / a, e -= s.offsetY * i / o, n *= s.width / a, i *= s.height / o
            }
            var h = this.filmOffset;
            0 !== h && (r += t * h / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far)
        },
        toJSON: function(t) {
            var e = dt.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    }), Object.assign(vt.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
            for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (var e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    });
    var Yo = 0;
    Object.assign(yt.prototype, n.prototype, {
        isGeometry: !0,
        applyMatrix: function(t) {
            for (var e = (new st).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) {
                this.vertices[i].applyMatrix4(t)
            }
            for (var i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i];
                r.normal.applyMatrix3(e).normalize();
                for (var s = 0, a = r.vertexNormals.length; s < a; s++) r.vertexNormals[s].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function() {
            var t = new u;
            return function(e) {
                return t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(),
        rotateY: function() {
            var t = new u;
            return function(e) {
                return t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(),
        rotateZ: function() {
            var t = new u;
            return function(e) {
                return t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(),
        translate: function() {
            var t = new u;
            return function(e, i, n) {
                return t.makeTranslation(e, i, n), this.applyMatrix(t), this
            }
        }(),
        scale: function() {
            var t = new u;
            return function(e, i, n) {
                return t.makeScale(e, i, n), this.applyMatrix(t), this
            }
        }(),
        lookAt: function() {
            var t = new dt;
            return function(e) {
                t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
            }
        }(),
        fromBufferGeometry: function(t) {
            function e(t, e, n, r) {
                var s = void 0 !== o ? [d[t].clone(), d[e].clone(), d[n].clone()] : [],
                    a = void 0 !== h ? [i.colors[t].clone(), i.colors[e].clone(), i.colors[n].clone()] : [],
                    c = new vt(t, e, n, s, a, r);
                i.faces.push(c), void 0 !== l && i.faceVertexUvs[0].push([p[t].clone(), p[e].clone(), p[n].clone()]), void 0 !== u && i.faceVertexUvs[1].push([f[t].clone(), f[e].clone(), f[n].clone()])
            }
            var i = this,
                n = null !== t.index ? t.index.array : void 0,
                s = t.attributes,
                a = s.position.array,
                o = void 0 !== s.normal ? s.normal.array : void 0,
                h = void 0 !== s.color ? s.color.array : void 0,
                l = void 0 !== s.uv ? s.uv.array : void 0,
                u = void 0 !== s.uv2 ? s.uv2.array : void 0;
            void 0 !== u && (this.faceVertexUvs[1] = []);
            for (var d = [], p = [], f = [], m = 0, v = 0; m < a.length; m += 3, v += 2) i.vertices.push(new c(a[m], a[m + 1], a[m + 2])), void 0 !== o && d.push(new c(o[m], o[m + 1], o[m + 2])), void 0 !== h && i.colors.push(new Y(h[m], h[m + 1], h[m + 2])), void 0 !== l && p.push(new r(l[v], l[v + 1])), void 0 !== u && f.push(new r(u[v], u[v + 1]));
            var g = t.groups;
            if (g.length > 0)
                for (var m = 0; m < g.length; m++)
                    for (var y = g[m], _ = y.start, x = y.count, v = _, b = _ + x; v < b; v += 3) void 0 !== n ? e(n[v], n[v + 1], n[v + 2], y.materialIndex) : e(v, v + 1, v + 2, y.materialIndex);
            else if (void 0 !== n)
                for (var m = 0; m < n.length; m += 3) e(n[m], n[m + 1], n[m + 2]);
            else
                for (var m = 0; m < a.length / 3; m += 3) e(m, m + 1, m + 2);
            return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
        },
        center: function() {
            this.computeBoundingBox();
            var t = this.boundingBox.getCenter().negate();
            return this.translate(t.x, t.y, t.z), t
        },
        normalize: function() {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center,
                e = this.boundingSphere.radius,
                i = 0 === e ? 1 : 1 / e,
                n = new u;
            return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(n), this
        },
        computeFaceNormals: function() {
            for (var t = new c, e = new c, i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i],
                    s = this.vertices[r.a],
                    a = this.vertices[r.b],
                    o = this.vertices[r.c];
                t.subVectors(o, a), e.subVectors(s, a), t.cross(e), t.normalize(), r.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            void 0 === t && (t = !0);
            var e, i, n, r, s, a;
            for (a = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) a[e] = new c;
            if (t) {
                var o, h, l, u = new c,
                    d = new c;
                for (n = 0, r = this.faces.length; n < r; n++) s = this.faces[n], o = this.vertices[s.a], h = this.vertices[s.b], l = this.vertices[s.c], u.subVectors(l, h), d.subVectors(o, h), u.cross(d), a[s.a].add(u), a[s.b].add(u), a[s.c].add(u)
            } else
                for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) s = this.faces[n], a[s.a].add(s.normal), a[s.b].add(s.normal), a[s.c].add(s.normal);
            for (e = 0, i = this.vertices.length; e < i; e++) a[e].normalize();
            for (n = 0, r = this.faces.length; n < r; n++) {
                s = this.faces[n];
                var p = s.vertexNormals;
                3 === p.length ? (p[0].copy(a[s.a]), p[1].copy(a[s.b]), p[2].copy(a[s.c])) : (p[0] = a[s.a].clone(), p[1] = a[s.b].clone(), p[2] = a[s.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var t, e, i;
            for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                i = this.faces[t];
                var n = i.vertexNormals;
                3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var t, e, i, n, r;
            for (i = 0, n = this.faces.length; i < n; i++)
                for (r = this.faces[i], r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
            var s = new yt;
            for (s.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                    var a, o, h = this.morphNormals[t].faceNormals,
                        l = this.morphNormals[t].vertexNormals;
                    for (i = 0, n = this.faces.length; i < n; i++) a = new c, o = {
                        a: new c,
                        b: new c,
                        c: new c
                    }, h.push(a), l.push(o)
                }
                var u = this.morphNormals[t];
                s.vertices = this.morphTargets[t].vertices, s.computeFaceNormals(), s.computeVertexNormals();
                var a, o;
                for (i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], a = u.faceNormals[i], o = u.vertexNormals[i], a.copy(r.normal), o.a.copy(r.vertexNormals[0]), o.b.copy(r.vertexNormals[1]), o.c.copy(r.vertexNormals[2])
            }
            for (i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
        },
        computeLineDistances: function() {
            for (var t = 0, e = this.vertices, i = 0, n = e.length; i < n; i++) i > 0 && (t += e[i].distanceTo(e[i - 1])), this.lineDistances[i] = t
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new nt), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new rt), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, i) {
            if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
            var n, r = this.vertices.length,
                s = this.vertices,
                a = t.vertices,
                o = this.faces,
                h = t.faces,
                l = this.faceVertexUvs[0],
                c = t.faceVertexUvs[0],
                u = this.colors,
                d = t.colors;
            void 0 === i && (i = 0), void 0 !== e && (n = (new st).getNormalMatrix(e));
            for (var p = 0, f = a.length; p < f; p++) {
                var m = a[p],
                    v = m.clone();
                void 0 !== e && v.applyMatrix4(e), s.push(v)
            }
            for (var p = 0, f = d.length; p < f; p++) u.push(d[p].clone());
            for (p = 0, f = h.length; p < f; p++) {
                var g, y, _, x = h[p],
                    b = x.vertexNormals,
                    w = x.vertexColors;
                g = new vt(x.a + r, x.b + r, x.c + r), g.normal.copy(x.normal), void 0 !== n && g.normal.applyMatrix3(n).normalize();
                for (var T = 0, M = b.length; T < M; T++) y = b[T].clone(), void 0 !== n && y.applyMatrix3(n).normalize(), g.vertexNormals.push(y);
                g.color.copy(x.color);
                for (var T = 0, M = w.length; T < M; T++) _ = w[T], g.vertexColors.push(_.clone());
                g.materialIndex = x.materialIndex + i, o.push(g)
            }
            for (p = 0, f = c.length; p < f; p++) {
                var E = c[p],
                    S = [];
                if (void 0 !== E) {
                    for (var T = 0, M = E.length; T < M; T++) S.push(E[T].clone());
                    l.push(S)
                }
            }
        },
        mergeMesh: function(t) {
            if (!t || !t.isMesh) return void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t);
            t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)
        },
        mergeVertices: function() {
            var t, e, i, n, r, s, a, o, h = {},
                l = [],
                c = [],
                u = Math.pow(10, 4);
            for (i = 0, n = this.vertices.length; i < n; i++) t = this.vertices[i], e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u), void 0 === h[e] ? (h[e] = i, l.push(this.vertices[i]), c[i] = l.length - 1) : c[i] = c[h[e]];
            var d = [];
            for (i = 0, n = this.faces.length; i < n; i++) {
                r = this.faces[i], r.a = c[r.a], r.b = c[r.b], r.c = c[r.c], s = [r.a, r.b, r.c];
                for (var p = 0; p < 3; p++)
                    if (s[p] === s[(p + 1) % 3]) {
                        d.push(i);
                        break
                    }
            }
            for (i = d.length - 1; i >= 0; i--) {
                var f = d[i];
                for (this.faces.splice(f, 1), a = 0, o = this.faceVertexUvs.length; a < o; a++) this.faceVertexUvs[a].splice(f, 1)
            }
            var m = this.vertices.length - l.length;
            return this.vertices = l, m
        },
        sortFacesByMaterialIndex: function() {
            function t(t, e) {
                return t.materialIndex - e.materialIndex
            }
            for (var e = this.faces, i = e.length, n = 0; n < i; n++) e[n]._id = n;
            e.sort(t);
            var r, s, a = this.faceVertexUvs[0],
                o = this.faceVertexUvs[1];
            a && a.length === i && (r = []), o && o.length === i && (s = []);
            for (var n = 0; n < i; n++) {
                var h = e[n]._id;
                r && r.push(a[h]), s && s.push(o[h])
            }
            r && (this.faceVertexUvs[0] = r), s && (this.faceVertexUvs[1] = s)
        },
        toJSON: function() {
            function t(t, e, i) {
                return i ? t | 1 << e : t & ~(1 << e)
            }

            function e(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== d[e] ? d[e] : (d[e] = u.length / 3, u.push(t.x, t.y, t.z), d[e])
            }

            function i(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== f[e] ? f[e] : (f[e] = p.length, p.push(t.getHex()), f[e])
            }

            function n(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== v[e] ? v[e] : (v[e] = m.length / 2, m.push(t.x, t.y), v[e])
            }
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                var s = this.parameters;
                for (var a in s) void 0 !== s[a] && (r[a] = s[a]);
                return r
            }
            for (var o = [], h = 0; h < this.vertices.length; h++) {
                var l = this.vertices[h];
                o.push(l.x, l.y, l.z)
            }
            for (var c = [], u = [], d = {}, p = [], f = {}, m = [], v = {}, h = 0; h < this.faces.length; h++) {
                var g = this.faces[h],
                    y = void 0 !== this.faceVertexUvs[0][h],
                    _ = g.normal.length() > 0,
                    x = g.vertexNormals.length > 0,
                    b = 1 !== g.color.r || 1 !== g.color.g || 1 !== g.color.b,
                    w = g.vertexColors.length > 0,
                    T = 0;
                if (T = t(T, 0, 0), T = t(T, 1, !0), T = t(T, 2, !1), T = t(T, 3, y), T = t(T, 4, _), T = t(T, 5, x), T = t(T, 6, b), T = t(T, 7, w), c.push(T), c.push(g.a, g.b, g.c), c.push(g.materialIndex), y) {
                    var M = this.faceVertexUvs[0][h];
                    c.push(n(M[0]), n(M[1]), n(M[2]))
                }
                if (_ && c.push(e(g.normal)), x) {
                    var E = g.vertexNormals;
                    c.push(e(E[0]), e(E[1]), e(E[2]))
                }
                if (b && c.push(i(g.color)), w) {
                    var S = g.vertexColors;
                    c.push(i(S[0]), i(S[1]), i(S[2]))
                }
            }
            return r.data = {}, r.data.vertices = o, r.data.normals = u, p.length > 0 && (r.data.colors = p), m.length > 0 && (r.data.uvs = [m]), r.data.faces = c, r
        },
        clone: function() {
            return (new yt).copy(this)
        },
        copy: function(t) {
            var e, i, n, r, s, a;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var o = t.vertices;
            for (e = 0, i = o.length; e < i; e++) this.vertices.push(o[e].clone());
            var h = t.colors;
            for (e = 0, i = h.length; e < i; e++) this.colors.push(h[e].clone());
            var l = t.faces;
            for (e = 0, i = l.length; e < i; e++) this.faces.push(l[e].clone());
            for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
                var c = t.faceVertexUvs[e];
                for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0, r = c.length; n < r; n++) {
                    var u = c[n],
                        d = [];
                    for (s = 0, a = u.length; s < a; s++) {
                        var p = u[s];
                        d.push(p.clone())
                    }
                    this.faceVertexUvs[e].push(d)
                }
            }
            var f = t.morphTargets;
            for (e = 0, i = f.length; e < i; e++) {
                var m = {};
                if (m.name = f[e].name, void 0 !== f[e].vertices)
                    for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m.vertices.push(f[e].vertices[n].clone());
                if (void 0 !== f[e].normals)
                    for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m.normals.push(f[e].normals[n].clone());
                this.morphTargets.push(m)
            }
            var v = t.morphNormals;
            for (e = 0, i = v.length; e < i; e++) {
                var g = {};
                if (void 0 !== v[e].vertexNormals)
                    for (g.vertexNormals = [], n = 0, r = v[e].vertexNormals.length; n < r; n++) {
                        var y = v[e].vertexNormals[n],
                            _ = {};
                        _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), g.vertexNormals.push(_)
                    }
                if (void 0 !== v[e].faceNormals)
                    for (g.faceNormals = [], n = 0, r = v[e].faceNormals.length; n < r; n++) g.faceNormals.push(v[e].faceNormals[n].clone());
                this.morphNormals.push(g)
            }
            var x = t.skinWeights;
            for (e = 0, i = x.length; e < i; e++) this.skinWeights.push(x[e].clone());
            var b = t.skinIndices;
            for (e = 0, i = b.length; e < i; e++) this.skinIndices.push(b[e].clone());
            var w = t.lineDistances;
            for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
            var T = t.boundingBox;
            null !== T && (this.boundingBox = T.clone());
            var M = t.boundingSphere;
            return null !== M && (this.boundingSphere = M.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(_t.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(_t.prototype, {
        isBufferAttribute: !0,
        setArray: function(t) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t
        },
        setDynamic: function(t) {
            return this.dynamic = t, this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
        },
        copyAt: function(t, e, i) {
            t *= this.itemSize, i *= e.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t), this
        },
        copyColorsArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var s = t[n];
                void 0 === s && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), s = new Y), e[i++] = s.r, e[i++] = s.g, e[i++] = s.b
            }
            return this
        },
        copyIndicesArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var s = t[n];
                e[i++] = s.a, e[i++] = s.b, e[i++] = s.c
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array, i = 0, n = 0, s = t.length; n < s; n++) {
                var a = t[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), a = new r), e[i++] = a.x, e[i++] = a.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var s = t[n];
                void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), s = new c), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var s = t[n];
                void 0 === s && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), s = new a), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z, e[i++] = s.w
            }
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e, this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e, this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e, this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e, this
        },
        setXY: function(t, e, i) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
        },
        setXYZ: function(t, e, i, n) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
        },
        setXYZW: function(t, e, i, n, r) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t, this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
    }), xt.prototype = Object.create(_t.prototype), xt.prototype.constructor = xt, bt.prototype = Object.create(_t.prototype), bt.prototype.constructor = bt, wt.prototype = Object.create(_t.prototype), wt.prototype.constructor = wt, Tt.prototype = Object.create(_t.prototype), Tt.prototype.constructor = Tt, Mt.prototype = Object.create(_t.prototype), Mt.prototype.constructor = Mt, Et.prototype = Object.create(_t.prototype), Et.prototype.constructor = Et, St.prototype = Object.create(_t.prototype), St.prototype.constructor = St, At.prototype = Object.create(_t.prototype), At.prototype.constructor = At, Pt.prototype = Object.create(_t.prototype), Pt.prototype.constructor = Pt, Object.assign(Rt.prototype, {
        computeGroups: function(t) {
            for (var e, i = [], n = void 0, r = t.faces, s = 0; s < r.length; s++) {
                var a = r[s];
                a.materialIndex !== n && (n = a.materialIndex, void 0 !== e && (e.count = 3 * s - e.start, i.push(e)), e = {
                    start: 3 * s,
                    materialIndex: n
                })
            }
            void 0 !== e && (e.count = 3 * s - e.start, i.push(e)), this.groups = i
        },
        fromGeometry: function(t) {
            var e, i = t.faces,
                n = t.vertices,
                s = t.faceVertexUvs,
                a = s[0] && s[0].length > 0,
                o = s[1] && s[1].length > 0,
                h = t.morphTargets,
                l = h.length;
            if (l > 0) {
                e = [];
                for (var c = 0; c < l; c++) e[c] = [];
                this.morphTargets.position = e
            }
            var u, d = t.morphNormals,
                p = d.length;
            if (p > 0) {
                u = [];
                for (var c = 0; c < p; c++) u[c] = [];
                this.morphTargets.normal = u
            }
            for (var f = t.skinIndices, m = t.skinWeights, v = f.length === n.length, g = m.length === n.length, c = 0; c < i.length; c++) {
                var y = i[c];
                this.vertices.push(n[y.a], n[y.b], n[y.c]);
                var _ = y.vertexNormals;
                if (3 === _.length) this.normals.push(_[0], _[1], _[2]);
                else {
                    var x = y.normal;
                    this.normals.push(x, x, x)
                }
                var b = y.vertexColors;
                if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                else {
                    var w = y.color;
                    this.colors.push(w, w, w)
                }
                if (!0 === a) {
                    var T = s[0][c];
                    void 0 !== T ? this.uvs.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", c), this.uvs.push(new r, new r, new r))
                }
                if (!0 === o) {
                    var T = s[1][c];
                    void 0 !== T ? this.uvs2.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", c), this.uvs2.push(new r, new r, new r))
                }
                for (var M = 0; M < l; M++) {
                    var E = h[M].vertices;
                    e[M].push(E[y.a], E[y.b], E[y.c])
                }
                for (var M = 0; M < p; M++) {
                    var S = d[M].vertexNormals[c];
                    u[M].push(S.a, S.b, S.c)
                }
                v && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), g && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        }
    }), Lt.MaxIndex = 65535, Object.assign(Lt.prototype, n.prototype, {
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            Array.isArray(t) ? this.index = new(Ct(t) > 65535 ? St : Mt)(t, 1) : this.index = t
        },
        addAttribute: function(t, e) {
            return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(e)) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(t, new _t(arguments[1], arguments[2])))
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        removeAttribute: function(t) {
            return delete this.attributes[t], this
        },
        addGroup: function(t, e, i) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== i ? i : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t, this.drawRange.count = e
        },
        applyMatrix: function(t) {
            var e = this.attributes.position;
            void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
            var i = this.attributes.normal;
            if (void 0 !== i) {
                (new st).getNormalMatrix(t).applyToBufferAttribute(i), i.needsUpdate = !0
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function() {
            var t = new u;
            return function(e) {
                return t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(),
        rotateY: function() {
            var t = new u;
            return function(e) {
                return t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(),
        rotateZ: function() {
            var t = new u;
            return function(e) {
                return t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(),
        translate: function() {
            var t = new u;
            return function(e, i, n) {
                return t.makeTranslation(e, i, n), this.applyMatrix(t), this
            }
        }(),
        scale: function() {
            var t = new u;
            return function(e, i, n) {
                return t.makeScale(e, i, n), this.applyMatrix(t), this
            }
        }(),
        lookAt: function() {
            var t = new dt;
            return function(e) {
                t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
            }
        }(),
        center: function() {
            this.computeBoundingBox();
            var t = this.boundingBox.getCenter().negate();
            return this.translate(t.x, t.y, t.z), t
        },
        setFromObject: function(t) {
            var e = t.geometry;
            if (t.isPoints || t.isLine) {
                var i = new At(3 * e.vertices.length, 3),
                    n = new At(3 * e.colors.length, 3);
                if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this.addAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                    var r = new At(e.lineDistances.length, 1);
                    this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                }
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        updateFromObject: function(t) {
            var e = t.geometry;
            if (t.isMesh) {
                var i = e.__directGeometry;
                if (!0 === e.elementsNeedUpdate && (i = void 0, e.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(e);
                i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i
            }
            var n;
            return !0 === e.verticesNeedUpdate && (n = this.attributes.position, void 0 !== n && (n.copyVector3sArray(e.vertices), n.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (n = this.attributes.normal, void 0 !== n && (n.copyVector3sArray(e.normals), n.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (n = this.attributes.color, void 0 !== n && (n.copyColorsArray(e.colors), n.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (n = this.attributes.uv, void 0 !== n && (n.copyVector2sArray(e.uvs), n.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (n = this.attributes.lineDistance, void 0 !== n && (n.copyArray(e.lineDistances), n.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new Rt).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            var e = new Float32Array(3 * t.vertices.length);
            if (this.addAttribute("position", new _t(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                var i = new Float32Array(3 * t.normals.length);
                this.addAttribute("normal", new _t(i, 3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
                var n = new Float32Array(3 * t.colors.length);
                this.addAttribute("color", new _t(n, 3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
                var r = new Float32Array(2 * t.uvs.length);
                this.addAttribute("uv", new _t(r, 2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
                var s = new Float32Array(2 * t.uvs2.length);
                this.addAttribute("uv2", new _t(s, 2).copyVector2sArray(t.uvs2))
            }
            if (t.indices.length > 0) {
                var a = Ct(t.indices) > 65535 ? Uint32Array : Uint16Array,
                    o = new a(3 * t.indices.length);
                this.setIndex(new _t(o, 1).copyIndicesArray(t.indices))
            }
            this.groups = t.groups;
            for (var h in t.morphTargets) {
                for (var l = [], c = t.morphTargets[h], u = 0, d = c.length; u < d; u++) {
                    var p = c[u],
                        f = new At(3 * p.length, 3);
                    l.push(f.copyVector3sArray(p))
                }
                this.morphAttributes[h] = l
            }
            if (t.skinIndices.length > 0) {
                var m = new At(4 * t.skinIndices.length, 4);
                this.addAttribute("skinIndex", m.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
                var v = new At(4 * t.skinWeights.length, 4);
                this.addAttribute("skinWeight", v.copyVector4sArray(t.skinWeights))
            }
            return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new nt);
            var t = this.attributes.position;
            void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            var t = new nt,
                e = new c;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new rt);
                var i = this.attributes.position;
                if (i) {
                    var n = this.boundingSphere.center;
                    t.setFromBufferAttribute(i), t.getCenter(n);
                    for (var r = 0, s = 0, a = i.count; s < a; s++) e.x = i.getX(s), e.y = i.getY(s), e.z = i.getZ(s), r = Math.max(r, n.distanceToSquared(e));
                    this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var t = this.index,
                e = this.attributes,
                i = this.groups;
            if (e.position) {
                var n = e.position.array;
                if (void 0 === e.normal) this.addAttribute("normal", new _t(new Float32Array(n.length), 3));
                else
                    for (var r = e.normal.array, s = 0, a = r.length; s < a; s++) r[s] = 0;
                var o, h, l, u = e.normal.array,
                    d = new c,
                    p = new c,
                    f = new c,
                    m = new c,
                    v = new c;
                if (t) {
                    var g = t.array;
                    0 === i.length && this.addGroup(0, g.length);
                    for (var y = 0, _ = i.length; y < _; ++y)
                        for (var x = i[y], b = x.start, w = x.count, s = b, a = b + w; s < a; s += 3) o = 3 * g[s + 0], h = 3 * g[s + 1], l = 3 * g[s + 2], d.fromArray(n, o), p.fromArray(n, h), f.fromArray(n, l), m.subVectors(f, p), v.subVectors(d, p), m.cross(v), u[o] += m.x, u[o + 1] += m.y, u[o + 2] += m.z, u[h] += m.x, u[h + 1] += m.y, u[h + 2] += m.z, u[l] += m.x, u[l + 1] += m.y, u[l + 2] += m.z
                } else
                    for (var s = 0, a = n.length; s < a; s += 9) d.fromArray(n, s), p.fromArray(n, s + 3), f.fromArray(n, s + 6), m.subVectors(f, p), v.subVectors(d, p), m.cross(v), u[s] = m.x, u[s + 1] = m.y, u[s + 2] = m.z, u[s + 3] = m.x, u[s + 4] = m.y, u[s + 5] = m.z, u[s + 6] = m.x, u[s + 7] = m.y, u[s + 8] = m.z;
                this.normalizeNormals(), e.normal.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
            void 0 === e && (e = 0);
            var i = this.attributes;
            for (var n in i)
                if (void 0 !== t.attributes[n])
                    for (var r = i[n], s = r.array, a = t.attributes[n], o = a.array, h = a.itemSize, l = 0, c = h * e; l < o.length; l++, c++) s[c] = o[l];
            return this
        },
        normalizeNormals: function() {
            var t = new c;
            return function() {
                for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z)
            }
        }(),
        toNonIndexed: function() {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var t = new Lt,
                e = this.index.array,
                i = this.attributes;
            for (var n in i) {
                for (var r = i[n], s = r.array, a = r.itemSize, o = new s.constructor(e.length * a), h = 0, l = 0, c = 0, u = e.length; c < u; c++) {
                    h = e[c] * a;
                    for (var d = 0; d < a; d++) o[l++] = s[h++]
                }
                t.addAttribute(n, new _t(o, a))
            }
            return t
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                var e = this.parameters;
                for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                return t
            }
            t.data = {
                attributes: {}
            };
            var n = this.index;
            if (null !== n) {
                var r = Array.prototype.slice.call(n.array);
                t.data.index = {
                    type: n.array.constructor.name,
                    array: r
                }
            }
            var s = this.attributes;
            for (var i in s) {
                var a = s[i],
                    r = Array.prototype.slice.call(a.array);
                t.data.attributes[i] = {
                    itemSize: a.itemSize,
                    type: a.array.constructor.name,
                    array: r,
                    normalized: a.normalized
                }
            }
            var o = this.groups;
            o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
            var h = this.boundingSphere;
            return null !== h && (t.data.boundingSphere = {
                center: h.center.toArray(),
                radius: h.radius
            }), t
        },
        clone: function() {
            return (new Lt).copy(this)
        },
        copy: function(t) {
            var e, i, n;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var r = t.index;
            null !== r && this.setIndex(r.clone());
            var s = t.attributes;
            for (e in s) {
                var a = s[e];
                this.addAttribute(e, a.clone())
            }
            var o = t.morphAttributes;
            for (e in o) {
                var h = [],
                    l = o[e];
                for (i = 0, n = l.length; i < n; i++) h.push(l[i].clone());
                this.morphAttributes[e] = h
            }
            var c = t.groups;
            for (i = 0, n = c.length; i < n; i++) {
                var u = c[i];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            var d = t.boundingBox;
            null !== d && (this.boundingBox = d.clone());
            var p = t.boundingSphere;
            return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Ot.prototype = Object.create(yt.prototype), Ot.prototype.constructor = Ot, It.prototype = Object.create(Lt.prototype), It.prototype.constructor = It, Dt.prototype = Object.create(yt.prototype), Dt.prototype.constructor = Dt, zt.prototype = Object.create(Lt.prototype), zt.prototype.constructor = zt, Ut.prototype = Object.create(K.prototype), Ut.prototype.constructor = Ut, Ut.prototype.isMeshBasicMaterial = !0, Ut.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    }, Object.assign(Nt.prototype, {
        set: function(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        },
        at: function(t, e) {
            return (e || new c).copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this
        },
        recast: function() {
            var t = new c;
            return function(e) {
                return this.origin.copy(this.at(e, t)), this
            }
        }(),
        closestPointToPoint: function(t, e) {
            var i = e || new c;
            i.subVectors(t, this.origin);
            var n = i.dot(this.direction);
            return n < 0 ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function() {
            var t = new c;
            return function(e) {
                var i = t.subVectors(e, this.origin).dot(this.direction);
                return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
            }
        }(),
        distanceSqToSegment: function() {
            var t = new c,
                e = new c,
                i = new c;
            return function(n, r, s, a) {
                t.copy(n).add(r).multiplyScalar(.5), e.copy(r).sub(n).normalize(), i.copy(this.origin).sub(t);
                var o, h, l, c, u = .5 * n.distanceTo(r),
                    d = -this.direction.dot(e),
                    p = i.dot(this.direction),
                    f = -i.dot(e),
                    m = i.lengthSq(),
                    v = Math.abs(1 - d * d);
                if (v > 0)
                    if (o = d * f - p, h = d * p - f, c = u * v, o >= 0)
                        if (h >= -c)
                            if (h <= c) {
                                var g = 1 / v;
                                o *= g, h *= g, l = o * (o + d * h + 2 * p) + h * (d * o + h + 2 * f) + m
                            } else h = u, o = Math.max(0, -(d * h + p)), l = -o * o + h * (h + 2 * f) + m;
                else h = -u, o = Math.max(0, -(d * h + p)), l = -o * o + h * (h + 2 * f) + m;
                else h <= -c ? (o = Math.max(0, -(-d * u + p)), h = o > 0 ? -u : Math.min(Math.max(-u, -f), u), l = -o * o + h * (h + 2 * f) + m) : h <= c ? (o = 0, h = Math.min(Math.max(-u, -f), u), l = h * (h + 2 * f) + m) : (o = Math.max(0, -(d * u + p)), h = o > 0 ? u : Math.min(Math.max(-u, -f), u), l = -o * o + h * (h + 2 * f) + m);
                else h = d > 0 ? -u : u, o = Math.max(0, -(d * h + p)), l = -o * o + h * (h + 2 * f) + m;
                return s && s.copy(this.direction).multiplyScalar(o).add(this.origin), a && a.copy(e).multiplyScalar(h).add(t), l
            }
        }(),
        intersectSphere: function() {
            var t = new c;
            return function(e, i) {
                t.subVectors(e.center, this.origin);
                var n = t.dot(this.direction),
                    r = t.dot(t) - n * n,
                    s = e.radius * e.radius;
                if (r > s) return null;
                var a = Math.sqrt(s - r),
                    o = n - a,
                    h = n + a;
                return o < 0 && h < 0 ? null : o < 0 ? this.at(h, i) : this.at(o, i)
            }
        }(),
        intersectsSphere: function(t) {
            return this.distanceToPoint(t.center) <= t.radius
        },
        distanceToPlane: function(t) {
            var e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            var i = -(this.origin.dot(t.normal) + t.constant) / e;
            return i >= 0 ? i : null
        },
        intersectPlane: function(t, e) {
            var i = this.distanceToPlane(t);
            return null === i ? null : this.at(i, e)
        },
        intersectsPlane: function(t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0
        },
        intersectBox: function(t, e) {
            var i, n, r, s, a, o, h = 1 / this.direction.x,
                l = 1 / this.direction.y,
                c = 1 / this.direction.z,
                u = this.origin;
            return h >= 0 ? (i = (t.min.x - u.x) * h, n = (t.max.x - u.x) * h) : (i = (t.max.x - u.x) * h, n = (t.min.x - u.x) * h), l >= 0 ? (r = (t.min.y - u.y) * l, s = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l, s = (t.min.y - u.y) * l), i > s || r > n ? null : ((r > i || i !== i) && (i = r), (s < n || n !== n) && (n = s), c >= 0 ? (a = (t.min.z - u.z) * c, o = (t.max.z - u.z) * c) : (a = (t.max.z - u.z) * c, o = (t.min.z - u.z) * c), i > o || a > n ? null : ((a > i || i !== i) && (i = a), (o < n || n !== n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
        },
        intersectsBox: function() {
            var t = new c;
            return function(e) {
                return null !== this.intersectBox(e, t)
            }
        }(),
        intersectTriangle: function() {
            var t = new c,
                e = new c,
                i = new c,
                n = new c;
            return function(r, s, a, o, h) {
                e.subVectors(s, r), i.subVectors(a, r), n.crossVectors(e, i);
                var l, c = this.direction.dot(n);
                if (c > 0) {
                    if (o) return null;
                    l = 1
                } else {
                    if (!(c < 0)) return null;
                    l = -1, c = -c
                }
                t.subVectors(this.origin, r);
                var u = l * this.direction.dot(i.crossVectors(t, i));
                if (u < 0) return null;
                var d = l * this.direction.dot(e.cross(t));
                if (d < 0) return null;
                if (u + d > c) return null;
                var p = -l * t.dot(n);
                return p < 0 ? null : this.at(p / c, h)
            }
        }(),
        applyMatrix4: function(t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    }), Object.assign(kt.prototype, {
        set: function(t, e) {
            return this.start.copy(t), this.end.copy(e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this
        },
        getCenter: function(t) {
            return (t || new c).addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            return (t || new c).subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            var i = e || new c;
            return this.delta(i).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: function() {
            var t = new c,
                e = new c;
            return function(i, n) {
                t.subVectors(i, this.start), e.subVectors(this.end, this.start);
                var r = e.dot(e),
                    s = e.dot(t),
                    a = s / r;
                return n && (a = Oo.clamp(a, 0, 1)), a
            }
        }(),
        closestPointToPoint: function(t, e, i) {
            var n = this.closestPointToPointParameter(t, e),
                r = i || new c;
            return this.delta(r).multiplyScalar(n).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }), Object.assign(Ft, {
        normal: function() {
            var t = new c;
            return function(e, i, n, r) {
                var s = r || new c;
                s.subVectors(n, i), t.subVectors(e, i), s.cross(t);
                var a = s.lengthSq();
                return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0)
            }
        }(),
        barycoordFromPoint: function() {
            var t = new c,
                e = new c,
                i = new c;
            return function(n, r, s, a, o) {
                t.subVectors(a, r), e.subVectors(s, r), i.subVectors(n, r);
                var h = t.dot(t),
                    l = t.dot(e),
                    u = t.dot(i),
                    d = e.dot(e),
                    p = e.dot(i),
                    f = h * d - l * l,
                    m = o || new c;
                if (0 === f) return m.set(-2, -1, -1);
                var v = 1 / f,
                    g = (d * u - l * p) * v,
                    y = (h * p - l * u) * v;
                return m.set(1 - g - y, y, g)
            }
        }(),
        containsPoint: function() {
            var t = new c;
            return function(e, i, n, r) {
                var s = Ft.barycoordFromPoint(e, i, n, r, t);
                return s.x >= 0 && s.y >= 0 && s.x + s.y <= 1
            }
        }()
    }), Object.assign(Ft.prototype, {
        set: function(t, e, i) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
        },
        setFromPointsAndIndices: function(t, e, i, n) {
            return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        },
        area: function() {
            var t = new c,
                e = new c;
            return function() {
                return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
            }
        }(),
        midpoint: function(t) {
            return (t || new c).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function(t) {
            return Ft.normal(this.a, this.b, this.c, t)
        },
        plane: function(t) {
            return (t || new at).setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function(t, e) {
            return Ft.barycoordFromPoint(t, this.a, this.b, this.c, e)
        },
        containsPoint: function(t) {
            return Ft.containsPoint(t, this.a, this.b, this.c)
        },
        closestPointToPoint: function() {
            var t = new at,
                e = [new kt, new kt, new kt],
                i = new c,
                n = new c;
            return function(r, s) {
                var a = s || new c,
                    o = 1 / 0;
                if (t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(r, i), !0 === this.containsPoint(i)) a.copy(i);
                else {
                    e[0].set(this.a, this.b), e[1].set(this.b, this.c), e[2].set(this.c, this.a);
                    for (var h = 0; h < e.length; h++) {
                        e[h].closestPointToPoint(i, !0, n);
                        var l = i.distanceToSquared(n);
                        l < o && (o = l, a.copy(n))
                    }
                }
                return a
            }
        }(),
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }), Bt.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Bt,
        isMesh: !0,
        setDrawMode: function(t) {
            this.drawMode = t
        },
        copy: function(t) {
            return dt.prototype.copy.call(this, t), this.drawMode = t.drawMode, this
        },
        updateMorphTargets: function() {
            var t, e, i, n = this.geometry;
            if (n.isBufferGeometry) {
                var r = n.morphAttributes,
                    s = Object.keys(r);
                if (s.length > 0) {
                    var a = r[s[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) i = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                }
            } else {
                var o = n.morphTargets;
                if (void 0 !== o && o.length > 0)
                    for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = o.length; t < e; t++) i = o[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
            }
        },
        raycast: function() {
            function t(t, e, i, n, r, s, a) {
                return Ft.barycoordFromPoint(t, e, i, n, y), r.multiplyScalar(y.x), s.multiplyScalar(y.y), a.multiplyScalar(y.z), r.add(s).add(a), r.clone()
            }

            function e(t, e, i, n, r, s, a, o) {
                if (null === (e.side === Ss ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, e.side !== As, o))) return null;
                x.copy(o), x.applyMatrix4(t.matrixWorld);
                var h = i.ray.origin.distanceTo(x);
                return h < i.near || h > i.far ? null : {
                    distance: h,
                    point: x.clone(),
                    object: t
                }
            }

            function i(i, n, r, s, a, c, u, d) {
                o.fromBufferAttribute(s, c), h.fromBufferAttribute(s, u), l.fromBufferAttribute(s, d);
                var p = e(i, i.material, n, r, o, h, l, _);
                return p && (a && (m.fromBufferAttribute(a, c), v.fromBufferAttribute(a, u), g.fromBufferAttribute(a, d), p.uv = t(_, o, h, l, m, v, g)), p.face = new vt(c, u, d, Ft.normal(o, h, l)), p.faceIndex = c), p
            }
            var n = new u,
                s = new Nt,
                a = new rt,
                o = new c,
                h = new c,
                l = new c,
                d = new c,
                p = new c,
                f = new c,
                m = new r,
                v = new r,
                g = new r,
                y = new c,
                _ = new c,
                x = new c;
            return function(r, c) {
                var u = this.geometry,
                    y = this.material,
                    x = this.matrixWorld;
                if (void 0 !== y && (null === u.boundingSphere && u.computeBoundingSphere(), a.copy(u.boundingSphere), a.applyMatrix4(x), !1 !== r.ray.intersectsSphere(a) && (n.getInverse(x), s.copy(r.ray).applyMatrix4(n), null === u.boundingBox || !1 !== s.intersectsBox(u.boundingBox)))) {
                    var b;
                    if (u.isBufferGeometry) {
                        var w, T, M, E, S, A = u.index,
                            P = u.attributes.position,
                            R = u.attributes.uv;
                        if (null !== A)
                            for (E = 0, S = A.count; E < S; E += 3) w = A.getX(E), T = A.getX(E + 1), M = A.getX(E + 2), (b = i(this, r, s, P, R, w, T, M)) && (b.faceIndex = Math.floor(E / 3), c.push(b));
                        else
                            for (E = 0, S = P.count; E < S; E += 3) w = E, T = E + 1, M = E + 2, (b = i(this, r, s, P, R, w, T, M)) && (b.index = w, c.push(b))
                    } else if (u.isGeometry) {
                        var C, L, O, I, D = Array.isArray(y),
                            z = u.vertices,
                            U = u.faces,
                            N = u.faceVertexUvs[0];
                        N.length > 0 && (I = N);
                        for (var k = 0, F = U.length; k < F; k++) {
                            var B = U[k],
                                G = D ? y[B.materialIndex] : y;
                            if (void 0 !== G) {
                                if (C = z[B.a], L = z[B.b], O = z[B.c], !0 === G.morphTargets) {
                                    var H = u.morphTargets,
                                        j = this.morphTargetInfluences;
                                    o.set(0, 0, 0), h.set(0, 0, 0), l.set(0, 0, 0);
                                    for (var V = 0, W = H.length; V < W; V++) {
                                        var X = j[V];
                                        if (0 !== X) {
                                            var q = H[V].vertices;
                                            o.addScaledVector(d.subVectors(q[B.a], C), X), h.addScaledVector(p.subVectors(q[B.b], L), X), l.addScaledVector(f.subVectors(q[B.c], O), X)
                                        }
                                    }
                                    o.add(C), h.add(L), l.add(O), C = o, L = h, O = l
                                }
                                if (b = e(this, G, r, s, C, L, O, _)) {
                                    if (I && I[k]) {
                                        var Y = I[k];
                                        m.copy(Y[0]), v.copy(Y[1]), g.copy(Y[2]), b.uv = t(_, C, L, O, m, v, g)
                                    }
                                    b.face = B, b.faceIndex = k, c.push(b)
                                }
                            }
                        }
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var Zo = 0;
    _e.prototype = Object.assign(Object.create(mt.prototype), {
        constructor: _e,
        isArrayCamera: !0
    }), Ee.prototype.isFogExp2 = !0, Ee.prototype.clone = function() {
        return new Ee(this.color.getHex(), this.density)
    }, Ee.prototype.toJSON = function(t) {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }, Se.prototype.isFog = !0, Se.prototype.clone = function() {
        return new Se(this.color.getHex(), this.near, this.far)
    }, Se.prototype.toJSON = function(t) {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }, Ae.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Ae,
        copy: function(t, e) {
            return dt.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
        },
        toJSON: function(t) {
            var e = dt.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        }
    }), Pe.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Pe,
        isLensFlare: !0,
        copy: function(t) {
            dt.prototype.copy.call(this, t), this.positionScreen.copy(t.positionScreen), this.customUpdateCallback = t.customUpdateCallback;
            for (var e = 0, i = t.lensFlares.length; e < i; e++) this.lensFlares.push(t.lensFlares[e]);
            return this
        },
        add: function(t, e, i, n, r, s) {
            void 0 === e && (e = -1), void 0 === i && (i = 0), void 0 === s && (s = 1), void 0 === r && (r = new Y(16777215)), void 0 === n && (n = Ds), i = Math.min(i, Math.max(0, i)), this.lensFlares.push({
                texture: t,
                size: e,
                distance: i,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: s,
                color: r,
                blending: n
            })
        },
        updateLensFlares: function() {
            var t, e, i = this.lensFlares.length,
                n = 2 * -this.positionScreen.x,
                r = 2 * -this.positionScreen.y;
            for (t = 0; t < i; t++) e = this.lensFlares[t], e.x = this.positionScreen.x + n * e.distance, e.y = this.positionScreen.y + r * e.distance, e.wantedRotation = e.x * Math.PI * .25, e.rotation += .25 * (e.wantedRotation - e.rotation)
        }
    }), Re.prototype = Object.create(K.prototype), Re.prototype.constructor = Re, Re.prototype.isSpriteMaterial = !0, Re.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this
    }, Ce.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Ce,
        isSprite: !0,
        raycast: function() {
            var t = new c,
                e = new c,
                i = new c;
            return function(n, r) {
                e.setFromMatrixPosition(this.matrixWorld), n.ray.closestPointToPoint(e, t), i.setFromMatrixScale(this.matrixWorld);
                var s = i.x * i.y / 4;
                if (!(e.distanceToSquared(t) > s)) {
                    var a = n.ray.origin.distanceTo(t);
                    a < n.near || a > n.far || r.push({
                        distance: a,
                        point: t.clone(),
                        face: null,
                        object: this
                    })
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        }
    }), Le.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Le,
        copy: function(t) {
            dt.prototype.copy.call(this, t, !1);
            for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                this.addLevel(r.object.clone(), r.distance)
            }
            return this
        },
        addLevel: function(t, e) {
            void 0 === e && (e = 0), e = Math.abs(e);
            for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
            i.splice(n, 0, {
                distance: e,
                object: t
            }), this.add(t)
        },
        getObjectForDistance: function(t) {
            for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
            return e[i - 1].object
        },
        raycast: function() {
            var t = new c;
            return function(e, i) {
                t.setFromMatrixPosition(this.matrixWorld);
                var n = e.ray.origin.distanceTo(t);
                this.getObjectForDistance(n).raycast(e, i)
            }
        }(),
        update: function() {
            var t = new c,
                e = new c;
            return function(i) {
                var n = this.levels;
                if (n.length > 1) {
                    t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                    var r = t.distanceTo(e);
                    n[0].object.visible = !0;
                    for (var s = 1, a = n.length; s < a && r >= n[s].distance; s++) n[s - 1].object.visible = !1, n[s].object.visible = !0;
                    for (; s < a; s++) n[s].object.visible = !1
                }
            }
        }(),
        toJSON: function(t) {
            var e = dt.prototype.toJSON.call(this, t);
            e.object.levels = [];
            for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                var s = i[n];
                e.object.levels.push({
                    object: s.object.uuid,
                    distance: s.distance
                })
            }
            return e
        }
    }), Object.assign(Oe.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var i = new u;
                this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
            }
        },
        pose: function() {
            var t, e, i;
            for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
        },
        update: function() {
            var t = new u,
                e = new u;
            return function() {
                for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, s = this.boneTexture, a = 0, o = i.length; a < o; a++) {
                    var h = i[a] ? i[a].matrixWorld : e;
                    t.multiplyMatrices(h, n[a]), t.toArray(r, 16 * a)
                }
                void 0 !== s && (s.needsUpdate = !0)
            }
        }(),
        clone: function() {
            return new Oe(this.bones, this.boneInverses)
        }
    }), Ie.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Ie,
        isBone: !0
    }), De.prototype = Object.assign(Object.create(Bt.prototype), {
        constructor: De,
        isSkinnedMesh: !0,
        initBones: function() {
            var t, e, i, n, r = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (i = 0, n = this.geometry.bones.length; i < n; i++) e = this.geometry.bones[i], t = new Ie, r.push(t), t.name = e.name, t.position.fromArray(e.pos), t.quaternion.fromArray(e.rotq), void 0 !== e.scl && t.scale.fromArray(e.scl);
                for (i = 0, n = this.geometry.bones.length; i < n; i++) e = this.geometry.bones[i], -1 !== e.parent && null !== e.parent && void 0 !== r[e.parent] ? r[e.parent].add(r[i]) : this.add(r[i])
            }
            return this.updateMatrixWorld(!0), r
        },
        bind: function(t, e) {
            this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            var t, e;
            if (this.geometry && this.geometry.isGeometry)
                for (e = 0; e < this.geometry.skinWeights.length; e++) {
                    var i = this.geometry.skinWeights[e];
                    t = 1 / i.lengthManhattan(), t !== 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0)
                } else if (this.geometry && this.geometry.isBufferGeometry) {
                    var n = new a,
                        r = this.geometry.attributes.skinWeight;
                    for (e = 0; e < r.count; e++) n.x = r.getX(e), n.y = r.getY(e), n.z = r.getZ(e), n.w = r.getW(e), t = 1 / n.lengthManhattan(), t !== 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0), r.setXYZW(e, n.x, n.y, n.z, n.w)
                }
        },
        updateMatrixWorld: function(t) {
            Bt.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), ze.prototype = Object.create(K.prototype), ze.prototype.constructor = ze, ze.prototype.isLineBasicMaterial = !0, ze.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
    }, Ue.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Ue,
        isLine: !0,
        raycast: function() {
            var t = new u,
                e = new Nt,
                i = new rt;
            return function(n, r) {
                var s = n.linePrecision,
                    a = s * s,
                    o = this.geometry,
                    h = this.matrixWorld;
                if (null === o.boundingSphere && o.computeBoundingSphere(), i.copy(o.boundingSphere), i.applyMatrix4(h), !1 !== n.ray.intersectsSphere(i)) {
                    t.getInverse(h), e.copy(n.ray).applyMatrix4(t);
                    var l = new c,
                        u = new c,
                        d = new c,
                        p = new c,
                        f = this && this.isLineSegments ? 2 : 1;
                    if (o.isBufferGeometry) {
                        var m = o.index,
                            v = o.attributes,
                            g = v.position.array;
                        if (null !== m)
                            for (var y = m.array, _ = 0, x = y.length - 1; _ < x; _ += f) {
                                var b = y[_],
                                    w = y[_ + 1];
                                l.fromArray(g, 3 * b), u.fromArray(g, 3 * w);
                                var T = e.distanceSqToSegment(l, u, p, d);
                                if (!(T > a)) {
                                    p.applyMatrix4(this.matrixWorld);
                                    var M = n.ray.origin.distanceTo(p);
                                    M < n.near || M > n.far || r.push({
                                        distance: M,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: _,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            } else
                                for (var _ = 0, x = g.length / 3 - 1; _ < x; _ += f) {
                                    l.fromArray(g, 3 * _), u.fromArray(g, 3 * _ + 3);
                                    var T = e.distanceSqToSegment(l, u, p, d);
                                    if (!(T > a)) {
                                        p.applyMatrix4(this.matrixWorld);
                                        var M = n.ray.origin.distanceTo(p);
                                        M < n.near || M > n.far || r.push({
                                            distance: M,
                                            point: d.clone().applyMatrix4(this.matrixWorld),
                                            index: _,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                    } else if (o.isGeometry)
                        for (var E = o.vertices, S = E.length, _ = 0; _ < S - 1; _ += f) {
                            var T = e.distanceSqToSegment(E[_], E[_ + 1], p, d);
                            if (!(T > a)) {
                                p.applyMatrix4(this.matrixWorld);
                                var M = n.ray.origin.distanceTo(p);
                                M < n.near || M > n.far || r.push({
                                    distance: M,
                                    point: d.clone().applyMatrix4(this.matrixWorld),
                                    index: _,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Ne.prototype = Object.assign(Object.create(Ue.prototype), {
        constructor: Ne,
        isLineSegments: !0
    }), ke.prototype = Object.assign(Object.create(Ue.prototype), {
        constructor: ke,
        isLineLoop: !0
    }), Fe.prototype = Object.create(K.prototype), Fe.prototype.constructor = Fe, Fe.prototype.isPointsMaterial = !0, Fe.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
    }, Be.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Be,
        isPoints: !0,
        raycast: function() {
            var t = new u,
                e = new Nt,
                i = new rt;
            return function(n, r) {
                function s(t, i) {
                    var s = e.distanceSqToPoint(t);
                    if (s < d) {
                        var o = e.closestPointToPoint(t);
                        o.applyMatrix4(h);
                        var l = n.ray.origin.distanceTo(o);
                        if (l < n.near || l > n.far) return;
                        r.push({
                            distance: l,
                            distanceToRay: Math.sqrt(s),
                            point: o.clone(),
                            index: i,
                            face: null,
                            object: a
                        })
                    }
                }
                var a = this,
                    o = this.geometry,
                    h = this.matrixWorld,
                    l = n.params.Points.threshold;
                if (null === o.boundingSphere && o.computeBoundingSphere(), i.copy(o.boundingSphere), i.applyMatrix4(h), i.radius += l, !1 !== n.ray.intersectsSphere(i)) {
                    t.getInverse(h), e.copy(n.ray).applyMatrix4(t);
                    var u = l / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        d = u * u,
                        p = new c;
                    if (o.isBufferGeometry) {
                        var f = o.index,
                            m = o.attributes,
                            v = m.position.array;
                        if (null !== f)
                            for (var g = f.array, y = 0, _ = g.length; y < _; y++) {
                                var x = g[y];
                                p.fromArray(v, 3 * x), s(p, x)
                            } else
                                for (var y = 0, b = v.length / 3; y < b; y++) p.fromArray(v, 3 * y), s(p, y)
                    } else
                        for (var w = o.vertices, y = 0, b = w.length; y < b; y++) s(w[y], y)
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Ge.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Ge
    }), He.prototype = Object.create(s.prototype), He.prototype.constructor = He, je.prototype = Object.create(s.prototype), je.prototype.constructor = je, je.prototype.isCompressedTexture = !0, Ve.prototype = Object.create(s.prototype), Ve.prototype.constructor = Ve, Ve.prototype.isDepthTexture = !0, We.prototype = Object.create(Lt.prototype), We.prototype.constructor = We, Xe.prototype = Object.create(yt.prototype), Xe.prototype.constructor = Xe, qe.prototype = Object.create(Lt.prototype), qe.prototype.constructor = qe, Ye.prototype = Object.create(yt.prototype), Ye.prototype.constructor = Ye, Ze.prototype = Object.create(Lt.prototype), Ze.prototype.constructor = Ze, $e.prototype = Object.create(yt.prototype), $e.prototype.constructor = $e, Qe.prototype = Object.create(Ze.prototype), Qe.prototype.constructor = Qe, Je.prototype = Object.create(yt.prototype), Je.prototype.constructor = Je, Ke.prototype = Object.create(Ze.prototype), Ke.prototype.constructor = Ke, ti.prototype = Object.create(yt.prototype), ti.prototype.constructor = ti, ei.prototype = Object.create(Ze.prototype), ei.prototype.constructor = ei, ii.prototype = Object.create(yt.prototype), ii.prototype.constructor = ii, ni.prototype = Object.create(Ze.prototype), ni.prototype.constructor = ni, ri.prototype = Object.create(yt.prototype), ri.prototype.constructor = ri, si.prototype = Object.create(Lt.prototype), si.prototype.constructor = si, ai.prototype = Object.create(yt.prototype), ai.prototype.constructor = ai, oi.prototype = Object.create(Lt.prototype), oi.prototype.constructor = oi, hi.prototype = Object.create(yt.prototype), hi.prototype.constructor = hi, li.prototype = Object.create(Lt.prototype), li.prototype.constructor = li;
    var $o = {
        area: function(t) {
            for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
            return .5 * i
        },
        triangulate: function() {
            function t(t, e, i, n, r, s) {
                var a, o, h, l, c, u, d, p, f;
                if (o = t[s[e]].x, h = t[s[e]].y, l = t[s[i]].x, c = t[s[i]].y, u = t[s[n]].x, d = t[s[n]].y, (l - o) * (d - h) - (c - h) * (u - o) <= 0) return !1;
                var m, v, g, y, _, x, b, w, T, M, E, S, A, P, R;
                for (m = u - l, v = d - c, g = o - u, y = h - d, _ = l - o, x = c - h, a = 0; a < r; a++)
                    if (p = t[s[a]].x, f = t[s[a]].y, !(p === o && f === h || p === l && f === c || p === u && f === d) && (b = p - o, w = f - h, T = p - l, M = f - c, E = p - u, S = f - d, R = m * M - v * T, A = _ * w - x * b, P = g * S - y * E, R >= -Number.EPSILON && P >= -Number.EPSILON && A >= -Number.EPSILON)) return !1;
                return !0
            }
            return function(e, i) {
                var n = e.length;
                if (n < 3) return null;
                var r, s, a, o = [],
                    h = [],
                    l = [];
                if ($o.area(e) > 0)
                    for (s = 0; s < n; s++) h[s] = s;
                else
                    for (s = 0; s < n; s++) h[s] = n - 1 - s;
                var c = n,
                    u = 2 * c;
                for (s = c - 1; c > 2;) {
                    if (u-- <= 0) return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"), i ? l : o;
                    if (r = s, c <= r && (r = 0), s = r + 1, c <= s && (s = 0), a = s + 1, c <= a && (a = 0), t(e, r, s, a, c, h)) {
                        var d, p, f, m, v;
                        for (d = h[r], p = h[s], f = h[a], o.push([e[d], e[p], e[f]]), l.push([h[r], h[s], h[a]]), m = s, v = s + 1; v < c; m++, v++) h[m] = h[v];
                        c--, u = 2 * c
                    }
                }
                return i ? l : o
            }
        }(),
        triangulateShape: function(t, e) {
            function i(t) {
                var e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function n(t, e, i) {
                return t.x !== e.x ? t.x < e.x ? t.x <= i.x && i.x <= e.x : e.x <= i.x && i.x <= t.x : t.y < e.y ? t.y <= i.y && i.y <= e.y : e.y <= i.y && i.y <= t.y
            }

            function r(t, e, i, r, s) {
                var a = e.x - t.x,
                    o = e.y - t.y,
                    h = r.x - i.x,
                    l = r.y - i.y,
                    c = t.x - i.x,
                    u = t.y - i.y,
                    d = o * h - a * l,
                    p = o * c - a * u;
                if (Math.abs(d) > Number.EPSILON) {
                    var f;
                    if (d > 0) {
                        if (p < 0 || p > d) return [];
                        if ((f = l * c - h * u) < 0 || f > d) return []
                    } else {
                        if (p > 0 || p < d) return [];
                        if ((f = l * c - h * u) > 0 || f < d) return []
                    }
                    if (0 === f) return !s || 0 !== p && p !== d ? [t] : [];
                    if (f === d) return !s || 0 !== p && p !== d ? [e] : [];
                    if (0 === p) return [i];
                    if (p === d) return [r];
                    var m = f / d;
                    return [{
                        x: t.x + m * a,
                        y: t.y + m * o
                    }]
                }
                if (0 !== p || l * c != h * u) return [];
                var v = 0 === a && 0 === o,
                    g = 0 === h && 0 === l;
                if (v && g) return t.x !== i.x || t.y !== i.y ? [] : [t];
                if (v) return n(i, r, t) ? [t] : [];
                if (g) return n(t, e, i) ? [i] : [];
                var y, _, x, b, w, T, M, E;
                return 0 !== a ? (t.x < e.x ? (y = t, x = t.x, _ = e, b = e.x) : (y = e, x = e.x, _ = t, b = t.x), i.x < r.x ? (w = i, M = i.x, T = r, E = r.x) : (w = r, M = r.x, T = i, E = i.x)) : (t.y < e.y ? (y = t, x = t.y, _ = e, b = e.y) : (y = e, x = e.y, _ = t, b = t.y), i.y < r.y ? (w = i, M = i.y, T = r, E = r.y) : (w = r, M = r.y, T = i, E = i.y)), x <= M ? b < M ? [] : b === M ? s ? [] : [w] : b <= E ? [w, _] : [w, T] : x > E ? [] : x === E ? s ? [] : [y] : b <= E ? [y, _] : [y, T]
            }

            function s(t, e, i, n) {
                var r = e.x - t.x,
                    s = e.y - t.y,
                    a = i.x - t.x,
                    o = i.y - t.y,
                    h = n.x - t.x,
                    l = n.y - t.y,
                    c = r * o - s * a,
                    u = r * l - s * h;
                if (Math.abs(c) > Number.EPSILON) {
                    var d = h * o - l * a;
                    return c > 0 ? u >= 0 && d >= 0 : u >= 0 || d >= 0
                }
                return u > 0
            }
            i(t), e.forEach(i);
            for (var a, o, h, l, c, u, d = {}, p = t.concat(), f = 0, m = e.length; f < m; f++) Array.prototype.push.apply(p, e[f]);
            for (a = 0, o = p.length; a < o; a++) c = p[a].x + ":" + p[a].y, void 0 !== d[c] && console.warn("THREE.ShapeUtils: Duplicate point", c, a), d[c] = a;
            var v = function(t, e) {
                    for (var i, n, a, o, h, l, c, u, d, p, f, m = t.concat(), v = [], g = [], y = 0, _ = e.length; y < _; y++) v.push(y);
                    for (var x = 0, b = 2 * v.length; v.length > 0;) {
                        if (--b < 0) {
                            console.log('THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!');
                            break
                        }
                        for (a = x; a < m.length; a++) {
                            o = m[a], n = -1;
                            for (var y = 0; y < v.length; y++)
                                if (l = v[y], c = o.x + ":" + o.y + ":" + l, void 0 === g[c]) {
                                    i = e[l];
                                    for (var w = 0; w < i.length; w++)
                                        if (h = i[w], function(t, e) {
                                                var n = m.length - 1,
                                                    r = t - 1;
                                                r < 0 && (r = n);
                                                var a = t + 1;
                                                a > n && (a = 0);
                                                var o = s(m[t], m[r], m[a], i[e]);
                                                if (!o) return !1;
                                                var h = i.length - 1,
                                                    l = e - 1;
                                                l < 0 && (l = h);
                                                var c = e + 1;
                                                return c > h && (c = 0), !!(o = s(i[e], i[l], i[c], m[t]))
                                            }(a, w) && ! function(t, e) {
                                                var i, n, s;
                                                for (i = 0; i < m.length; i++)
                                                    if (n = i + 1, n %= m.length, s = r(t, e, m[i], m[n], !0), s.length > 0) return !0;
                                                return !1
                                            }(o, h) && ! function(t, i) {
                                                var n, s, a, o, h;
                                                for (n = 0; n < v.length; n++)
                                                    for (s = e[v[n]], a = 0; a < s.length; a++)
                                                        if (o = a + 1, o %= s.length, h = r(t, i, s[a], s[o], !0), h.length > 0) return !0;
                                                return !1
                                            }(o, h)) {
                                            n = w, v.splice(y, 1), u = m.slice(0, a + 1), d = m.slice(a), p = i.slice(n), f = i.slice(0, n + 1), m = u.concat(p).concat(f).concat(d), x = a;
                                            break
                                        }
                                    if (n >= 0) break;
                                    g[c] = !0
                                }
                            if (n >= 0) break
                        }
                    }
                    return m
                }(t, e),
                g = $o.triangulate(v, !1);
            for (a = 0, o = g.length; a < o; a++)
                for (l = g[a], h = 0; h < 3; h++) c = l[h].x + ":" + l[h].y, void 0 !== (u = d[c]) && (l[h] = u);
            return g.concat()
        },
        isClockWise: function(t) {
            return $o.area(t) < 0
        }
    };
    ci.prototype = Object.create(yt.prototype), ci.prototype.constructor = ci, ui.prototype = Object.create(Lt.prototype), ui.prototype.constructor = ui, ui.prototype.getArrays = function() {
        var t = this.getAttribute("position"),
            e = t ? Array.prototype.slice.call(t.array) : [],
            i = this.getAttribute("uv"),
            n = i ? Array.prototype.slice.call(i.array) : [],
            r = this.index;
        return {
            position: e,
            uv: n,
            index: r ? Array.prototype.slice.call(r.array) : []
        }
    }, ui.prototype.addShapeList = function(t, e) {
        var i = t.length;
        e.arrays = this.getArrays();
        for (var n = 0; n < i; n++) {
            var r = t[n];
            this.addShape(r, e)
        }
        this.setIndex(e.arrays.index), this.addAttribute("position", new At(e.arrays.position, 3)), this.addAttribute("uv", new At(e.arrays.uv, 2))
    }, ui.prototype.addShape = function(t, e) {
        function i(t, e, i) {
            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
        }

        function n(t, e, i) {
            var n, s, a, o = t.x - e.x,
                h = t.y - e.y,
                l = i.x - t.x,
                c = i.y - t.y,
                u = o * o + h * h,
                d = o * c - h * l;
            if (Math.abs(d) > Number.EPSILON) {
                var p = Math.sqrt(u),
                    f = Math.sqrt(l * l + c * c),
                    m = e.x - h / p,
                    v = e.y + o / p,
                    g = i.x - c / f,
                    y = i.y + l / f,
                    _ = ((g - m) * c - (y - v) * l) / (o * c - h * l);
                n = m + o * _ - t.x, s = v + h * _ - t.y;
                var x = n * n + s * s;
                if (x <= 2) return new r(n, s);
                a = Math.sqrt(x / 2)
            } else {
                var b = !1;
                o > Number.EPSILON ? l > Number.EPSILON && (b = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (b = !0) : Math.sign(h) === Math.sign(c) && (b = !0), b ? (n = -h, s = o, a = Math.sqrt(u)) : (n = o, s = h, a = Math.sqrt(u / 2))
            }
            return new r(n / a, s / a)
        }

        function s(t, e) {
            var i, n;
            for ($ = t.length; --$ >= 0;) {
                i = $, n = $ - 1, n < 0 && (n = t.length - 1);
                var r = 0,
                    s = P + 2 * E;
                for (r = 0; r < s; r++) {
                    var a = q * r,
                        o = q * (r + 1);
                    h(e + i + a, e + n + a, e + n + o, e + i + o, t, r, s, i, n)
                }
            }
        }

        function a(t, e, i) {
            b.push(t), b.push(e), b.push(i)
        }

        function o(t, e, i) {
            l(t), l(e), l(i);
            var n = y.length / 3,
                r = L.generateTopUV(z, y, n - 3, n - 2, n - 1);
            u(r[0]), u(r[1]), u(r[2])
        }

        function h(t, e, i, n, r, s, a, o, h) {
            l(t), l(e), l(n), l(e), l(i), l(n);
            var c = y.length / 3,
                d = L.generateSideWallUV(z, y, c - 6, c - 3, c - 2, c - 1);
            u(d[0]), u(d[1]), u(d[3]), u(d[1]), u(d[2]), u(d[3])
        }

        function l(t) {
            _.push(y.length / 3), y.push(b[3 * t + 0]), y.push(b[3 * t + 1]), y.push(b[3 * t + 2])
        }

        function u(t) {
            x.push(t.x), x.push(t.y)
        }
        var d, p, f, m, v, g = e.arrays ? e.arrays : this.getArrays(),
            y = g.position,
            _ = g.index,
            x = g.uv,
            b = [],
            w = void 0 !== e.amount ? e.amount : 100,
            T = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
            M = void 0 !== e.bevelSize ? e.bevelSize : T - 2,
            E = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
            S = void 0 === e.bevelEnabled || e.bevelEnabled,
            A = void 0 !== e.curveSegments ? e.curveSegments : 12,
            P = void 0 !== e.steps ? e.steps : 1,
            R = e.extrudePath,
            C = !1,
            L = void 0 !== e.UVGenerator ? e.UVGenerator : ci.WorldUVGenerator;
        R && (d = R.getSpacedPoints(P), C = !0, S = !1, p = void 0 !== e.frames ? e.frames : R.computeFrenetFrames(P, !1), f = new c, m = new c, v = new c), S || (E = 0, T = 0, M = 0);
        var O, I, D, z = this,
            U = t.extractPoints(A),
            N = U.shape,
            k = U.holes;
        if (!$o.isClockWise(N))
            for (N = N.reverse(), I = 0, D = k.length; I < D; I++) O = k[I], $o.isClockWise(O) && (k[I] = O.reverse());
        var F = $o.triangulateShape(N, k),
            B = N;
        for (I = 0, D = k.length; I < D; I++) O = k[I], N = N.concat(O);
        for (var G, H, j, V, W, X, q = N.length, Y = F.length, Z = [], $ = 0, Q = B.length, J = Q - 1, K = $ + 1; $ < Q; $++, J++, K++) J === Q && (J = 0), K === Q && (K = 0), Z[$] = n(B[$], B[J], B[K]);
        var tt, et = [],
            it = Z.concat();
        for (I = 0, D = k.length; I < D; I++) {
            for (O = k[I], tt = [], $ = 0, Q = O.length, J = Q - 1, K = $ + 1; $ < Q; $++, J++, K++) J === Q && (J = 0), K === Q && (K = 0), tt[$] = n(O[$], O[J], O[K]);
            et.push(tt), it = it.concat(tt)
        }
        for (G = 0; G < E; G++) {
            for (j = G / E, V = T * Math.cos(j * Math.PI / 2), H = M * Math.sin(j * Math.PI / 2), $ = 0, Q = B.length; $ < Q; $++) W = i(B[$], Z[$], H), a(W.x, W.y, -V);
            for (I = 0, D = k.length; I < D; I++)
                for (O = k[I], tt = et[I], $ = 0, Q = O.length; $ < Q; $++) W = i(O[$], tt[$], H), a(W.x, W.y, -V)
        }
        for (H = M, $ = 0; $ < q; $++) W = S ? i(N[$], it[$], H) : N[$], C ? (m.copy(p.normals[0]).multiplyScalar(W.x), f.copy(p.binormals[0]).multiplyScalar(W.y), v.copy(d[0]).add(m).add(f), a(v.x, v.y, v.z)) : a(W.x, W.y, 0);
        var nt;
        for (nt = 1; nt <= P; nt++)
            for ($ = 0; $ < q; $++) W = S ? i(N[$], it[$], H) : N[$], C ? (m.copy(p.normals[nt]).multiplyScalar(W.x), f.copy(p.binormals[nt]).multiplyScalar(W.y), v.copy(d[nt]).add(m).add(f), a(v.x, v.y, v.z)) : a(W.x, W.y, w / P * nt);
        for (G = E - 1; G >= 0; G--) {
            for (j = G / E, V = T * Math.cos(j * Math.PI / 2), H = M * Math.sin(j * Math.PI / 2), $ = 0, Q = B.length; $ < Q; $++) W = i(B[$], Z[$], H), a(W.x, W.y, w + V);
            for (I = 0, D = k.length; I < D; I++)
                for (O = k[I], tt = et[I], $ = 0, Q = O.length; $ < Q; $++) W = i(O[$], tt[$], H), C ? a(W.x, W.y + d[P - 1].y, d[P - 1].x + V) : a(W.x, W.y, w + V)
        }! function() {
            var t = y.length / 3;
            if (S) {
                var i = 0,
                    n = q * i;
                for ($ = 0; $ < Y; $++) X = F[$], o(X[2] + n, X[1] + n, X[0] + n);
                for (i = P + 2 * E, n = q * i, $ = 0; $ < Y; $++) X = F[$], o(X[0] + n, X[1] + n, X[2] + n)
            } else {
                for ($ = 0; $ < Y; $++) X = F[$], o(X[2], X[1], X[0]);
                for ($ = 0; $ < Y; $++) X = F[$], o(X[0] + q * P, X[1] + q * P, X[2] + q * P)
            }
            z.addGroup(t, y.length / 3 - t, void 0 !== e.material ? e.material : 0)
        }(),
        function() {
            var t = y.length / 3,
                i = 0;
            for (s(B, i), i += B.length, I = 0, D = k.length; I < D; I++) O = k[I], s(O, i), i += O.length;
            z.addGroup(t, y.length / 3 - t, void 0 !== e.extrudeMaterial ? e.extrudeMaterial : 1)
        }(), e.arrays || (this.setIndex(_), this.addAttribute("position", new At(y, 3)), this.addAttribute("uv", new At(e.arrays.uv, 2)))
    }, ci.WorldUVGenerator = {
        generateTopUV: function(t, e, i, n, s) {
            var a = e[3 * i],
                o = e[3 * i + 1],
                h = e[3 * n],
                l = e[3 * n + 1],
                c = e[3 * s],
                u = e[3 * s + 1];
            return [new r(a, o), new r(h, l), new r(c, u)]
        },
        generateSideWallUV: function(t, e, i, n, s, a) {
            var o = e[3 * i],
                h = e[3 * i + 1],
                l = e[3 * i + 2],
                c = e[3 * n],
                u = e[3 * n + 1],
                d = e[3 * n + 2],
                p = e[3 * s],
                f = e[3 * s + 1],
                m = e[3 * s + 2],
                v = e[3 * a],
                g = e[3 * a + 1],
                y = e[3 * a + 2];
            return Math.abs(h - u) < .01 ? [new r(o, 1 - l), new r(c, 1 - d), new r(p, 1 - m), new r(v, 1 - y)] : [new r(h, 1 - l), new r(u, 1 - d), new r(f, 1 - m), new r(g, 1 - y)]
        }
    }, di.prototype = Object.create(yt.prototype), di.prototype.constructor = di, pi.prototype = Object.create(ui.prototype), pi.prototype.constructor = pi, fi.prototype = Object.create(yt.prototype), fi.prototype.constructor = fi, mi.prototype = Object.create(Lt.prototype), mi.prototype.constructor = mi, vi.prototype = Object.create(yt.prototype), vi.prototype.constructor = vi, gi.prototype = Object.create(Lt.prototype), gi.prototype.constructor = gi, yi.prototype = Object.create(yt.prototype), yi.prototype.constructor = yi, _i.prototype = Object.create(Lt.prototype), _i.prototype.constructor = _i, xi.prototype = Object.create(yt.prototype), xi.prototype.constructor = xi, bi.prototype = Object.create(Lt.prototype), bi.prototype.constructor = bi, wi.prototype = Object.create(Lt.prototype), wi.prototype.constructor = wi, Ti.prototype = Object.create(yt.prototype), Ti.prototype.constructor = Ti, Mi.prototype = Object.create(Lt.prototype), Mi.prototype.constructor = Mi, Ei.prototype = Object.create(Ti.prototype), Ei.prototype.constructor = Ei, Si.prototype = Object.create(Mi.prototype), Si.prototype.constructor = Si, Ai.prototype = Object.create(yt.prototype), Ai.prototype.constructor = Ai, Pi.prototype = Object.create(Lt.prototype), Pi.prototype.constructor = Pi;
    var Qo = Object.freeze({
        WireframeGeometry: We,
        ParametricGeometry: Xe,
        ParametricBufferGeometry: qe,
        TetrahedronGeometry: $e,
        TetrahedronBufferGeometry: Qe,
        OctahedronGeometry: Je,
        OctahedronBufferGeometry: Ke,
        IcosahedronGeometry: ti,
        IcosahedronBufferGeometry: ei,
        DodecahedronGeometry: ii,
        DodecahedronBufferGeometry: ni,
        PolyhedronGeometry: Ye,
        PolyhedronBufferGeometry: Ze,
        TubeGeometry: ri,
        TubeBufferGeometry: si,
        TorusKnotGeometry: ai,
        TorusKnotBufferGeometry: oi,
        TorusGeometry: hi,
        TorusBufferGeometry: li,
        TextGeometry: di,
        TextBufferGeometry: pi,
        SphereGeometry: fi,
        SphereBufferGeometry: mi,
        RingGeometry: vi,
        RingBufferGeometry: gi,
        PlaneGeometry: Dt,
        PlaneBufferGeometry: zt,
        LatheGeometry: yi,
        LatheBufferGeometry: _i,
        ShapeGeometry: xi,
        ShapeBufferGeometry: bi,
        ExtrudeGeometry: ci,
        ExtrudeBufferGeometry: ui,
        EdgesGeometry: wi,
        ConeGeometry: Ei,
        ConeBufferGeometry: Si,
        CylinderGeometry: Ti,
        CylinderBufferGeometry: Mi,
        CircleGeometry: Ai,
        CircleBufferGeometry: Pi,
        BoxGeometry: Ot,
        BoxBufferGeometry: It
    });
    Ri.prototype = Object.create(K.prototype), Ri.prototype.constructor = Ri, Ri.prototype.isShadowMaterial = !0, Ci.prototype = Object.create(tt.prototype), Ci.prototype.constructor = Ci, Ci.prototype.isRawShaderMaterial = !0, Li.prototype = Object.create(K.prototype), Li.prototype.constructor = Li, Li.prototype.isMeshStandardMaterial = !0, Li.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.defines = {
            STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Oi.prototype = Object.create(Li.prototype), Oi.prototype.constructor = Oi, Oi.prototype.isMeshPhysicalMaterial = !0, Oi.prototype.copy = function(t) {
        return Li.prototype.copy.call(this, t), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
    }, Ii.prototype = Object.create(K.prototype), Ii.prototype.constructor = Ii, Ii.prototype.isMeshPhongMaterial = !0, Ii.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Di.prototype = Object.create(Ii.prototype), Di.prototype.constructor = Di, Di.prototype.isMeshToonMaterial = !0, Di.prototype.copy = function(t) {
        return Ii.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
    }, zi.prototype = Object.create(K.prototype), zi.prototype.constructor = zi, zi.prototype.isMeshNormalMaterial = !0, zi.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Ui.prototype = Object.create(K.prototype), Ui.prototype.constructor = Ui, Ui.prototype.isMeshLambertMaterial = !0, Ui.prototype.copy = function(t) {
        return K.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Ni.prototype = Object.create(ze.prototype), Ni.prototype.constructor = Ni, Ni.prototype.isLineDashedMaterial = !0, Ni.prototype.copy = function(t) {
        return ze.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
    };
    var Jo = Object.freeze({
            ShadowMaterial: Ri,
            SpriteMaterial: Re,
            RawShaderMaterial: Ci,
            ShaderMaterial: tt,
            PointsMaterial: Fe,
            MeshPhysicalMaterial: Oi,
            MeshStandardMaterial: Li,
            MeshPhongMaterial: Ii,
            MeshToonMaterial: Di,
            MeshNormalMaterial: zi,
            MeshLambertMaterial: Ui,
            MeshDepthMaterial: et,
            MeshDistanceMaterial: it,
            MeshBasicMaterial: Ut,
            LineDashedMaterial: Ni,
            LineBasicMaterial: ze,
            Material: K
        }),
        Ko = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        },
        th = new ki;
    Object.assign(Fi.prototype, {
        load: function(t, e, i, n) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t);
            var r = this,
                s = Ko.get(t);
            if (void 0 !== s) return r.manager.itemStart(t), setTimeout(function() {
                e && e(s), r.manager.itemEnd(t)
            }, 0), s;
            var a = /^data:(.*?)(;base64)?,(.*)$/,
                o = t.match(a);
            if (o) {
                var h = o[1],
                    l = !!o[2],
                    c = o[3];
                c = window.decodeURIComponent(c), l && (c = window.atob(c));
                try {
                    var u, d = (this.responseType || "").toLowerCase();
                    switch (d) {
                        case "arraybuffer":
                        case "blob":
                            u = new ArrayBuffer(c.length);
                            for (var p = new Uint8Array(u), f = 0; f < c.length; f++) p[f] = c.charCodeAt(f);
                            "blob" === d && (u = new Blob([u], {
                                type: h
                            }));
                            break;
                        case "document":
                            var m = new DOMParser;
                            u = m.parseFromString(c, h);
                            break;
                        case "json":
                            u = JSON.parse(c);
                            break;
                        default:
                            u = c
                    }
                    window.setTimeout(function() {
                        e && e(u), r.manager.itemEnd(t)
                    }, 0)
                } catch (e) {
                    window.setTimeout(function() {
                        n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
                    }, 0)
                }
            } else {
                var v = new XMLHttpRequest;
                v.open("GET", t, !0), v.addEventListener("load", function(i) {
                    var s = i.target.response;
                    Ko.add(t, s), 200 === this.status ? (e && e(s), r.manager.itemEnd(t)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), e && e(s), r.manager.itemEnd(t)) : (n && n(i), r.manager.itemEnd(t), r.manager.itemError(t))
                }, !1), void 0 !== i && v.addEventListener("progress", function(t) {
                    i(t)
                }, !1), v.addEventListener("error", function(e) {
                    n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
                }, !1), void 0 !== this.responseType && (v.responseType = this.responseType), void 0 !== this.withCredentials && (v.withCredentials = this.withCredentials), v.overrideMimeType && v.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (var g in this.requestHeader) v.setRequestHeader(g, this.requestHeader[g]);
                v.send(null)
            }
            return r.manager.itemStart(t), v
        },
        setPath: function(t) {
            return this.path = t, this
        },
        setResponseType: function(t) {
            return this.responseType = t, this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t, this
        },
        setMimeType: function(t) {
            return this.mimeType = t, this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t, this
        }
    }), Object.assign(Bi.prototype, {
        load: function(t, e, i, n) {
            var r = this,
                s = [],
                a = new je;
            a.image = s;
            var o = new Fi(this.manager);
            if (o.setPath(this.path), o.setResponseType("arraybuffer"), Array.isArray(t))
                for (var h = 0, l = 0, c = t.length; l < c; ++l) ! function(l) {
                    o.load(t[l], function(t) {
                        var i = r._parser(t, !0);
                        s[l] = {
                            width: i.width,
                            height: i.height,
                            format: i.format,
                            mipmaps: i.mipmaps
                        }, 6 === (h += 1) && (1 === i.mipmapCount && (a.minFilter = La), a.format = i.format, a.needsUpdate = !0, e && e(a))
                    }, i, n)
                }(l);
            else o.load(t, function(t) {
                var i = r._parser(t, !0);
                if (i.isCubemap)
                    for (var n = i.mipmaps.length / i.mipmapCount, o = 0; o < n; o++) {
                        s[o] = {
                            mipmaps: []
                        };
                        for (var h = 0; h < i.mipmapCount; h++) s[o].mipmaps.push(i.mipmaps[o * i.mipmapCount + h]), s[o].format = i.format, s[o].width = i.width, s[o].height = i.height
                    } else a.image.width = i.width, a.image.height = i.height, a.mipmaps = i.mipmaps;
                1 === i.mipmapCount && (a.minFilter = La), a.format = i.format, a.needsUpdate = !0, e && e(a)
            }, i, n);
            return a
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(Gi.prototype, {
        load: function(t, e, i, n) {
            var r = this,
                s = new d,
                a = new Fi(this.manager);
            return a.setResponseType("arraybuffer"), a.load(t, function(t) {
                var i = r._parser(t);
                i && (void 0 !== i.image ? s.image = i.image : void 0 !== i.data && (s.image.width = i.width, s.image.height = i.height, s.image.data = i.data), s.wrapS = void 0 !== i.wrapS ? i.wrapS : Sa, s.wrapT = void 0 !== i.wrapT ? i.wrapT : Sa, s.magFilter = void 0 !== i.magFilter ? i.magFilter : La, s.minFilter = void 0 !== i.minFilter ? i.minFilter : Ia, s.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (s.format = i.format), void 0 !== i.type && (s.type = i.type), void 0 !== i.mipmaps && (s.mipmaps = i.mipmaps), 1 === i.mipmapCount && (s.minFilter = La), s.needsUpdate = !0, e && e(s, i))
            }, i, n), s
        }
    }), Object.assign(Hi.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, e, i, n) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t);
            var r = this,
                s = Ko.get(t);
            if (void 0 !== s) return r.manager.itemStart(t), setTimeout(function() {
                e && e(s), r.manager.itemEnd(t)
            }, 0), s;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return a.addEventListener("load", function() {
                Ko.add(t, this), e && e(this), r.manager.itemEnd(t)
            }, !1), a.addEventListener("error", function(e) {
                n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
            }, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(ji.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, e, i, n) {
            var r = new p,
                s = new Hi(this.manager);
            s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
            for (var a = 0, o = 0; o < t.length; ++o) ! function(i) {
                s.load(t[i], function(t) {
                    r.images[i] = t, 6 == ++a && (r.needsUpdate = !0, e && e(r))
                }, void 0, n)
            }(o);
            return r
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(Vi.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, e, i, n) {
            var r = new Hi(this.manager);
            r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
            var a = new s;
            return a.image = r.load(t, function() {
                var i = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                a.format = i ? qa : Ya, a.needsUpdate = !0, void 0 !== e && e(a)
            }, i, n), a
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Wi.prototype = Object.assign(Object.create(dt.prototype), {
        constructor: Wi,
        isLight: !0,
        copy: function(t) {
            return dt.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
        },
        toJSON: function(t) {
            var e = dt.prototype.toJSON.call(this, t);
            return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), Xi.prototype = Object.assign(Object.create(Wi.prototype), {
        constructor: Xi,
        isHemisphereLight: !0,
        copy: function(t) {
            return Wi.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
        }
    }), Object.assign(qi.prototype, {
        copy: function(t) {
            return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var t = {};
            return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
        }
    }), Yi.prototype = Object.assign(Object.create(qi.prototype), {
        constructor: Yi,
        isSpotLightShadow: !0,
        update: function(t) {
            var e = this.camera,
                i = 2 * Oo.RAD2DEG * t.angle,
                n = this.mapSize.width / this.mapSize.height,
                r = t.distance || e.far;
            i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix())
        }
    }), Zi.prototype = Object.assign(Object.create(Wi.prototype), {
        constructor: Zi,
        isSpotLight: !0,
        copy: function(t) {
            return Wi.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), $i.prototype = Object.assign(Object.create(Wi.prototype), {
        constructor: $i,
        isPointLight: !0,
        copy: function(t) {
            return Wi.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
        }
    }), Qi.prototype = Object.assign(Object.create(qi.prototype), {
        constructor: Qi
    }), Ji.prototype = Object.assign(Object.create(Wi.prototype), {
        constructor: Ji,
        isDirectionalLight: !0,
        copy: function(t) {
            return Wi.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), Ki.prototype = Object.assign(Object.create(Wi.prototype), {
        constructor: Ki,
        isAmbientLight: !0
    }), tn.prototype = Object.assign(Object.create(Wi.prototype), {
        constructor: tn,
        isRectAreaLight: !0,
        copy: function(t) {
            return Wi.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
        },
        toJSON: function(t) {
            var e = Wi.prototype.toJSON.call(this, t);
            return e.object.width = this.width, e.object.height = this.height, e
        }
    });
    var eh = {
        arraySlice: function(t, e, i) {
            return eh.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
        },
        convertArray: function(t, e, i) {
            return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            function e(e, i) {
                return t[e] - t[i]
            }
            for (var i = t.length, n = new Array(i), r = 0; r !== i; ++r) n[r] = r;
            return n.sort(e), n
        },
        sortedArray: function(t, e, i) {
            for (var n = t.length, r = new t.constructor(n), s = 0, a = 0; a !== n; ++s)
                for (var o = i[s] * e, h = 0; h !== e; ++h) r[a++] = t[o + h];
            return r
        },
        flattenJSON: function(t, e, i, n) {
            for (var r = 1, s = t[0]; void 0 !== s && void 0 === s[n];) s = t[r++];
            if (void 0 !== s) {
                var a = s[n];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            a = s[n], void 0 !== a && (e.push(s.time), i.push.apply(i, a)), s = t[r++]
                        } while (void 0 !== s);
                    else if (void 0 !== a.toArray)
                    do {
                        a = s[n], void 0 !== a && (e.push(s.time), a.toArray(i, i.length)), s = t[r++]
                    } while (void 0 !== s);
                else
                    do {
                        a = s[n], void 0 !== a && (e.push(s.time), i.push(a)), s = t[r++]
                    } while (void 0 !== s)
            }
        }
    };
    Object.assign(en.prototype, {
            evaluate: function(t) {
                var e = this.parameterPositions,
                    i = this._cachedIndex,
                    n = e[i],
                    r = e[i - 1];
                t: {
                    e: {
                        var s;i: {
                            n: if (!(t < n)) {
                                for (var a = i + 2;;) {
                                    if (void 0 === n) {
                                        if (t < r) break n;
                                        return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r)
                                    }
                                    if (i === a) break;
                                    if (r = n, n = e[++i], t < n) break e
                                }
                                s = e.length;
                                break i
                            } {
                                if (t >= r) break t;
                                var o = e[1];
                                t < o && (i = 2, r = o);
                                for (var a = i - 2;;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                    if (i === a) break;
                                    if (n = r, r = e[--i - 1], t >= r) break e
                                }
                                s = i, i = 0
                            }
                        }
                        for (; i < s;) {
                            var h = i + s >>> 1;
                            t < e[h] ? s = h : i = h + 1
                        }
                        if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                        if (void 0 === n) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, t)
                    }
                    this._cachedIndex = i,
                    this.intervalChanged_(i, r, n)
                }
                return this.interpolate_(i, r, t, n)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, s = 0; s !== n; ++s) e[s] = i[r + s];
                return e
            },
            interpolate_: function(t, e, i, n) {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function(t, e, i) {}
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(en.prototype, {
            beforeStart_: en.prototype.copySampleValue_,
            afterEnd_: en.prototype.copySampleValue_
        }), nn.prototype = Object.assign(Object.create(en.prototype), {
            constructor: nn,
            DefaultSettings_: {
                endingStart: vo,
                endingEnd: vo
            },
            intervalChanged_: function(t, e, i) {
                var n = this.parameterPositions,
                    r = t - 2,
                    s = t + 1,
                    a = n[r],
                    o = n[s];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case go:
                        r = t, a = 2 * e - i;
                        break;
                    case yo:
                        r = n.length - 2, a = e + n[r] - n[r + 1];
                        break;
                    default:
                        r = t, a = i
                }
                if (void 0 === o) switch (this.getSettings_().endingEnd) {
                    case go:
                        s = t, o = 2 * i - e;
                        break;
                    case yo:
                        s = 1, o = i + n[1] - n[0];
                        break;
                    default:
                        s = t - 1, o = e
                }
                var h = .5 * (i - e),
                    l = this.valueSize;
                this._weightPrev = h / (e - a), this._weightNext = h / (o - i), this._offsetPrev = r * l, this._offsetNext = s * l
            },
            interpolate_: function(t, e, i, n) {
                for (var r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = t * a, h = o - a, l = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (i - e) / (n - e), f = p * p, m = f * p, v = -u * m + 2 * u * f - u * p, g = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, _ = d * m - d * f, x = 0; x !== a; ++x) r[x] = v * s[l + x] + g * s[h + x] + y * s[o + x] + _ * s[c + x];
                return r
            }
        }), rn.prototype = Object.assign(Object.create(en.prototype), {
            constructor: rn,
            interpolate_: function(t, e, i, n) {
                for (var r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = t * a, h = o - a, l = (i - e) / (n - e), c = 1 - l, u = 0; u !== a; ++u) r[u] = s[h + u] * c + s[o + u] * l;
                return r
            }
        }), sn.prototype = Object.assign(Object.create(en.prototype), {
            constructor: sn,
            interpolate_: function(t, e, i, n) {
                return this.copySampleValue_(t - 1)
            }
        });
    var ih;
    ih = {
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: fo,
        InterpolantFactoryMethodDiscrete: function(t) {
            return new sn(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodLinear: function(t) {
            return new rn(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: function(t) {
            return new nn(this.times, this.values, this.getValueSize(), t)
        },
        setInterpolation: function(t) {
            var e;
            switch (t) {
                case po:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case fo:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case mo:
                    e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation) throw new Error(i);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return void console.warn("THREE.KeyframeTrackPrototype:", i)
            }
            this.createInterpolant = e
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return po;
                case this.InterpolantFactoryMethodLinear:
                    return fo;
                case this.InterpolantFactoryMethodSmooth:
                    return mo
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(t) {
            if (0 !== t)
                for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
            return this
        },
        scale: function(t) {
            if (1 !== t)
                for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
            return this
        },
        trim: function(t, e) {
            for (var i = this.times, n = i.length, r = 0, s = n - 1; r !== n && i[r] < t;) ++r;
            for (; - 1 !== s && i[s] > e;) --s;
            if (++s, 0 !== r || s !== n) {
                r >= s && (s = Math.max(s, 1), r = s - 1);
                var a = this.getValueSize();
                this.times = eh.arraySlice(i, r, s), this.values = eh.arraySlice(this.values, r * a, s * a)
            }
            return this
        },
        validate: function() {
            var t = !0,
                e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrackPrototype: Invalid value size in track.", this), t = !1);
            var i = this.times,
                n = this.values,
                r = i.length;
            0 === r && (console.error("THREE.KeyframeTrackPrototype: Track is empty.", this), t = !1);
            for (var s = null, a = 0; a !== r; a++) {
                var o = i[a];
                if ("number" == typeof o && isNaN(o)) {
                    console.error("THREE.KeyframeTrackPrototype: Time is not a valid number.", this, a, o), t = !1;
                    break
                }
                if (null !== s && s > o) {
                    console.error("THREE.KeyframeTrackPrototype: Out of order keys.", this, a, o, s), t = !1;
                    break
                }
                s = o
            }
            if (void 0 !== n && eh.isTypedArray(n))
                for (var a = 0, h = n.length; a !== h; ++a) {
                    var l = n[a];
                    if (isNaN(l)) {
                        console.error("THREE.KeyframeTrackPrototype: Value is not a valid number.", this, a, l), t = !1;
                        break
                    }
                }
            return t
        },
        optimize: function() {
            for (var t = this.times, e = this.values, i = this.getValueSize(), n = this.getInterpolation() === mo, r = 1, s = t.length - 1, a = 1; a < s; ++a) {
                var o = !1,
                    h = t[a];
                if (h !== t[a + 1] && (1 !== a || h !== h[0]))
                    if (n) o = !0;
                    else
                        for (var l = a * i, c = l - i, u = l + i, d = 0; d !== i; ++d) {
                            var p = e[l + d];
                            if (p !== e[c + d] || p !== e[u + d]) {
                                o = !0;
                                break
                            }
                        }
                if (o) {
                    if (a !== r) {
                        t[r] = t[a];
                        for (var f = a * i, m = r * i, d = 0; d !== i; ++d) e[m + d] = e[f + d]
                    }++r
                }
            }
            if (s > 0) {
                t[r] = t[s];
                for (var f = s * i, m = r * i, d = 0; d !== i; ++d) e[m + d] = e[f + d];
                ++r
            }
            return r !== t.length && (this.times = eh.arraySlice(t, 0, r), this.values = eh.arraySlice(e, 0, r * i)), this
        }
    }, on.prototype = Object.assign(Object.create(ih), {
        constructor: on,
        ValueTypeName: "vector"
    }), hn.prototype = Object.assign(Object.create(en.prototype), {
        constructor: hn,
        interpolate_: function(t, e, i, n) {
            for (var r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = t * a, h = (i - e) / (n - e), c = o + a; o !== c; o += 4) l.slerpFlat(r, 0, s, o - a, s, o, h);
            return r
        }
    }), ln.prototype = Object.assign(Object.create(ih), {
        constructor: ln,
        ValueTypeName: "quaternion",
        DefaultInterpolation: fo,
        InterpolantFactoryMethodLinear: function(t) {
            return new hn(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), cn.prototype = Object.assign(Object.create(ih), {
        constructor: cn,
        ValueTypeName: "number"
    }), un.prototype = Object.assign(Object.create(ih), {
        constructor: un,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: po,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), dn.prototype = Object.assign(Object.create(ih), {
        constructor: dn,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: po,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), pn.prototype = Object.assign(Object.create(ih), {
        constructor: pn,
        ValueTypeName: "color"
    }), fn.prototype = ih, ih.constructor = fn, Object.assign(fn, {
        parse: function(t) {
            if (void 0 === t.type) throw new Error("track type undefined, can not parse");
            var e = fn._getTrackTypeForValueTypeName(t.type);
            if (void 0 === t.times) {
                var i = [],
                    n = [];
                eh.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        },
        toJSON: function(t) {
            var e, i = t.constructor;
            if (void 0 !== i.toJSON) e = i.toJSON(t);
            else {
                e = {
                    name: t.name,
                    times: eh.convertArray(t.times, Array),
                    values: eh.convertArray(t.values, Array)
                };
                var n = t.getInterpolation();
                n !== t.DefaultInterpolation && (e.interpolation = n)
            }
            return e.type = t.ValueTypeName, e
        },
        _getTrackTypeForValueTypeName: function(t) {
            switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return cn;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return on;
                case "color":
                    return pn;
                case "quaternion":
                    return ln;
                case "bool":
                case "boolean":
                    return dn;
                case "string":
                    return un
            }
            throw new Error("Unsupported typeName: " + t)
        }
    }), Object.assign(mn, {
        parse: function(t) {
            for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, s = i.length; r !== s; ++r) e.push(fn.parse(i[r]).scale(n));
            return new mn(t.name, t.duration, e)
        },
        toJSON: function(t) {
            for (var e = [], i = t.tracks, n = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e
                }, r = 0, s = i.length; r !== s; ++r) e.push(fn.toJSON(i[r]));
            return n
        },
        CreateFromMorphTargetSequence: function(t, e, i, n) {
            for (var r = e.length, s = [], a = 0; a < r; a++) {
                var o = [],
                    h = [];
                o.push((a + r - 1) % r, a, (a + 1) % r), h.push(0, 1, 0);
                var l = eh.getKeyframeOrder(o);
                o = eh.sortedArray(o, 1, l), h = eh.sortedArray(h, 1, l), n || 0 !== o[0] || (o.push(r), h.push(h[0])), s.push(new cn(".morphTargetInfluences[" + e[a].name + "]", o, h).scale(1 / i))
            }
            return new mn(t, -1, s)
        },
        findByName: function(t, e) {
            var i = t;
            if (!Array.isArray(t)) {
                var n = t;
                i = n.geometry && n.geometry.animations || n.animations
            }
            for (var r = 0; r < i.length; r++)
                if (i[r].name === e) return i[r];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(t, e, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, s = 0, a = t.length; s < a; s++) {
                var o = t[s],
                    h = o.name.match(r);
                if (h && h.length > 1) {
                    var l = h[1],
                        c = n[l];
                    c || (n[l] = c = []), c.push(o)
                }
            }
            var u = [];
            for (var l in n) u.push(mn.CreateFromMorphTargetSequence(l, n[l], e, i));
            return u
        },
        parseAnimation: function(t, e) {
            if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            for (var i = function(t, e, i, n, r) {
                    if (0 !== i.length) {
                        var s = [],
                            a = [];
                        eh.flattenJSON(i, s, a, n), 0 !== s.length && r.push(new t(e, s, a))
                    }
                }, n = [], r = t.name || "default", s = t.length || -1, a = t.fps || 30, o = t.hierarchy || [], h = 0; h < o.length; h++) {
                var l = o[h].keys;
                if (l && 0 !== l.length)
                    if (l[0].morphTargets) {
                        for (var c = {}, u = 0; u < l.length; u++)
                            if (l[u].morphTargets)
                                for (var d = 0; d < l[u].morphTargets.length; d++) c[l[u].morphTargets[d]] = -1;
                        for (var p in c) {
                            for (var f = [], m = [], d = 0; d !== l[u].morphTargets.length; ++d) {
                                var v = l[u];
                                f.push(v.time), m.push(v.morphTarget === p ? 1 : 0)
                            }
                            n.push(new cn(".morphTargetInfluence[" + p + "]", f, m))
                        }
                        s = c.length * (a || 1)
                    } else {
                        var g = ".bones[" + e[h].name + "]";
                        i(on, g + ".position", l, "pos", n), i(ln, g + ".quaternion", l, "rot", n), i(on, g + ".scale", l, "scl", n)
                    }
            }
            return 0 === n.length ? null : new mn(r, s, n)
        }
    }), Object.assign(mn.prototype, {
        resetDuration: function() {
            for (var t = this.tracks, e = 0, i = 0, n = t.length; i !== n; ++i) {
                var r = this.tracks[i];
                e = Math.max(e, r.times[r.times.length - 1])
            }
            this.duration = e
        },
        trim: function() {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
            return this
        },
        optimize: function() {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
            return this
        }
    }), Object.assign(vn.prototype, {
        load: function(t, e, i, n) {
            var r = this;
            new Fi(r.manager).load(t, function(t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        },
        setTextures: function(t) {
            this.textures = t
        },
        parse: function(t) {
            function e(t) {
                return void 0 === i[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), i[t]
            }
            var i = this.textures,
                n = new Jo[t.type];
            if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular), void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t.clearCoat && (n.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (n.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.uniforms && (n.uniforms = t.uniforms), void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !== t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t.flatShading), void 0 !== t.blending && (n.blending = t.blending), void 0 !== t.side && (n.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.skinning && (n.skinning = t.skinning), void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets), void 0 !== t.dithering && (n.dithering = t.dithering), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = e(t.map)), void 0 !== t.alphaMap && (n.alphaMap = e(t.alphaMap), n.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t.normalMap && (n.normalMap = e(t.normalMap)), void 0 !== t.normalScale) {
                var s = t.normalScale;
                !1 === Array.isArray(s) && (s = [s, s]), n.normalScale = (new r).fromArray(s)
            }
            return void 0 !== t.displacementMap && (n.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (n.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (n.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (n.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (n.specularMap = e(t.specularMap)), void 0 !== t.envMap && (n.envMap = e(t.envMap)), void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n.gradientMap = e(t.gradientMap)), n
        }
    }), Object.assign(gn.prototype, {
        load: function(t, e, i, n) {
            var r = this;
            new Fi(r.manager).load(t, function(t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        },
        parse: function(t) {
            var e = new Lt,
                i = t.data.index;
            if (void 0 !== i) {
                var n = new nh[i.type](i.array);
                e.setIndex(new _t(n, 1))
            }
            var r = t.data.attributes;
            for (var s in r) {
                var a = r[s],
                    n = new nh[a.type](a.array);
                e.addAttribute(s, new _t(n, a.itemSize, a.normalized))
            }
            var o = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== o)
                for (var h = 0, l = o.length; h !== l; ++h) {
                    var u = o[h];
                    e.addGroup(u.start, u.count, u.materialIndex)
                }
            var d = t.data.boundingSphere;
            if (void 0 !== d) {
                var p = new c;
                void 0 !== d.center && p.fromArray(d.center), e.boundingSphere = new rt(p, d.radius)
            }
            return e
        }
    });
    var nh = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    yn.Handlers = {
        handlers: [],
        add: function(t, e) {
            this.handlers.push(t, e)
        },
        get: function(t) {
            for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                var r = e[i],
                    s = e[i + 1];
                if (r.test(t)) return s
            }
            return null
        }
    }, Object.assign(yn.prototype, {
        crossOrigin: void 0,
        extractUrlBase: function(t) {
            var e = t.split("/");
            return 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
        },
        initMaterials: function(t, e, i) {
            for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
            return n
        },
        createMaterial: function() {
            var t = {
                    NoBlending: Is,
                    NormalBlending: Ds,
                    AdditiveBlending: zs,
                    SubtractiveBlending: Us,
                    MultiplyBlending: Ns,
                    CustomBlending: ks
                },
                e = new Y,
                i = new Vi,
                n = new vn;
            return function(r, s, a) {
                function o(t, e, n, r, o) {
                    var l, c = s + t,
                        u = yn.Handlers.get(c);
                    null !== u ? l = u.load(c) : (i.setCrossOrigin(a), l = i.load(c)), void 0 !== e && (l.repeat.fromArray(e), 1 !== e[0] && (l.wrapS = Ea), 1 !== e[1] && (l.wrapT = Ea)), void 0 !== n && l.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (l.wrapS = Ea), "mirror" === r[0] && (l.wrapS = Aa), "repeat" === r[1] && (l.wrapT = Ea), "mirror" === r[1] && (l.wrapT = Aa)), void 0 !== o && (l.anisotropy = o);
                    var d = Oo.generateUUID();
                    return h[d] = l, d
                }
                var h = {},
                    l = {
                        uuid: Oo.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                for (var c in r) {
                    var u = r[c];
                    switch (c) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            l.name = u;
                            break;
                        case "blending":
                            l.blending = t[u];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", c, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            l.color = e.fromArray(u).getHex();
                            break;
                        case "colorSpecular":
                            l.specular = e.fromArray(u).getHex();
                            break;
                        case "colorEmissive":
                            l.emissive = e.fromArray(u).getHex();
                            break;
                        case "specularCoef":
                            l.shininess = u;
                            break;
                        case "shading":
                            "basic" === u.toLowerCase() && (l.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (l.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (l.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            l.map = o(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            l.emissiveMap = o(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            l.lightMap = o(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            l.aoMap = o(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            l.bumpMap = o(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            l.bumpScale = u;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            l.normalMap = o(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            l.normalScale = [u, u];
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            l.specularMap = o(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            l.metalnessMap = o(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            l.roughnessMap = o(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            l.alphaMap = o(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            l.side = Ss;
                            break;
                        case "doubleSided":
                            l.side = As;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), l.opacity = u;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            l[c] = u;
                            break;
                        case "vertexColors":
                            !0 === u && (l.vertexColors = Os), "face" === u && (l.vertexColors = Ls);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", c, u)
                    }
                }
                return "MeshBasicMaterial" === l.type && delete l.emissive, "MeshPhongMaterial" !== l.type && delete l.specular, l.opacity < 1 && (l.transparent = !0), n.setTextures(h), n.parse(l)
            }
        }()
    }), Object.assign(_n.prototype, {
        load: function(t, e, i, n) {
            var r = this,
                s = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : yn.prototype.extractUrlBase(t),
                a = new Fi(this.manager);
            a.setWithCredentials(this.withCredentials), a.load(t, function(i) {
                var n = JSON.parse(i),
                    a = n.metadata;
                if (void 0 !== a) {
                    var o = a.type;
                    if (void 0 !== o) {
                        if ("object" === o.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === o.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                    }
                }
                var h = r.parse(n, s);
                e(h.geometry, h.materials)
            }, i, n)
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        parse: function() {
            function t(t, e) {
                function i(t, e) {
                    return t & 1 << e
                }
                var n, s, a, o, h, l, u, d, p, f, m, v, g, y, _, x, b, w, T, M, E, S, A, P, R, C, L, O = t.faces,
                    I = t.vertices,
                    D = t.normals,
                    z = t.colors,
                    U = t.scale,
                    N = 0;
                if (void 0 !== t.uvs) {
                    for (n = 0; n < t.uvs.length; n++) t.uvs[n].length && N++;
                    for (n = 0; n < N; n++) e.faceVertexUvs[n] = []
                }
                for (o = 0, h = I.length; o < h;) w = new c, w.x = I[o++] * U, w.y = I[o++] * U, w.z = I[o++] * U, e.vertices.push(w);
                for (o = 0, h = O.length; o < h;)
                    if (f = O[o++], m = i(f, 0), v = i(f, 1), g = i(f, 3), y = i(f, 4), _ = i(f, 5), x = i(f, 6), b = i(f, 7), m) {
                        if (M = new vt, M.a = O[o], M.b = O[o + 1], M.c = O[o + 3], E = new vt, E.a = O[o + 1], E.b = O[o + 2], E.c = O[o + 3], o += 4, v && (p = O[o++], M.materialIndex = p, E.materialIndex = p), a = e.faces.length, g)
                            for (n = 0; n < N; n++)
                                for (P = t.uvs[n], e.faceVertexUvs[n][a] = [], e.faceVertexUvs[n][a + 1] = [], s = 0; s < 4; s++) d = O[o++], C = P[2 * d], L = P[2 * d + 1], R = new r(C, L), 2 !== s && e.faceVertexUvs[n][a].push(R), 0 !== s && e.faceVertexUvs[n][a + 1].push(R);
                        if (y && (u = 3 * O[o++], M.normal.set(D[u++], D[u++], D[u]), E.normal.copy(M.normal)), _)
                            for (n = 0; n < 4; n++) u = 3 * O[o++], A = new c(D[u++], D[u++], D[u]), 2 !== n && M.vertexNormals.push(A), 0 !== n && E.vertexNormals.push(A);
                        if (x && (l = O[o++], S = z[l], M.color.setHex(S), E.color.setHex(S)), b)
                            for (n = 0; n < 4; n++) l = O[o++], S = z[l], 2 !== n && M.vertexColors.push(new Y(S)), 0 !== n && E.vertexColors.push(new Y(S));
                        e.faces.push(M), e.faces.push(E)
                    } else {
                        if (T = new vt, T.a = O[o++], T.b = O[o++], T.c = O[o++], v && (p = O[o++], T.materialIndex = p), a = e.faces.length, g)
                            for (n = 0; n < N; n++)
                                for (P = t.uvs[n], e.faceVertexUvs[n][a] = [], s = 0; s < 3; s++) d = O[o++], C = P[2 * d], L = P[2 * d + 1], R = new r(C, L), e.faceVertexUvs[n][a].push(R);
                        if (y && (u = 3 * O[o++], T.normal.set(D[u++], D[u++], D[u])), _)
                            for (n = 0; n < 3; n++) u = 3 * O[o++], A = new c(D[u++], D[u++], D[u]), T.vertexNormals.push(A);
                        if (x && (l = O[o++], T.color.setHex(z[l])), b)
                            for (n = 0; n < 3; n++) l = O[o++], T.vertexColors.push(new Y(z[l]));
                        e.faces.push(T)
                    }
            }

            function e(t, e) {
                var i = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                if (t.skinWeights)
                    for (var n = 0, r = t.skinWeights.length; n < r; n += i) {
                        var s = t.skinWeights[n],
                            o = i > 1 ? t.skinWeights[n + 1] : 0,
                            h = i > 2 ? t.skinWeights[n + 2] : 0,
                            l = i > 3 ? t.skinWeights[n + 3] : 0;
                        e.skinWeights.push(new a(s, o, h, l))
                    }
                if (t.skinIndices)
                    for (var n = 0, r = t.skinIndices.length; n < r; n += i) {
                        var c = t.skinIndices[n],
                            u = i > 1 ? t.skinIndices[n + 1] : 0,
                            d = i > 2 ? t.skinIndices[n + 2] : 0,
                            p = i > 3 ? t.skinIndices[n + 3] : 0;
                        e.skinIndices.push(new a(c, u, d, p))
                    }
                e.bones = t.bones, e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
            }

            function i(t, e) {
                var i = t.scale;
                if (void 0 !== t.morphTargets)
                    for (var n = 0, r = t.morphTargets.length; n < r; n++) {
                        e.morphTargets[n] = {}, e.morphTargets[n].name = t.morphTargets[n].name, e.morphTargets[n].vertices = [];
                        for (var s = e.morphTargets[n].vertices, a = t.morphTargets[n].vertices, o = 0, h = a.length; o < h; o += 3) {
                            var l = new c;
                            l.x = a[o] * i, l.y = a[o + 1] * i, l.z = a[o + 2] * i, s.push(l)
                        }
                    }
                if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    for (var u = e.faces, d = t.morphColors[0].colors, n = 0, r = u.length; n < r; n++) u[n].color.fromArray(d, 3 * n)
                }
            }

            function n(t, e) {
                var i = [],
                    n = [];
                void 0 !== t.animation && n.push(t.animation), void 0 !== t.animations && (t.animations.length ? n = n.concat(t.animations) : n.push(t.animations));
                for (var r = 0; r < n.length; r++) {
                    var s = mn.parseAnimation(n[r], e.bones);
                    s && i.push(s)
                }
                if (e.morphTargets) {
                    var a = mn.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                    i = i.concat(a)
                }
                i.length > 0 && (e.animations = i)
            }
            return function(r, s) {
                void 0 !== r.data && (r = r.data), void 0 !== r.scale ? r.scale = 1 / r.scale : r.scale = 1;
                var a = new yt;
                return t(r, a), e(r, a), i(r, a), n(r, a), a.computeFaceNormals(), a.computeBoundingSphere(), void 0 === r.materials || 0 === r.materials.length ? {
                    geometry: a
                } : {
                    geometry: a,
                    materials: yn.prototype.initMaterials(r.materials, s, this.crossOrigin)
                }
            }
        }()
    }), Object.assign(xn.prototype, {
        load: function(t, e, i, n) {
            "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
            var r = this;
            new Fi(r.manager).load(t, function(i) {
                var s = null;
                try {
                    s = JSON.parse(i)
                } catch (e) {
                    return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                }
                var a = s.metadata;
                if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) return void console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.");
                r.parse(s, e)
            }, i, n)
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        parse: function(t, e) {
            var i = this.parseGeometries(t.geometries),
                n = this.parseImages(t.images, function() {
                    void 0 !== e && e(a)
                }),
                r = this.parseTextures(t.textures, n),
                s = this.parseMaterials(t.materials, r),
                a = this.parseObject(t.object, i, s);
            return t.animations && (a.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(a), a
        },
        parseGeometries: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var i = new _n, n = new gn, r = 0, s = t.length; r < s; r++) {
                    var a, o = t[r];
                    switch (o.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            a = new Qo[o.type](o.width, o.height, o.widthSegments, o.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            a = new Qo[o.type](o.width, o.height, o.depth, o.widthSegments, o.heightSegments, o.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            a = new Qo[o.type](o.radius, o.segments, o.thetaStart, o.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            a = new Qo[o.type](o.radiusTop, o.radiusBottom, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            a = new Qo[o.type](o.radius, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            a = new Qo[o.type](o.radius, o.widthSegments, o.heightSegments, o.phiStart, o.phiLength, o.thetaStart, o.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "IcosahedronGeometry":
                        case "OctahedronGeometry":
                        case "TetrahedronGeometry":
                            a = new Qo[o.type](o.radius, o.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            a = new Qo[o.type](o.innerRadius, o.outerRadius, o.thetaSegments, o.phiSegments, o.thetaStart, o.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            a = new Qo[o.type](o.radius, o.tube, o.radialSegments, o.tubularSegments, o.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            a = new Qo[o.type](o.radius, o.tube, o.tubularSegments, o.radialSegments, o.p, o.q);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            a = new Qo[o.type](o.points, o.segments, o.phiStart, o.phiLength);
                            break;
                        case "BufferGeometry":
                            a = n.parse(o);
                            break;
                        case "Geometry":
                            a = i.parse(o, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + o.type + '"');
                            continue
                    }
                    a.uuid = o.uuid, void 0 !== o.name && (a.name = o.name), e[o.uuid] = a
                }
            return e
        },
        parseMaterials: function(t, e) {
            var i = {};
            if (void 0 !== t) {
                var n = new vn;
                n.setTextures(e);
                for (var r = 0, s = t.length; r < s; r++) {
                    var a = t[r];
                    if ("MultiMaterial" === a.type) {
                        for (var o = [], h = 0; h < a.materials.length; h++) o.push(n.parse(a.materials[h]));
                        i[a.uuid] = o
                    } else i[a.uuid] = n.parse(a)
                }
            }
            return i
        },
        parseAnimations: function(t) {
            for (var e = [], i = 0; i < t.length; i++) {
                var n = mn.parse(t[i]);
                e.push(n)
            }
            return e
        },
        parseImages: function(t, e) {
            var i = this,
                n = {};
            if (void 0 !== t && t.length > 0) {
                var r = new ki(e),
                    s = new Hi(r);
                s.setCrossOrigin(this.crossOrigin);
                for (var a = 0, o = t.length; a < o; a++) {
                    var h = t[a],
                        l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : i.texturePath + h.url;
                    n[h.uuid] = function(t) {
                        return i.manager.itemStart(t), s.load(t, function() {
                            i.manager.itemEnd(t)
                        }, void 0, function() {
                            i.manager.itemEnd(t), i.manager.itemError(t)
                        })
                    }(l)
                }
            }
            return n
        },
        parseTextures: function(t, e) {
            function i(t, e) {
                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
            }
            var n = {};
            if (void 0 !== t)
                for (var r = 0, a = t.length; r < a; r++) {
                    var o = t[r];
                    void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                    var h = new s(e[o.image]);
                    h.needsUpdate = !0, h.uuid = o.uuid, void 0 !== o.name && (h.name = o.name), void 0 !== o.mapping && (h.mapping = i(o.mapping, rh)), void 0 !== o.offset && h.offset.fromArray(o.offset), void 0 !== o.repeat && h.repeat.fromArray(o.repeat), void 0 !== o.wrap && (h.wrapS = i(o.wrap[0], sh), h.wrapT = i(o.wrap[1], sh)), void 0 !== o.minFilter && (h.minFilter = i(o.minFilter, ah)), void 0 !== o.magFilter && (h.magFilter = i(o.magFilter, ah)), void 0 !== o.anisotropy && (h.anisotropy = o.anisotropy), void 0 !== o.flipY && (h.flipY = o.flipY), n[o.uuid] = h
                }
            return n
        },
        parseObject: function() {
            var t = new u;
            return function(e, i, n) {
                function r(t) {
                    return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), i[t]
                }

                function s(t) {
                    if (void 0 !== t) {
                        if (Array.isArray(t)) {
                            for (var e = [], i = 0, r = t.length; i < r; i++) {
                                var s = t[i];
                                void 0 === n[s] && console.warn("THREE.ObjectLoader: Undefined material", s), e.push(n[s])
                            }
                            return e
                        }
                        return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                    }
                }
                var a;
                switch (e.type) {
                    case "Scene":
                        a = new Ae, void 0 !== e.background && Number.isInteger(e.background) && (a.background = new Y(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new Se(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new Ee(e.fog.color, e.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        a = new mt(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                        break;
                    case "OrthographicCamera":
                        a = new ft(e.left, e.right, e.top, e.bottom, e.near, e.far);
                        break;
                    case "AmbientLight":
                        a = new Ki(e.color, e.intensity);
                        break;
                    case "DirectionalLight":
                        a = new Ji(e.color, e.intensity);
                        break;
                    case "PointLight":
                        a = new $i(e.color, e.intensity, e.distance, e.decay);
                        break;
                    case "RectAreaLight":
                        a = new tn(e.color, e.intensity, e.width, e.height);
                        break;
                    case "SpotLight":
                        a = new Zi(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                        break;
                    case "HemisphereLight":
                        a = new Xi(e.color, e.groundColor, e.intensity);
                        break;
                    case "SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                    case "Mesh":
                        var o = r(e.geometry),
                            h = s(e.material);
                        a = o.bones && o.bones.length > 0 ? new De(o, h) : new Bt(o, h);
                        break;
                    case "LOD":
                        a = new Le;
                        break;
                    case "Line":
                        a = new Ue(r(e.geometry), s(e.material), e.mode);
                        break;
                    case "LineLoop":
                        a = new ke(r(e.geometry), s(e.material));
                        break;
                    case "LineSegments":
                        a = new Ne(r(e.geometry), s(e.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        a = new Be(r(e.geometry), s(e.material));
                        break;
                    case "Sprite":
                        a = new Ce(s(e.material));
                        break;
                    case "Group":
                        a = new Ge;
                        break;
                    default:
                        a = new dt
                }
                if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (t.fromArray(e.matrix), t.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.children)
                    for (var l = e.children, c = 0; c < l.length; c++) a.add(this.parseObject(l[c], i, n));
                if ("LOD" === e.type)
                    for (var u = e.levels, d = 0; d < u.length; d++) {
                        var p = u[d],
                            f = a.getObjectByProperty("uuid", p.object);
                        void 0 !== f && a.addLevel(f, p.distance)
                    }
                return a
            }
        }()
    });
    var rh = {
            UVMapping: ga,
            CubeReflectionMapping: ya,
            CubeRefractionMapping: _a,
            EquirectangularReflectionMapping: xa,
            EquirectangularRefractionMapping: ba,
            SphericalReflectionMapping: wa,
            CubeUVReflectionMapping: Ta,
            CubeUVRefractionMapping: Ma
        },
        sh = {
            RepeatWrapping: Ea,
            ClampToEdgeWrapping: Sa,
            MirroredRepeatWrapping: Aa
        },
        ah = {
            NearestFilter: Pa,
            NearestMipMapNearestFilter: Ra,
            NearestMipMapLinearFilter: Ca,
            LinearFilter: La,
            LinearMipMapNearestFilter: Oa,
            LinearMipMapLinearFilter: Ia
        };
    Object.assign(Ln.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function(t) {
            var e = this.getUtoTmapping(t);
            return this.getPoint(e)
        },
        getPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
            return e
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
            return e
        },
        getLength: function() {
            var t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, i, n = [],
                r = this.getPoint(0),
                s = 0;
            for (n.push(0), i = 1; i <= t; i++) e = this.getPoint(i / t), s += e.distanceTo(r), n.push(s), r = e;
            return this.cacheArcLengths = n, n
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            var i, n = this.getLengths(),
                r = 0,
                s = n.length;
            i = e || t * n[s - 1];
            for (var a, o = 0, h = s - 1; o <= h;)
                if (r = Math.floor(o + (h - o) / 2), (a = n[r] - i) < 0) o = r + 1;
                else {
                    if (!(a > 0)) {
                        h = r;
                        break
                    }
                    h = r - 1
                }
            if (r = h, n[r] === i) return r / (s - 1);
            var l = n[r];
            return (r + (i - l) / (n[r + 1] - l)) / (s - 1)
        },
        getTangent: function(t) {
            var e = t - 1e-4,
                i = t + 1e-4;
            e < 0 && (e = 0), i > 1 && (i = 1);
            var n = this.getPoint(e);
            return this.getPoint(i).clone().sub(n).normalize()
        },
        getTangentAt: function(t) {
            var e = this.getUtoTmapping(t);
            return this.getTangent(e)
        },
        computeFrenetFrames: function(t, e) {
            var i, n, r, s = new c,
                a = [],
                o = [],
                h = [],
                l = new c,
                d = new u;
            for (i = 0; i <= t; i++) n = i / t, a[i] = this.getTangentAt(n), a[i].normalize();
            o[0] = new c, h[0] = new c;
            var p = Number.MAX_VALUE,
                f = Math.abs(a[0].x),
                m = Math.abs(a[0].y),
                v = Math.abs(a[0].z);
            for (f <= p && (p = f, s.set(1, 0, 0)), m <= p && (p = m, s.set(0, 1, 0)), v <= p && s.set(0, 0, 1), l.crossVectors(a[0], s).normalize(), o[0].crossVectors(a[0], l), h[0].crossVectors(a[0], o[0]), i = 1; i <= t; i++) o[i] = o[i - 1].clone(), h[i] = h[i - 1].clone(), l.crossVectors(a[i - 1], a[i]), l.length() > Number.EPSILON && (l.normalize(), r = Math.acos(Oo.clamp(a[i - 1].dot(a[i]), -1, 1)), o[i].applyMatrix4(d.makeRotationAxis(l, r))), h[i].crossVectors(a[i], o[i]);
            if (!0 === e)
                for (r = Math.acos(Oo.clamp(o[0].dot(o[t]), -1, 1)), r /= t, a[0].dot(l.crossVectors(o[0], o[t])) > 0 && (r = -r), i = 1; i <= t; i++) o[i].applyMatrix4(d.makeRotationAxis(a[i], r * i)), h[i].crossVectors(a[i], o[i]);
            return {
                tangents: a,
                normals: o,
                binormals: h
            }
        }
    }), On.prototype = Object.create(Ln.prototype), On.prototype.constructor = On, On.prototype.isLineCurve = !0, On.prototype.getPoint = function(t) {
        if (1 === t) return this.v2.clone();
        var e = this.v2.clone().sub(this.v1);
        return e.multiplyScalar(t).add(this.v1), e
    }, On.prototype.getPointAt = function(t) {
        return this.getPoint(t)
    }, On.prototype.getTangent = function(t) {
        return this.v2.clone().sub(this.v1).normalize()
    }, In.prototype = Object.assign(Object.create(Ln.prototype), {
        constructor: In,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            var t = this.curves[0].getPoint(0),
                e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new On(e, t))
        },
        getPoint: function(t) {
            for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) {
                if (i[n] >= e) {
                    var r = i[n] - e,
                        s = this.curves[n],
                        a = s.getLength(),
                        o = 0 === a ? 0 : 1 - r / a;
                    return s.getPointAt(o)
                }
                n++
            }
            return null
        },
        getLength: function() {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
            return this.cacheLengths = t, t
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 40);
            for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
            return this.autoClose && e.push(e[0]), e
        },
        getPoints: function(t) {
            t = t || 12;
            for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                for (var s = r[n], a = s && s.isEllipseCurve ? 2 * t : s && s.isLineCurve ? 1 : s && s.isSplineCurve ? t * s.points.length : t, o = s.getPoints(a), h = 0; h < o.length; h++) {
                    var l = o[h];
                    e && e.equals(l) || (i.push(l), e = l)
                }
            return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
        },
        createPointsGeometry: function(t) {
            var e = this.getPoints(t);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(t) {
            var e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        },
        createGeometry: function(t) {
            for (var e = new yt, i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.vertices.push(new c(r.x, r.y, r.z || 0))
            }
            return e
        }
    }), Dn.prototype = Object.create(Ln.prototype), Dn.prototype.constructor = Dn, Dn.prototype.isEllipseCurve = !0, Dn.prototype.getPoint = function(t) {
        for (var e = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, n = Math.abs(i) < Number.EPSILON; i < 0;) i += e;
        for (; i > e;) i -= e;
        i < Number.EPSILON && (i = n ? 0 : e), !0 !== this.aClockwise || n || (i === e ? i = -e : i -= e);
        var s = this.aStartAngle + t * i,
            a = this.aX + this.xRadius * Math.cos(s),
            o = this.aY + this.yRadius * Math.sin(s);
        if (0 !== this.aRotation) {
            var h = Math.cos(this.aRotation),
                l = Math.sin(this.aRotation),
                c = a - this.aX,
                u = o - this.aY;
            a = c * h - u * l + this.aX, o = c * l + u * h + this.aY
        }
        return new r(a, o)
    }, zn.prototype = Object.create(Ln.prototype), zn.prototype.constructor = zn, zn.prototype.isSplineCurve = !0, zn.prototype.getPoint = function(t) {
        var e = this.points,
            i = (e.length - 1) * t,
            n = Math.floor(i),
            s = i - n,
            a = e[0 === n ? n : n - 1],
            o = e[n],
            h = e[n > e.length - 2 ? e.length - 1 : n + 1],
            l = e[n > e.length - 3 ? e.length - 1 : n + 2];
        return new r(bn(s, a.x, o.x, h.x, l.x), bn(s, a.y, o.y, h.y, l.y))
    }, Un.prototype = Object.create(Ln.prototype), Un.prototype.constructor = Un, Un.prototype.getPoint = function(t) {
        var e = this.v0,
            i = this.v1,
            n = this.v2,
            s = this.v3;
        return new r(Cn(t, e.x, i.x, n.x, s.x), Cn(t, e.y, i.y, n.y, s.y))
    }, Nn.prototype = Object.create(Ln.prototype), Nn.prototype.constructor = Nn, Nn.prototype.getPoint = function(t) {
        var e = this.v0,
            i = this.v1,
            n = this.v2;
        return new r(En(t, e.x, i.x, n.x), En(t, e.y, i.y, n.y))
    };
    var oh = Object.assign(Object.create(In.prototype), {
        fromPoints: function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
        },
        moveTo: function(t, e) {
            this.currentPoint.set(t, e)
        },
        lineTo: function(t, e) {
            var i = new On(this.currentPoint.clone(), new r(t, e));
            this.curves.push(i), this.currentPoint.set(t, e)
        },
        quadraticCurveTo: function(t, e, i, n) {
            var s = new Nn(this.currentPoint.clone(), new r(t, e), new r(i, n));
            this.curves.push(s), this.currentPoint.set(i, n)
        },
        bezierCurveTo: function(t, e, i, n, s, a) {
            var o = new Un(this.currentPoint.clone(), new r(t, e), new r(i, n), new r(s, a));
            this.curves.push(o), this.currentPoint.set(s, a)
        },
        splineThru: function(t) {
            var e = [this.currentPoint.clone()].concat(t),
                i = new zn(e);
            this.curves.push(i), this.currentPoint.copy(t[t.length - 1])
        },
        arc: function(t, e, i, n, r, s) {
            var a = this.currentPoint.x,
                o = this.currentPoint.y;
            this.absarc(t + a, e + o, i, n, r, s)
        },
        absarc: function(t, e, i, n, r, s) {
            this.absellipse(t, e, i, i, n, r, s)
        },
        ellipse: function(t, e, i, n, r, s, a, o) {
            var h = this.currentPoint.x,
                l = this.currentPoint.y;
            this.absellipse(t + h, e + l, i, n, r, s, a, o)
        },
        absellipse: function(t, e, i, n, r, s, a, o) {
            var h = new Dn(t, e, i, n, r, s, a, o);
            if (this.curves.length > 0) {
                var l = h.getPoint(0);
                l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
            }
            this.curves.push(h);
            var c = h.getPoint(1);
            this.currentPoint.copy(c)
        }
    });
    kn.prototype = oh, oh.constructor = kn, Fn.prototype = Object.assign(Object.create(oh), {
        constructor: Fn,
        getPointsHoles: function(t) {
            for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
            return e
        },
        extractAllPoints: function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        extractPoints: function(t) {
            return this.extractAllPoints(t)
        }
    }), Object.assign(Bn.prototype, {
        moveTo: function(t, e) {
            this.currentPath = new kn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
        },
        lineTo: function(t, e) {
            this.currentPath.lineTo(t, e)
        },
        quadraticCurveTo: function(t, e, i, n) {
            this.currentPath.quadraticCurveTo(t, e, i, n)
        },
        bezierCurveTo: function(t, e, i, n, r, s) {
            this.currentPath.bezierCurveTo(t, e, i, n, r, s)
        },
        splineThru: function(t) {
            this.currentPath.splineThru(t)
        },
        toShapes: function(t, e) {
            function i(t) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = t[i],
                        s = new Fn;
                    s.curves = r.curves, e.push(s)
                }
                return e
            }
            var n = $o.isClockWise,
                r = this.subPaths;
            if (0 === r.length) return [];
            if (!0 === e) return i(r);
            var s, a, o, h = [];
            if (1 === r.length) return a = r[0], o = new Fn, o.curves = a.curves, h.push(o), h;
            var l = !n(r[0].getPoints());
            l = t ? !l : l;
            var c, u = [],
                d = [],
                p = [],
                f = 0;
            d[f] = void 0, p[f] = [];
            for (var m = 0, v = r.length; m < v; m++) a = r[m], c = a.getPoints(), s = n(c), s = t ? !s : s, s ? (!l && d[f] && f++, d[f] = {
                s: new Fn,
                p: c
            }, d[f].s.curves = a.curves, l && f++, p[f] = []) : p[f].push({
                h: a,
                p: c[0]
            });
            if (!d[0]) return i(r);
            if (d.length > 1) {
                for (var g = !1, y = [], _ = 0, x = d.length; _ < x; _++) u[_] = [];
                for (var _ = 0, x = d.length; _ < x; _++)
                    for (var b = p[_], w = 0; w < b.length; w++) {
                        for (var T = b[w], M = !0, E = 0; E < d.length; E++)(function(t, e) {
                            for (var i = e.length, n = !1, r = i - 1, s = 0; s < i; r = s++) {
                                var a = e[r],
                                    o = e[s],
                                    h = o.x - a.x,
                                    l = o.y - a.y;
                                if (Math.abs(l) > Number.EPSILON) {
                                    if (l < 0 && (a = e[s], h = -h, o = e[r], l = -l), t.y < a.y || t.y > o.y) continue;
                                    if (t.y === a.y) {
                                        if (t.x === a.x) return !0
                                    } else {
                                        var c = l * (t.x - a.x) - h * (t.y - a.y);
                                        if (0 === c) return !0;
                                        if (c < 0) continue;
                                        n = !n
                                    }
                                } else {
                                    if (t.y !== a.y) continue;
                                    if (o.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= o.x) return !0
                                }
                            }
                            return n
                        })(T.p, d[E].p) && (_ !== E && y.push({
                            froms: _,
                            tos: E,
                            hole: w
                        }), M ? (M = !1, u[E].push(T)) : g = !0);
                        M && u[_].push(T)
                    }
                y.length > 0 && (g || (p = u))
            }
            for (var S, m = 0, A = d.length; m < A; m++) {
                o = d[m].s, h.push(o), S = p[m];
                for (var P = 0, R = S.length; P < R; P++) o.holes.push(S[P].h)
            }
            return h
        }
    }), Object.assign(Gn.prototype, {
        isFont: !0,
        generateShapes: function(t, e, i) {
            function n(t, e, n, s) {
                var a = r.glyphs[t] || r.glyphs["?"];
                if (a) {
                    var o, h, l, c, u, d, p, f, m, v, g, y = new Bn,
                        _ = [];
                    if (a.o)
                        for (var x = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), b = 0, w = x.length; b < w;) {
                            var T = x[b++];
                            switch (T) {
                                case "m":
                                    o = x[b++] * e + n, h = x[b++] * e + s, y.moveTo(o, h);
                                    break;
                                case "l":
                                    o = x[b++] * e + n, h = x[b++] * e + s, y.lineTo(o, h);
                                    break;
                                case "q":
                                    if (l = x[b++] * e + n, c = x[b++] * e + s, p = x[b++] * e + n, f = x[b++] * e + s, y.quadraticCurveTo(p, f, l, c), g = _[_.length - 1]) {
                                        u = g.x, d = g.y;
                                        for (var M = 1; M <= i; M++) {
                                            var E = M / i;
                                            En(E, u, p, l), En(E, d, f, c)
                                        }
                                    }
                                    break;
                                case "b":
                                    if (l = x[b++] * e + n, c = x[b++] * e + s, p = x[b++] * e + n, f = x[b++] * e + s, m = x[b++] * e + n, v = x[b++] * e + s, y.bezierCurveTo(p, f, m, v, l, c), g = _[_.length - 1]) {
                                        u = g.x, d = g.y;
                                        for (var M = 1; M <= i; M++) {
                                            var E = M / i;
                                            Cn(E, u, p, m, l), Cn(E, d, f, v, c)
                                        }
                                    }
                            }
                        }
                    return {
                        offsetX: a.ha * e,
                        path: y
                    }
                }
            }
            void 0 === e && (e = 100), void 0 === i && (i = 4);
            for (var r = this.data, s = function(t) {
                    for (var i = String(t).split(""), s = e / r.resolution, a = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * s, o = 0, h = 0, l = [], c = 0; c < i.length; c++) {
                        var u = i[c];
                        if ("\n" === u) o = 0, h -= a;
                        else {
                            var d = n(u, s, o, h);
                            o += d.offsetX, l.push(d.path)
                        }
                    }
                    return l
                }(t), a = [], o = 0, h = s.length; o < h; o++) Array.prototype.push.apply(a, s[o].toShapes());
            return a
        }
    }), Object.assign(Hn.prototype, {
        load: function(t, e, i, n) {
            var r = this;
            new Fi(this.manager).load(t, function(t) {
                var i;
                try {
                    i = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                }
                var n = r.parse(i);
                e && e(n)
            }, i, n)
        },
        parse: function(t) {
            return new Gn(t)
        }
    });
    var hh, lh = {
        getContext: function() {
            return void 0 === hh && (hh = new(window.AudioContext || window.webkitAudioContext)), hh
        },
        setContext: function(t) {
            hh = t
        }
    };
    Object.assign(jn.prototype, {
            load: function(t, e, i, n) {
                var r = new Fi(this.manager);
                r.setResponseType("arraybuffer"), r.load(t, function(t) {
                    lh.getContext().decodeAudioData(t, function(t) {
                        e(t)
                    })
                }, i, n)
            }
        }), Object.assign(Vn.prototype, {
            update: function() {
                var t, e, i, n, r, s, a, o, h = new u,
                    l = new u;
                return function(c) {
                    if (t !== this || e !== c.focus || i !== c.fov || n !== c.aspect * this.aspect || r !== c.near || s !== c.far || a !== c.zoom || o !== this.eyeSep) {
                        t = this, e = c.focus, i = c.fov, n = c.aspect * this.aspect, r = c.near, s = c.far, a = c.zoom;
                        var u = c.projectionMatrix.clone();
                        o = this.eyeSep / 2;
                        var d, p, f = o * r / e,
                            m = r * Math.tan(Oo.DEG2RAD * i * .5) / a;
                        l.elements[12] = -o, h.elements[12] = o, d = -m * n + f, p = m * n + f, u.elements[0] = 2 * r / (p - d), u.elements[8] = (p + d) / (p - d), this.cameraL.projectionMatrix.copy(u), d = -m * n - f, p = m * n - f, u.elements[0] = 2 * r / (p - d), u.elements[8] = (p + d) / (p - d), this.cameraR.projectionMatrix.copy(u)
                    }
                    this.cameraL.matrixWorld.copy(c.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(c.matrixWorld).multiply(h)
                }
            }()
        }), Wn.prototype = Object.create(dt.prototype), Wn.prototype.constructor = Wn, Xn.prototype = Object.assign(Object.create(dt.prototype), {
            constructor: Xn,
            getInput: function() {
                return this.gain
            },
            removeFilter: function() {
                null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
            },
            getFilter: function() {
                return this.filter
            },
            setFilter: function(t) {
                null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
            },
            getMasterVolume: function() {
                return this.gain.gain.value
            },
            setMasterVolume: function(t) {
                this.gain.gain.value = t
            },
            updateMatrixWorld: function() {
                var t = new c,
                    e = new l,
                    i = new c,
                    n = new c;
                return function(r) {
                    dt.prototype.updateMatrixWorld.call(this, r);
                    var s = this.context.listener,
                        a = this.up;
                    this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), s.positionX ? (s.positionX.setValueAtTime(t.x, this.context.currentTime), s.positionY.setValueAtTime(t.y, this.context.currentTime), s.positionZ.setValueAtTime(t.z, this.context.currentTime), s.forwardX.setValueAtTime(n.x, this.context.currentTime), s.forwardY.setValueAtTime(n.y, this.context.currentTime), s.forwardZ.setValueAtTime(n.z, this.context.currentTime), s.upX.setValueAtTime(a.x, this.context.currentTime), s.upY.setValueAtTime(a.y, this.context.currentTime), s.upZ.setValueAtTime(a.z, this.context.currentTime)) : (s.setPosition(t.x, t.y, t.z), s.setOrientation(n.x, n.y, n.z, a.x, a.y, a.z))
                }
            }()
        }), qn.prototype = Object.assign(Object.create(dt.prototype), {
            constructor: qn,
            getOutput: function() {
                return this.gain
            },
            setNodeSource: function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            },
            setBuffer: function(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function() {
                if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                var t = this.context.createBufferSource();
                return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), t.start(0, this.startTime), this.isPlaying = !0, this.source = t, this.connect()
            },
            pause: function() {
                return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this)
            },
            stop: function() {
                return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = 0, this.isPlaying = !1, this)
            },
            connect: function() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function() {
                return this.filters
            },
            setFilters: function(t) {
                return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
            },
            getFilter: function() {
                return this.getFilters()[0]
            },
            setFilter: function(t) {
                return this.setFilters(t ? [t] : [])
            },
            setPlaybackRate: function(t) {
                return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this)
            },
            getPlaybackRate: function() {
                return this.playbackRate
            },
            onEnded: function() {
                this.isPlaying = !1
            },
            getLoop: function() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            },
            setLoop: function(t) {
                return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this)
            },
            getVolume: function() {
                return this.gain.gain.value
            },
            setVolume: function(t) {
                return this.gain.gain.value = t, this
            }
        }), Yn.prototype = Object.assign(Object.create(qn.prototype), {
            constructor: Yn,
            getOutput: function() {
                return this.panner
            },
            getRefDistance: function() {
                return this.panner.refDistance
            },
            setRefDistance: function(t) {
                this.panner.refDistance = t
            },
            getRolloffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function(t) {
                this.panner.rolloffFactor = t
            },
            getDistanceModel: function() {
                return this.panner.distanceModel
            },
            setDistanceModel: function(t) {
                this.panner.distanceModel = t
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(t) {
                this.panner.maxDistance = t
            },
            updateMatrixWorld: function() {
                var t = new c;
                return function(e) {
                    dt.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z)
                }
            }()
        }), Object.assign(Zn.prototype, {
            getFrequencyData: function() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function() {
                for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                return t / e.length
            }
        }), Object.assign($n.prototype, {
            accumulate: function(t, e) {
                var i = this.buffer,
                    n = this.valueSize,
                    r = t * n + n,
                    s = this.cumulativeWeight;
                if (0 === s) {
                    for (var a = 0; a !== n; ++a) i[r + a] = i[a];
                    s = e
                } else {
                    s += e;
                    var o = e / s;
                    this._mixBufferRegion(i, r, 0, o, n)
                }
                this.cumulativeWeight = s
            },
            apply: function(t) {
                var e = this.valueSize,
                    i = this.buffer,
                    n = t * e + e,
                    r = this.cumulativeWeight,
                    s = this.binding;
                if (this.cumulativeWeight = 0, r < 1) {
                    var a = 3 * e;
                    this._mixBufferRegion(i, n, a, 1 - r, e)
                }
                for (var o = e, h = e + e; o !== h; ++o)
                    if (i[o] !== i[o + e]) {
                        s.setValue(i, n);
                        break
                    }
            },
            saveOriginalState: function() {
                var t = this.binding,
                    e = this.buffer,
                    i = this.valueSize,
                    n = 3 * i;
                t.getValue(e, n);
                for (var r = i, s = n; r !== s; ++r) e[r] = e[n + r % i];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                var t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            },
            _select: function(t, e, i, n, r) {
                if (n >= .5)
                    for (var s = 0; s !== r; ++s) t[e + s] = t[i + s]
            },
            _slerp: function(t, e, i, n) {
                l.slerpFlat(t, e, t, e, t, i, n)
            },
            _lerp: function(t, e, i, n, r) {
                for (var s = 1 - n, a = 0; a !== r; ++a) {
                    var o = e + a;
                    t[o] = t[o] * s + t[i + a] * n
                }
            }
        }), Object.assign(Qn.prototype, {
            getValue: function(t, e) {
                this.bind();
                var i = this._targetGroup.nCachedObjects_,
                    n = this._bindings[i];
                void 0 !== n && n.getValue(t, e)
            },
            setValue: function(t, e) {
                for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
            },
            bind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
            },
            unbind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
            }
        }), Object.assign(Jn, {
            Composite: Qn,
            create: function(t, e, i) {
                return t && t.isAnimationObjectGroup ? new Jn.Composite(t, e, i) : new Jn(t, e, i)
            },
            sanitizeNodeName: function(t) {
                return t.replace(/\s/g, "_").replace(/[^\w-]/g, "")
            },
            parseTrackName: function() {
                var t = /((?:[\w-]+[\/:])*)/,
                    e = /([\w-\.]+)?/,
                    i = /(?:\.([\w-]+)(?:\[(.+)\])?)?/,
                    n = /\.([\w-]+)(?:\[(.+)\])?/,
                    r = new RegExp("^" + t.source + e.source + i.source + n.source + "$"),
                    s = ["material", "materials", "bones"];
                return function(t) {
                    var e = r.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    var i = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        n = i.nodeName && i.nodeName.lastIndexOf(".");
                    if (void 0 !== n && -1 !== n) {
                        var a = i.nodeName.substring(n + 1); - 1 !== s.indexOf(a) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = a)
                    }
                    if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return i
                }
            }(),
            findNode: function(t, e) {
                if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    var i = function(t) {
                        for (var i = 0; i < t.bones.length; i++) {
                            var n = t.bones[i];
                            if (n.name === e) return n
                        }
                        return null
                    }(t.skeleton);
                    if (i) return i
                }
                if (t.children) {
                    var n = function(t) {
                            for (var i = 0; i < t.length; i++) {
                                var r = t[i];
                                if (r.name === e || r.uuid === e) return r;
                                var s = n(r.children);
                                if (s) return s
                            }
                            return null
                        },
                        r = n(t.children);
                    if (r) return r
                }
                return null
            }
        }), Object.assign(Jn.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            }, function(t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
            }, function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(t, e) {
                    this.node[this.propertyName] = t[e]
                }, function(t, e) {
                    this.node[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.node[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function() {
                var t = this.node,
                    e = this.parsedPath,
                    i = e.objectName,
                    n = e.propertyName,
                    r = e.propertyIndex;
                if (t || (t = Jn.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (i) {
                    var s = e.objectIndex;
                    switch (i) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (var a = 0; a < t.length; a++)
                                if (t[a].name === s) {
                                    s = a;
                                    break
                                }
                            break;
                        default:
                            if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[i]
                    }
                    if (void 0 !== s) {
                        if (void 0 === t[s]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[s]
                    }
                }
                var o = t[n];
                if (void 0 === o) {
                    var h = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + n + " but it wasn't found.", t)
                }
                var l = this.Versioning.None;
                void 0 !== t.needsUpdate ? (l = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t);
                var c = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === n) {
                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (t.geometry.isBufferGeometry) {
                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            for (var a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                if (t.geometry.morphAttributes.position[a].name === r) {
                                    r = a;
                                    break
                                }
                        } else {
                            if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                            for (var a = 0; a < this.node.geometry.morphTargets.length; a++)
                                if (t.geometry.morphTargets[a].name === r) {
                                    r = a;
                                    break
                                }
                        }
                    }
                    c = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                } else void 0 !== o.fromArray && void 0 !== o.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(Jn.prototype, {
            _getValue_unbound: Jn.prototype.getValue,
            _setValue_unbound: Jn.prototype.setValue
        }), Object.assign(Kn.prototype, {
            isAnimationObjectGroup: !0,
            add: function(t) {
                for (var e = this._objects, i = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, s = this._paths, a = this._parsedPaths, o = this._bindings, h = o.length, l = 0, c = arguments.length; l !== c; ++l) {
                    var u = arguments[l],
                        d = u.uuid,
                        p = r[d],
                        f = void 0;
                    if (void 0 === p) {
                        p = i++, r[d] = p, e.push(u);
                        for (var m = 0, v = h; m !== v; ++m) o[m].push(new Jn(u, s[m], a[m]))
                    } else if (p < n) {
                        f = e[p];
                        var g = --n,
                            y = e[g];
                        r[y.uuid] = p, e[p] = y, r[d] = g, e[g] = u;
                        for (var m = 0, v = h; m !== v; ++m) {
                            var _ = o[m],
                                x = _[g],
                                b = _[p];
                            _[p] = x, void 0 === b && (b = new Jn(u, s[m], a[m])), _[g] = b
                        }
                    } else e[p] !== f && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = n
            },
            remove: function(t) {
                for (var e = this._objects, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, s = r.length, a = 0, o = arguments.length; a !== o; ++a) {
                    var h = arguments[a],
                        l = h.uuid,
                        c = n[l];
                    if (void 0 !== c && c >= i) {
                        var u = i++,
                            d = e[u];
                        n[d.uuid] = c, e[c] = d, n[l] = u, e[u] = h;
                        for (var p = 0, f = s; p !== f; ++p) {
                            var m = r[p],
                                v = m[u],
                                g = m[c];
                            m[c] = v, m[u] = g
                        }
                    }
                }
                this.nCachedObjects_ = i
            },
            uncache: function(t) {
                for (var e = this._objects, i = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, s = this._bindings, a = s.length, o = 0, h = arguments.length; o !== h; ++o) {
                    var l = arguments[o],
                        c = l.uuid,
                        u = r[c];
                    if (void 0 !== u)
                        if (delete r[c], u < n) {
                            var d = --n,
                                p = e[d],
                                f = --i,
                                m = e[f];
                            r[p.uuid] = u, e[u] = p, r[m.uuid] = d, e[d] = m, e.pop();
                            for (var v = 0, g = a; v !== g; ++v) {
                                var y = s[v],
                                    _ = y[d],
                                    x = y[f];
                                y[u] = _, y[d] = x, y.pop()
                            }
                        } else {
                            var f = --i,
                                m = e[f];
                            r[m.uuid] = u, e[u] = m, e.pop();
                            for (var v = 0, g = a; v !== g; ++v) {
                                var y = s[v];
                                y[u] = y[f], y.pop()
                            }
                        }
                }
                this.nCachedObjects_ = n
            },
            subscribe_: function(t, e) {
                var i = this._bindingsIndicesByPath,
                    n = i[t],
                    r = this._bindings;
                if (void 0 !== n) return r[n];
                var s = this._paths,
                    a = this._parsedPaths,
                    o = this._objects,
                    h = o.length,
                    l = this.nCachedObjects_,
                    c = new Array(h);
                n = r.length, i[t] = n, s.push(t), a.push(e), r.push(c);
                for (var u = l, d = o.length; u !== d; ++u) {
                    var p = o[u];
                    c[u] = new Jn(p, t, e)
                }
                return c
            },
            unsubscribe_: function(t) {
                var e = this._bindingsIndicesByPath,
                    i = e[t];
                if (void 0 !== i) {
                    var n = this._paths,
                        r = this._parsedPaths,
                        s = this._bindings,
                        a = s.length - 1,
                        o = s[a];
                    e[t[a]] = i, s[i] = o, s.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
                }
            }
        }), Object.assign(tr.prototype, {
            play: function() {
                return this._mixer._activateAction(this), this
            },
            stop: function() {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(t) {
                return this._startTime = t, this
            },
            setLoop: function(t, e) {
                return this.loop = t, this.repetitions = e, this
            },
            setEffectiveWeight: function(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(t) {
                return this._scheduleFading(t, 0, 1)
            },
            fadeOut: function(t) {
                return this._scheduleFading(t, 1, 0)
            },
            crossFadeFrom: function(t, e, i) {
                if (t.fadeOut(e), this.fadeIn(e), i) {
                    var n = this._clip.duration,
                        r = t._clip.duration,
                        s = r / n,
                        a = n / r;
                    t.warp(1, s, e), this.warp(a, 1, e)
                }
                return this
            },
            crossFadeTo: function(t, e, i) {
                return t.crossFadeFrom(this, e, i)
            },
            stopFading: function() {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            setEffectiveTimeScale: function(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            },
            syncWith: function(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            },
            halt: function(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            },
            warp: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    s = this._timeScaleInterpolant,
                    a = this.timeScale;
                null === s && (s = n._lendControlInterpolant(), this._timeScaleInterpolant = s);
                var o = s.parameterPositions,
                    h = s.sampleValues;
                return o[0] = r, o[1] = r + i, h[0] = t / a, h[1] = e / a, this
            },
            stopWarping: function() {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(t, e, i, n) {
                if (!this.enabled) return void this._updateWeight(t);
                var r = this._startTime;
                if (null !== r) {
                    var s = (t - r) * i;
                    if (s < 0 || 0 === i) return;
                    this._startTime = null, e = i * s
                }
                e *= this._updateTimeScale(t);
                var a = this._updateTime(e),
                    o = this._updateWeight(t);
                if (o > 0)
                    for (var h = this._interpolants, l = this._propertyBindings, c = 0, u = h.length; c !== u; ++c) h[c].evaluate(a), l[c].accumulate(n, o)
            },
            _updateWeight: function(t) {
                var e = 0;
                if (this.enabled) {
                    e = this.weight;
                    var i = this._weightInterpolant;
                    if (null !== i) {
                        var n = i.evaluate(t)[0];
                        e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e, e
            },
            _updateTimeScale: function(t) {
                var e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    var i = this._timeScaleInterpolant;
                    if (null !== i) {
                        e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                }
                return this._effectiveTimeScale = e, e
            },
            _updateTime: function(t) {
                var e = this.time + t;
                if (0 === t) return e;
                var i = this._clip.duration,
                    n = this.loop,
                    r = this._loopCount;
                if (n === lo) {
                    -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t: {
                        if (e >= i) e = i;
                        else {
                            if (!(e < 0)) break t;
                            e = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    var s = n === uo;
                    if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), e >= i || e < 0) {
                        var a = Math.floor(e / i);
                        e -= i * a, r += Math.abs(a);
                        var o = this.repetitions - r;
                        if (o < 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? i : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                        else {
                            if (0 === o) {
                                var h = t < 0;
                                this._setEndings(h, !h, s)
                            } else this._setEndings(!1, !1, s);
                            this._loopCount = r, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: a
                            })
                        }
                    }
                    if (s && 1 == (1 & r)) return this.time = e, i - e
                }
                return this.time = e, e
            },
            _setEndings: function(t, e, i) {
                var n = this._interpolantSettings;
                i ? (n.endingStart = go, n.endingEnd = go) : (n.endingStart = t ? this.zeroSlopeAtStart ? go : vo : yo, n.endingEnd = e ? this.zeroSlopeAtEnd ? go : vo : yo)
            },
            _scheduleFading: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    s = this._weightInterpolant;
                null === s && (s = n._lendControlInterpolant(), this._weightInterpolant = s);
                var a = s.parameterPositions,
                    o = s.sampleValues;
                return a[0] = r, o[0] = e, a[1] = r + t, o[1] = i, this
            }
        }), Object.assign(er.prototype, n.prototype, {
            _bindAction: function(t, e) {
                var i = t._localRoot || this._root,
                    n = t._clip.tracks,
                    r = n.length,
                    s = t._propertyBindings,
                    a = t._interpolants,
                    o = i.uuid,
                    h = this._bindingsByRootAndName,
                    l = h[o];
                void 0 === l && (l = {}, h[o] = l);
                for (var c = 0; c !== r; ++c) {
                    var u = n[c],
                        d = u.name,
                        p = l[d];
                    if (void 0 !== p) s[c] = p;
                    else {
                        if (void 0 !== (p = s[c])) {
                            null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, o, d));
                            continue
                        }
                        var f = e && e._propertyBindings[c].binding.parsedPath;
                        p = new $n(Jn.create(i, d, f), u.ValueTypeName, u.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, o, d), s[c] = p
                    }
                    a[c].resultBuffer = p.buffer
                }
            },
            _activateAction: function(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        var e = (t._localRoot || this._root).uuid,
                            i = t._clip.uuid,
                            n = this._actionsByClip[i];
                        this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                    }
                    for (var r = t._propertyBindings, s = 0, a = r.length; s !== a; ++s) {
                        var o = r[s];
                        0 == o.useCount++ && (this._lendBinding(o), o.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function(t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                        var r = e[i];
                        0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(t) {
                var e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            },
            _addInactiveAction: function(t, e, i) {
                var n = this._actions,
                    r = this._actionsByClip,
                    s = r[e];
                if (void 0 === s) s = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, r[e] = s;
                else {
                    var a = s.knownActions;
                    t._byClipCacheIndex = a.length, a.push(t)
                }
                t._cacheIndex = n.length, n.push(t), s.actionByRoot[i] = t
            },
            _removeInactiveAction: function(t) {
                var e = this._actions,
                    i = e[e.length - 1],
                    n = t._cacheIndex;
                i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
                var r = t._clip.uuid,
                    s = this._actionsByClip,
                    a = s[r],
                    o = a.knownActions,
                    h = o[o.length - 1],
                    l = t._byClipCacheIndex;
                h._byClipCacheIndex = l, o[l] = h, o.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function(t) {
                for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                    var r = e[i];
                    0 == --r.referenceCount && this._removeInactiveBinding(r)
                }
            },
            _lendAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = this._nActiveActions++,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _takeBackAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = --this._nActiveActions,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _addInactiveBinding: function(t, e, i) {
                var n = this._bindingsByRootAndName,
                    r = n[e],
                    s = this._bindings;
                void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = s.length, s.push(t)
            },
            _removeInactiveBinding: function(t) {
                var e = this._bindings,
                    i = t.binding,
                    n = i.rootNode.uuid,
                    r = i.path,
                    s = this._bindingsByRootAndName,
                    a = s[n],
                    o = e[e.length - 1],
                    h = t._cacheIndex;
                o._cacheIndex = h, e[h] = o, e.pop(), delete a[r];
                t: {
                    for (var l in a) break t;delete s[n]
                }
            },
            _lendBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = this._nActiveBindings++,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _takeBackBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = --this._nActiveBindings,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _lendControlInterpolant: function() {
                var t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++,
                    i = t[e];
                return void 0 === i && (i = new rn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = e, t[e] = i), i
            },
            _takeBackControlInterpolant: function(t) {
                var e = this._controlInterpolants,
                    i = t.__cacheIndex,
                    n = --this._nActiveControlInterpolants,
                    r = e[n];
                t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function(t, e) {
                var i = e || this._root,
                    n = i.uuid,
                    r = "string" == typeof t ? mn.findByName(i, t) : t,
                    s = null !== r ? r.uuid : t,
                    a = this._actionsByClip[s],
                    o = null;
                if (void 0 !== a) {
                    var h = a.actionByRoot[n];
                    if (void 0 !== h) return h;
                    o = a.knownActions[0], null === r && (r = o._clip)
                }
                if (null === r) return null;
                var l = new tr(this, r, e);
                return this._bindAction(l, o), this._addInactiveAction(l, s, n), l
            },
            existingAction: function(t, e) {
                var i = e || this._root,
                    n = i.uuid,
                    r = "string" == typeof t ? mn.findByName(i, t) : t,
                    s = r ? r.uuid : t,
                    a = this._actionsByClip[s];
                return void 0 !== a ? a.actionByRoot[n] || null : null
            },
            stopAllAction: function() {
                var t = this._actions,
                    e = this._nActiveActions,
                    i = this._bindings,
                    n = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (var r = 0; r !== e; ++r) t[r].reset();
                for (var r = 0; r !== n; ++r) i[r].useCount = 0;
                return this
            },
            update: function(t) {
                t *= this.timeScale;
                for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), s = this._accuIndex ^= 1, a = 0; a !== i; ++a) {
                    e[a]._update(n, t, r, s)
                }
                for (var o = this._bindings, h = this._nActiveBindings, a = 0; a !== h; ++a) o[a].apply(s);
                return this
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(t) {
                var e = this._actions,
                    i = t.uuid,
                    n = this._actionsByClip,
                    r = n[i];
                if (void 0 !== r) {
                    for (var s = r.knownActions, a = 0, o = s.length; a !== o; ++a) {
                        var h = s[a];
                        this._deactivateAction(h);
                        var l = h._cacheIndex,
                            c = e[e.length - 1];
                        h._cacheIndex = null, h._byClipCacheIndex = null, c._cacheIndex = l, e[l] = c, e.pop(), this._removeInactiveBindingsForAction(h)
                    }
                    delete n[i]
                }
            },
            uncacheRoot: function(t) {
                var e = t.uuid,
                    i = this._actionsByClip;
                for (var n in i) {
                    var r = i[n].actionByRoot,
                        s = r[e];
                    void 0 !== s && (this._deactivateAction(s), this._removeInactiveAction(s))
                }
                var a = this._bindingsByRootAndName,
                    o = a[e];
                if (void 0 !== o)
                    for (var h in o) {
                        var l = o[h];
                        l.restoreOriginalState(), this._removeInactiveBinding(l)
                    }
            },
            uncacheAction: function(t, e) {
                var i = this.existingAction(t, e);
                null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
        }), ir.prototype.clone = function() {
            return new ir(void 0 === this.value.clone ? this.value : this.value.clone())
        }, nr.prototype = Object.assign(Object.create(Lt.prototype), {
            constructor: nr,
            isInstancedBufferGeometry: !0,
            addGroup: function(t, e, i) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: i
                })
            },
            copy: function(t) {
                var e = t.index;
                null !== e && this.setIndex(e.clone());
                var i = t.attributes;
                for (var n in i) {
                    var r = i[n];
                    this.addAttribute(n, r.clone())
                }
                for (var s = t.groups, a = 0, o = s.length; a < o; a++) {
                    var h = s[a];
                    this.addGroup(h.start, h.count, h.materialIndex)
                }
                return this
            }
        }), Object.defineProperties(rr.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            }
        }), Object.assign(rr.prototype, {
            isInterleavedBufferAttribute: !0,
            setX: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            },
            setY: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            },
            setZ: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            },
            setW: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            },
            getX: function(t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function(t, e, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
            }
        }), Object.defineProperty(sr.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(sr.prototype, {
            isInterleavedBuffer: !0,
            setArray: function(t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t
            },
            setDynamic: function(t) {
                return this.dynamic = t, this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
            },
            copyAt: function(t, e, i) {
                t *= this.stride, i *= e.stride;
                for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            }
        }), ar.prototype = Object.assign(Object.create(sr.prototype), {
            constructor: ar,
            isInstancedInterleavedBuffer: !0,
            copy: function(t) {
                return sr.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), or.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: or,
            isInstancedBufferAttribute: !0,
            copy: function(t) {
                return _t.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), Object.assign(hr.prototype, {
            linePrecision: 1,
            set: function(t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function(t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(t, e) {
                var i = [];
                return cr(t, this, i, e), i.sort(lr), i
            },
            intersectObjects: function(t, e) {
                var i = [];
                if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                for (var n = 0, r = t.length; n < r; n++) cr(t[n], this, i, e);
                return i.sort(lr), i
            }
        }), Object.assign(ur.prototype, {
            start: function() {
                this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            },
            stop: function() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            },
            getElapsedTime: function() {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function() {
                var t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var e = ("undefined" == typeof performance ? Date : performance).now();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }), Object.assign(dr.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.phi = e, this.theta = i, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            },
            makeSafe: function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function(t) {
                return this.radius = t.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(Oo.clamp(t.y / this.radius, -1, 1))), this
            }
        }), Object.assign(pr.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.theta = e, this.y = i, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            },
            setFromVector3: function(t) {
                return this.radius = Math.sqrt(t.x * t.x + t.z * t.z), this.theta = Math.atan2(t.x, t.z), this.y = t.y, this
            }
        }), fr.prototype = Object.create(dt.prototype), fr.prototype.constructor = fr, fr.prototype.isImmediateRenderObject = !0, mr.prototype = Object.create(Ne.prototype), mr.prototype.constructor = mr, mr.prototype.update = function() {
            var t = new c,
                e = new c,
                i = new st;
            return function() {
                var n = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                var r = this.object.matrixWorld,
                    s = this.geometry.attributes.position,
                    a = this.object.geometry;
                if (a && a.isGeometry)
                    for (var o = a.vertices, h = a.faces, l = 0, c = 0, u = h.length; c < u; c++)
                        for (var d = h[c], p = 0, f = d.vertexNormals.length; p < f; p++) {
                            var m = o[d[n[p]]],
                                v = d.vertexNormals[p];
                            t.copy(m).applyMatrix4(r), e.copy(v).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), s.setXYZ(l, t.x, t.y, t.z), l += 1, s.setXYZ(l, e.x, e.y, e.z), l += 1
                        } else if (a && a.isBufferGeometry)
                            for (var g = a.attributes.position, y = a.attributes.normal, l = 0, p = 0, f = g.count; p < f; p++) t.set(g.getX(p), g.getY(p), g.getZ(p)).applyMatrix4(r), e.set(y.getX(p), y.getY(p), y.getZ(p)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), s.setXYZ(l, t.x, t.y, t.z), l += 1, s.setXYZ(l, e.x, e.y, e.z), l += 1;
                s.needsUpdate = !0
            }
        }(), vr.prototype = Object.create(dt.prototype), vr.prototype.constructor = vr, vr.prototype.dispose = function() {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, vr.prototype.update = function() {
            var t = new c,
                e = new c;
            return function() {
                this.light.updateMatrixWorld();
                var i = this.light.distance ? this.light.distance : 1e3,
                    n = i * Math.tan(this.light.angle);
                this.cone.scale.set(n, n, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }(), yr.prototype = Object.create(Ne.prototype), yr.prototype.constructor = yr, yr.prototype.onBeforeRender = function() {
            var t = new c,
                e = new u,
                i = new u;
            return function() {
                var n = this.bones,
                    r = this.geometry,
                    s = r.getAttribute("position");
                i.getInverse(this.root.matrixWorld);
                for (var a = 0, o = 0; a < n.length; a++) {
                    var h = n[a];
                    h.parent && h.parent.isBone && (e.multiplyMatrices(i, h.matrixWorld), t.setFromMatrixPosition(e), s.setXYZ(o, t.x, t.y, t.z), e.multiplyMatrices(i, h.parent.matrixWorld), t.setFromMatrixPosition(e), s.setXYZ(o + 1, t.x, t.y, t.z), o += 2)
                }
                r.getAttribute("position").needsUpdate = !0
            }
        }(), _r.prototype = Object.create(Bt.prototype), _r.prototype.constructor = _r, _r.prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose()
        }, _r.prototype.update = function() {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        }, xr.prototype = Object.create(dt.prototype), xr.prototype.constructor = xr, xr.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, xr.prototype.update = function() {
            var t = .5 * this.light.width,
                e = .5 * this.light.height,
                i = this.line.geometry.attributes.position,
                n = i.array;
            n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
        }, br.prototype = Object.create(dt.prototype), br.prototype.constructor = br, br.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, br.prototype.update = function() {
            var t = new c,
                e = new Y,
                i = new Y;
            return function() {
                var n = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var r = n.geometry.getAttribute("color");
                    e.copy(this.light.color), i.copy(this.light.groundColor);
                    for (var s = 0, a = r.count; s < a; s++) {
                        var o = s < a / 2 ? e : i;
                        r.setXYZ(s, o.r, o.g, o.b)
                    }
                    r.needsUpdate = !0
                }
                n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }(), wr.prototype = Object.create(Ne.prototype), wr.prototype.constructor = wr, Tr.prototype = Object.create(Ne.prototype), Tr.prototype.constructor = Tr, Mr.prototype = Object.create(Ne.prototype), Mr.prototype.constructor = Mr, Mr.prototype.update = function() {
            var t = new c,
                e = new c,
                i = new st;
            return function() {
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, s = this.object.geometry, a = s.vertices, o = s.faces, h = 0, l = 0, c = o.length; l < c; l++) {
                    var u = o[l],
                        d = u.normal;
                    t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(n), e.copy(d).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(h, t.x, t.y, t.z), h += 1, r.setXYZ(h, e.x, e.y, e.z), h += 1
                }
                r.needsUpdate = !0
            }
        }(), Er.prototype = Object.create(dt.prototype), Er.prototype.constructor = Er, Er.prototype.dispose = function() {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
        }, Er.prototype.update = function() {
            var t = new c,
                e = new c,
                i = new c;
            return function() {
                t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(i), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(i), this.targetLine.scale.z = i.length()
            }
        }(), Sr.prototype = Object.create(Ne.prototype), Sr.prototype.constructor = Sr, Sr.prototype.update = function() {
            function t(t, s, a, o) {
                n.set(s, a, o).unproject(r);
                var h = i[t];
                if (void 0 !== h)
                    for (var l = e.getAttribute("position"), c = 0, u = h.length; c < u; c++) l.setXYZ(h[c], n.x, n.y, n.z)
            }
            var e, i, n = new c,
                r = new pt;
            return function() {
                e = this.geometry, i = this.pointMap;
                r.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", .7, 1.1, -1), t("u2", -.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0
            }
        }(), Ar.prototype = Object.create(Ne.prototype), Ar.prototype.constructor = Ar, Ar.prototype.update = function() {
            var t = new nt;
            return function(e) {
                if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                    var i = t.min,
                        n = t.max,
                        r = this.geometry.attributes.position,
                        s = r.array;
                    s[0] = n.x, s[1] = n.y, s[2] = n.z, s[3] = i.x, s[4] = n.y, s[5] = n.z, s[6] = i.x, s[7] = i.y, s[8] = n.z, s[9] = n.x, s[10] = i.y, s[11] = n.z, s[12] = n.x, s[13] = n.y, s[14] = i.z, s[15] = i.x, s[16] = n.y, s[17] = i.z, s[18] = i.x, s[19] = i.y, s[20] = i.z, s[21] = n.x, s[22] = i.y, s[23] = i.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }
        }(), Ar.prototype.setFromObject = function(t) {
            return this.object = t, this.update(), this
        }, Pr.prototype = Object.create(Ne.prototype), Pr.prototype.constructor = Pr, Pr.prototype.onBeforeRender = function() {
            var t = this.box;
            t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5))
        }, Rr.prototype = Object.create(Ue.prototype), Rr.prototype.constructor = Rr, Rr.prototype.onBeforeRender = function() {
            var t = -this.plane.constant;
            Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.lookAt(this.plane.normal), this.updateMatrixWorld()
        };
    var ch, uh;
    Cr.prototype = Object.create(dt.prototype), Cr.prototype.constructor = Cr, Cr.prototype.setDirection = function() {
        var t, e = new c;
        return function(i) {
            i.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : i.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(), t = Math.acos(i.y), this.quaternion.setFromAxisAngle(e, t))
        }
    }(), Cr.prototype.setLength = function(t, e, i) {
        void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
    }, Cr.prototype.setColor = function(t) {
        this.line.material.color.copy(t), this.cone.material.color.copy(t)
    }, Lr.prototype = Object.create(Ne.prototype), Lr.prototype.constructor = Lr;
    var dh = new c,
        ph = new Or,
        fh = new Or,
        mh = new Or;
    Ir.prototype = Object.create(Ln.prototype), Ir.prototype.constructor = Ir, Ir.prototype.getPoint = function(t) {
        var e = this.points,
            i = e.length,
            n = (i - (this.closed ? 0 : 1)) * t,
            r = Math.floor(n),
            s = n - r;
        this.closed ? r += r > 0 ? 0 : (Math.floor(Math.abs(r) / e.length) + 1) * e.length : 0 === s && r === i - 1 && (r = i - 2, s = 1);
        var a, o, h, l;
        if (this.closed || r > 0 ? a = e[(r - 1) % i] : (dh.subVectors(e[0], e[1]).add(e[0]), a = dh), o = e[r % i], h = e[(r + 1) % i], this.closed || r + 2 < i ? l = e[(r + 2) % i] : (dh.subVectors(e[i - 1], e[i - 2]).add(e[i - 1]), l = dh), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
            var u = "chordal" === this.type ? .5 : .25,
                d = Math.pow(a.distanceToSquared(o), u),
                p = Math.pow(o.distanceToSquared(h), u),
                f = Math.pow(h.distanceToSquared(l), u);
            p < 1e-4 && (p = 1), d < 1e-4 && (d = p), f < 1e-4 && (f = p), ph.initNonuniformCatmullRom(a.x, o.x, h.x, l.x, d, p, f), fh.initNonuniformCatmullRom(a.y, o.y, h.y, l.y, d, p, f), mh.initNonuniformCatmullRom(a.z, o.z, h.z, l.z, d, p, f)
        } else if ("catmullrom" === this.type) {
            var m = void 0 !== this.tension ? this.tension : .5;
            ph.initCatmullRom(a.x, o.x, h.x, l.x, m), fh.initCatmullRom(a.y, o.y, h.y, l.y, m), mh.initCatmullRom(a.z, o.z, h.z, l.z, m)
        }
        return new c(ph.calc(s), fh.calc(s), mh.calc(s))
    }, Dr.prototype = Object.create(Ln.prototype), Dr.prototype.constructor = Dr, Dr.prototype.getPoint = function(t) {
        var e = this.v0,
            i = this.v1,
            n = this.v2,
            r = this.v3;
        return new c(Cn(t, e.x, i.x, n.x, r.x), Cn(t, e.y, i.y, n.y, r.y), Cn(t, e.z, i.z, n.z, r.z))
    }, zr.prototype = Object.create(Ln.prototype), zr.prototype.constructor = zr, zr.prototype.getPoint = function(t) {
        var e = this.v0,
            i = this.v1,
            n = this.v2;
        return new c(En(t, e.x, i.x, n.x), En(t, e.y, i.y, n.y), En(t, e.z, i.z, n.z))
    }, Ur.prototype = Object.create(Ln.prototype), Ur.prototype.constructor = Ur, Ur.prototype.getPoint = function(t) {
        if (1 === t) return this.v2.clone();
        var e = new c;
        return e.subVectors(this.v2, this.v1), e.multiplyScalar(t), e.add(this.v1), e
    }, Nr.prototype = Object.create(Dn.prototype), Nr.prototype.constructor = Nr;
    var vh = {
            createMultiMaterialObject: function(t, e) {
                for (var i = new Ge, n = 0, r = e.length; n < r; n++) i.add(new Bt(t, e[n]));
                return i
            },
            detach: function(t, e, i) {
                t.applyMatrix(e.matrixWorld), e.remove(t), i.add(t)
            },
            attach: function(t, e, i) {
                t.applyMatrix((new u).getInverse(i.matrixWorld)), e.remove(t), i.add(t)
            }
        },
        gh = 0,
        yh = 1;
    Ln.create = function(t, e) {
        return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ln.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
    }, rs.prototype = Object.create(Ir.prototype), ss.prototype = Object.create(Ir.prototype), as.prototype = Object.create(Ir.prototype), Object.assign(as.prototype, {
        initFromArray: function(t) {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function(t) {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function(t) {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), wr.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, yr.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(Z.prototype, {
        center: function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        size: function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Object.assign(nt.prototype, {
        center: function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        },
        size: function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), kt.prototype.center = function(t) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, Oo.random16 = function() {
        return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
    }, Object.assign(st.prototype, {
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        },
        multiplyVector3Array: function(t) {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(t, e, i) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function(t, e, i) {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(u.prototype, {
        extractPosition: function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        },
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        getPosition: function() {
            var t;
            return function() {
                return void 0 === t && (t = new c), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector4: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector3Array: function(t) {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        },
        crossVector: function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(t, e, i) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function(t, e, i) {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(t, e, i, n, r, s) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, s)
        }
    }), at.prototype.isIntersectionLine = function(t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
    }, l.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
    }, Object.assign(Nt.prototype, {
        isIntersectionBox: function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionPlane: function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }
    }), Object.assign(Fn.prototype, {
        extrude: function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ci(this, t)
        },
        makeGeometry: function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new xi(this, t)
        }
    }), Object.assign(r.prototype, {
        fromAttribute: function(t, e, i) {
            return console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
        }
    }), Object.assign(c.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        },
        applyProjection: function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
        },
        fromAttribute: function(t, e, i) {
            return console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
        }
    }), Object.assign(a.prototype, {
        fromAttribute: function(t, e, i) {
            return console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
        }
    }), yt.prototype.computeTangents = function() {
        console.warn("THREE.Geometry: .computeTangents() has been removed.")
    }, Object.assign(dt.prototype, {
        getChildByName: function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        }
    }), Object.defineProperties(dt.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(Le.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(Oe.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), Object.defineProperty(Ln.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function(t) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
        }
    }), mt.prototype.setLens = function(t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
    }, Object.defineProperties(Wi.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
            }
        }
    }), Object.defineProperties(_t.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        }
    }), Object.assign(Lt.prototype, {
        addIndex: function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        },
        addDrawCall: function(t, e, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(Lt.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.defineProperties(ir.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(K.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new Y
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === Ps
            }
        }
    }), Object.defineProperties(Ii.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(tt.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
            }
        }
    }), Object.assign(Me.prototype, {
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
    }), Object.defineProperties(Me.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {
                return this.shadowMap.cullFace
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = t
            }
        }
    }), Object.defineProperties(ht.prototype, {
        cullFace: {
            get: function() {
                return this.renderReverseSided ? ys : gs
            },
            set: function(t) {
                var e = t !== gs;
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + e + "."), this.renderReverseSided = e
            }
        }
    }), Object.defineProperties(o.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
            }
        }
    }), qn.prototype.load = function(t) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var e = this;
        return (new jn).load(t, function(t) {
            e.setBuffer(t)
        }), this
    }, Zn.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, Wn.prototype.updateCubeMap = function(t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
    };
    var _h = {
            merge: function(t, e, i) {
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                var n;
                e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i)
            },
            center: function(t) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
            }
        },
        xh = {
            crossOrigin: void 0,
            loadTexture: function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new Vi;
                r.setCrossOrigin(this.crossOrigin);
                var s = r.load(t, i, void 0, n);
                return e && (s.mapping = e), s
            },
            loadTextureCube: function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new ji;
                r.setCrossOrigin(this.crossOrigin);
                var s = r.load(t, i, void 0, n);
                return e && (s.mapping = e), s
            },
            loadCompressedTexture: function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            },
            loadCompressedTextureCube: function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        }
}, function(t, e, i) {
    function n() {}

    function r(t) {
        if (!m(t)) return t;
        var e = [];
        for (var i in t) s(e, i, t[i]);
        return e.join("&")
    }

    function s(t, e, i) {
        if (null != i)
            if (Array.isArray(i)) i.forEach(function(i) {
                s(t, e, i)
            });
            else if (m(i))
            for (var n in i) s(t, e + "[" + n + "]", i[n]);
        else t.push(encodeURIComponent(e) + "=" + encodeURIComponent(i));
        else null === i && t.push(encodeURIComponent(e))
    }

    function a(t) {
        for (var e, i, n = {}, r = t.split("&"), s = 0, a = r.length; s < a; ++s) e = r[s], i = e.indexOf("="), -1 == i ? n[decodeURIComponent(e)] = "" : n[decodeURIComponent(e.slice(0, i))] = decodeURIComponent(e.slice(i + 1));
        return n
    }

    function o(t) {
        for (var e, i, n, r, s = t.split(/\r?\n/), a = {}, o = 0, h = s.length; o < h; ++o) i = s[o], -1 !== (e = i.indexOf(":")) && (n = i.slice(0, e).toLowerCase(), r = _(i.slice(e + 1)), a[n] = r);
        return a
    }

    function h(t) {
        return /[\/+]json\b/.test(t)
    }

    function l(t) {
        this.req = t, this.xhr = this.req.xhr, this.text = "HEAD" != this.req.method && ("" === this.xhr.responseType || "text" === this.xhr.responseType) || void 0 === this.xhr.responseType ? this.xhr.responseText : null, this.statusText = this.req.xhr.statusText;
        var e = this.xhr.status;
        1223 === e && (e = 204), this._setStatusProperties(e), this.header = this.headers = o(this.xhr.getAllResponseHeaders()), this.header["content-type"] = this.xhr.getResponseHeader("content-type"), this._setHeaderProperties(this.header), null === this.text && t._responseType ? this.body = this.xhr.response : this.body = "HEAD" != this.req.method ? this._parseBody(this.text ? this.text : this.xhr.response) : null
    }

    function c(t, e) {
        var i = this;
        this._query = this._query || [], this.method = t, this.url = e, this.header = {}, this._header = {}, this.on("end", function() {
            var t = null,
                e = null;
            try {
                e = new l(i)
            } catch (e) {
                return t = new Error("Parser is unable to parse the response"), t.parse = !0, t.original = e, i.xhr ? (t.rawResponse = void 0 === i.xhr.responseType ? i.xhr.responseText : i.xhr.response, t.status = i.xhr.status ? i.xhr.status : null, t.statusCode = t.status) : (t.rawResponse = null, t.status = null), i.callback(t)
            }
            i.emit("response", e);
            var n;
            try {
                i._isResponseOK(e) || (n = new Error(e.statusText || "Unsuccessful HTTP response"))
            } catch (t) {
                n = t
            }
            n ? (n.original = t, n.response = e, n.status = e.status, i.callback(n, e)) : i.callback(null, e)
        })
    }

    function u(t, e, i) {
        var n = y("DELETE", t);
        return "function" == typeof e && (i = e, e = null), e && n.send(e), i && n.end(i), n
    }
    var d;
    "undefined" != typeof window ? d = window : "undefined" != typeof self ? d = self : (console.warn("Using browser-only version of superagent in non-browser environment"), d = this);
    var p = i(14),
        f = i(15),
        m = i(4),
        v = i(16),
        g = i(18),
        y = e = t.exports = function(t, i) {
            return "function" == typeof i ? new e.Request("GET", t).end(i) : 1 == arguments.length ? new e.Request("GET", t) : new e.Request(t, i)
        };
    e.Request = c, y.getXHR = function() {
        if (!(!d.XMLHttpRequest || d.location && "file:" == d.location.protocol && d.ActiveXObject)) return new XMLHttpRequest;
        try {
            return new ActiveXObject("Microsoft.XMLHTTP")
        } catch (t) {}
        try {
            return new ActiveXObject("Msxml2.XMLHTTP.6.0")
        } catch (t) {}
        try {
            return new ActiveXObject("Msxml2.XMLHTTP.3.0")
        } catch (t) {}
        try {
            return new ActiveXObject("Msxml2.XMLHTTP")
        } catch (t) {}
        throw Error("Browser-only version of superagent could not find XHR")
    };
    var _ = "".trim ? function(t) {
        return t.trim()
    } : function(t) {
        return t.replace(/(^\s*|\s*$)/g, "")
    };
    y.serializeObject = r, y.parseString = a, y.types = {
        html: "text/html",
        json: "application/json",
        xml: "text/xml",
        urlencoded: "application/x-www-form-urlencoded",
        form: "application/x-www-form-urlencoded",
        "form-data": "application/x-www-form-urlencoded"
    }, y.serialize = {
        "application/x-www-form-urlencoded": r,
        "application/json": JSON.stringify
    }, y.parse = {
        "application/x-www-form-urlencoded": a,
        "application/json": JSON.parse
    }, v(l.prototype), l.prototype._parseBody = function(t) {
        var e = y.parse[this.type];
        return this.req._parser ? this.req._parser(this, t) : (!e && h(this.type) && (e = y.parse["application/json"]), e && t && (t.length || t instanceof Object) ? e(t) : null)
    }, l.prototype.toError = function() {
        var t = this.req,
            e = t.method,
            i = t.url,
            n = "cannot " + e + " " + i + " (" + this.status + ")",
            r = new Error(n);
        return r.status = this.status, r.method = e, r.url = i, r
    }, y.Response = l, p(c.prototype), f(c.prototype), c.prototype.type = function(t) {
        return this.set("Content-Type", y.types[t] || t), this
    }, c.prototype.accept = function(t) {
        return this.set("Accept", y.types[t] || t), this
    }, c.prototype.auth = function(t, e, i) {
        1 === arguments.length && (e = ""), "object" == typeof e && null !== e && (i = e, e = ""), i || (i = {
            type: "function" == typeof btoa ? "basic" : "auto"
        });
        var n = function(t) {
            if ("function" == typeof btoa) return btoa(t);
            throw new Error("Cannot use basic auth, btoa is not a function")
        };
        return this._auth(t, e, i, n)
    }, c.prototype.query = function(t) {
        return "string" != typeof t && (t = r(t)), t && this._query.push(t), this
    }, c.prototype.attach = function(t, e, i) {
        if (e) {
            if (this._data) throw Error("superagent can't mix .send() and .attach()");
            this._getFormData().append(t, e, i || e.name)
        }
        return this
    }, c.prototype._getFormData = function() {
        return this._formData || (this._formData = new d.FormData), this._formData
    }, c.prototype.callback = function(t, e) {
        if (this._shouldRetry(t, e)) return this._retry();
        var i = this._callback;
        this.clearTimeout(), t && (this._maxRetries && (t.retries = this._retries - 1), this.emit("error", t)), i(t, e)
    }, c.prototype.crossDomainError = function() {
        var t = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");
        t.crossDomain = !0, t.status = this.status, t.method = this.method, t.url = this.url, this.callback(t)
    }, c.prototype.buffer = c.prototype.ca = c.prototype.agent = function() {
        return console.warn("This is not supported in browser version of superagent"), this
    }, c.prototype.pipe = c.prototype.write = function() {
        throw Error("Streaming is not supported in browser version of superagent")
    }, c.prototype._isHost = function(t) {
        return t && "object" == typeof t && !Array.isArray(t) && "[object Object]" !== Object.prototype.toString.call(t)
    }, c.prototype.end = function(t) {
        return this._endCalled && console.warn("Warning: .end() was called twice. This is not supported in superagent"), this._endCalled = !0, this._callback = t || n, this._finalizeQueryString(), this._end()
    }, c.prototype._end = function() {
        var t = this,
            e = this.xhr = y.getXHR(),
            i = this._formData || this._data;
        this._setTimeouts(), e.onreadystatechange = function() {
            var i = e.readyState;
            if (i >= 2 && t._responseTimeoutTimer && clearTimeout(t._responseTimeoutTimer), 4 == i) {
                var n;
                try {
                    n = e.status
                } catch (t) {
                    n = 0
                }
                if (!n) {
                    if (t.timedout || t._aborted) return;
                    return t.crossDomainError()
                }
                t.emit("end")
            }
        };
        var n = function(e, i) {
            i.total > 0 && (i.percent = i.loaded / i.total * 100), i.direction = e, t.emit("progress", i)
        };
        if (this.hasListeners("progress")) try {
            e.onprogress = n.bind(null, "download"), e.upload && (e.upload.onprogress = n.bind(null, "upload"))
        } catch (t) {}
        try {
            this.username && this.password ? e.open(this.method, this.url, !0, this.username, this.password) : e.open(this.method, this.url, !0)
        } catch (t) {
            return this.callback(t)
        }
        if (this._withCredentials && (e.withCredentials = !0), !this._formData && "GET" != this.method && "HEAD" != this.method && "string" != typeof i && !this._isHost(i)) {
            var r = this._header["content-type"],
                s = this._serializer || y.serialize[r ? r.split(";")[0] : ""];
            !s && h(r) && (s = y.serialize["application/json"]), s && (i = s(i))
        }
        for (var a in this.header) null != this.header[a] && this.header.hasOwnProperty(a) && e.setRequestHeader(a, this.header[a]);
        return this._responseType && (e.responseType = this._responseType), this.emit("request", this), e.send(void 0 !== i ? i : null), this
    }, y.agent = function() {
        return new g
    }, ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(t) {
        g.prototype[t.toLowerCase()] = function(e, i) {
            var n = new y.Request(t, e);
            return this._setDefaults(n), i && n.end(i), n
        }
    }), g.prototype.del = g.prototype.delete, y.get = function(t, e, i) {
        var n = y("GET", t);
        return "function" == typeof e && (i = e, e = null), e && n.query(e), i && n.end(i), n
    }, y.head = function(t, e, i) {
        var n = y("HEAD", t);
        return "function" == typeof e && (i = e, e = null), e && n.query(e), i && n.end(i), n
    }, y.options = function(t, e, i) {
        var n = y("OPTIONS", t);
        return "function" == typeof e && (i = e, e = null), e && n.send(e), i && n.end(i), n
    }, y.del = u, y.delete = u, y.patch = function(t, e, i) {
        var n = y("PATCH", t);
        return "function" == typeof e && (i = e, e = null), e && n.send(e), i && n.end(i), n
    }, y.post = function(t, e, i) {
        var n = y("POST", t);
        return "function" == typeof e && (i = e, e = null), e && n.send(e), i && n.end(i), n
    }, y.put = function(t, e, i) {
        var n = y("PUT", t);
        return "function" == typeof e && (i = e, e = null), e && n.send(e), i && n.end(i), n
    }
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(0),
        r = (function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            e.default = t
        }(n), function() {
            this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
        });
    Object.assign(r.prototype, {
        setSize: function(t, e) {},
        render: function(t, e, i, n, r) {
            console.error("Pass: .render() must be implemented in derived pass.")
        }
    }), e.default = r
}, function(t, e) {
    var i;
    i = function() {
        return this
    }();
    try {
        i = i || Function("return this")() || (0, eval)("this")
    } catch (t) {
        "object" == typeof window && (i = window)
    }
    t.exports = i
}, function(t, e, i) {
    "use strict";

    function n(t) {
        return null !== t && "object" == typeof t
    }
    t.exports = n
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(0),
        r = function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(n),
        s = i(2),
        a = function(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(s),
        o = function(t, e) {
            a.default.call(this), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof r.ShaderMaterial ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = r.UniformsUtils.clone(t.uniforms), this.material = new r.ShaderMaterial({
                defines: t.defines || {},
                uniforms: this.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader
            })), this.camera = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1), this.scene = new r.Scene, this.quad = new r.Mesh(new r.PlaneBufferGeometry(2, 2), null), this.quad.frustumCulled = !1, this.scene.add(this.quad)
        };
    o.prototype = Object.assign(Object.create(a.default.prototype), {
        constructor: o,
        render: function(t, e, i, n, r) {
            this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.quad.material = this.material, this.renderToScreen ? t.render(this.scene, this.camera) : t.render(this.scene, this.camera, e, this.clear)
        }
    }), e.default = o
}, function(t, e, i) {
    (function(i) {
        var n, r, s = void 0 !== t && t.exports && void 0 !== i ? i : this || window;
        (s._gsQueue || (s._gsQueue = [])).push(function() {
                "use strict";
                s._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                        var n = function(t) {
                                var e, i = [],
                                    n = t.length;
                                for (e = 0; e !== n; i.push(t[e++]));
                                return i
                            },
                            r = function(t, e, i) {
                                var n, r, s = t.cycle;
                                for (n in s) r = s[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                                delete t.cycle
                            },
                            s = function(t, e, n) {
                                i.call(this, t, e, n), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = s.prototype.render
                            },
                            a = i._internals,
                            o = a.isSelector,
                            h = a.isArray,
                            l = s.prototype = i.to({}, .1, {}),
                            c = [];
                        s.version = "1.20.3", l.constructor = s, l.kill()._gc = !1, s.killTweensOf = s.killDelayedCallsTo = i.killTweensOf, s.getTweensOf = i.getTweensOf, s.lagSmoothing = i.lagSmoothing, s.ticker = i.ticker, s.render = i.render, l.invalidate = function() {
                            return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), i.prototype.invalidate.call(this)
                        }, l.updateTo = function(t, e) {
                            var n, r = this.ratio,
                                s = this.vars.immediateRender || t.immediateRender;
                            e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                            for (n in t) this.vars[n] = t[n];
                            if (this._initted || s)
                                if (e) this._initted = !1, s && this.render(0, !0, !0);
                                else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                                var a = this._totalTime;
                                this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
                            } else if (this._initted = !1, this._init(), this._time > 0 || s)
                                for (var o, h = 1 / (1 - r), l = this._firstPT; l;) o = l.s + l.c, l.c *= h, l.s = o - l.c, l = l._next;
                            return this
                        }, l.render = function(t, e, n) {
                            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                            var r, s, o, h, l, c, u, d, p, f = this._dirty ? this.totalDuration() : this._totalDuration,
                                m = this._time,
                                v = this._totalTime,
                                g = this._cycle,
                                y = this._duration,
                                _ = this._rawPrevTime;
                            if (t >= f - 1e-7 && t >= 0 ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, s = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (_ < 0 || t <= 0 && t >= -1e-7 || 1e-10 === _ && "isPause" !== this.data) && _ !== t && (n = !0, _ > 1e-10 && (s = "onReverseComplete")), this._rawPrevTime = d = !e || t || _ === t ? t : 1e-10)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== v || 0 === y && _ > 0) && (s = "onReverseComplete", r = this._reversed), t < 0 && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || n) && (_ >= 0 && (n = !0), this._rawPrevTime = d = !e || t || _ === t ? t : 1e-10)), this._initted || (n = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (h = y + this._repeatDelay, this._cycle = this._totalTime / h >> 0, 0 !== this._cycle && this._cycle === this._totalTime / h && v <= t && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 0 != (1 & this._cycle) && (this._time = y - this._time, (p = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== p || this._initted ? this._yoyoEase = p = !0 === p ? this._ease : p instanceof Ease ? p : Ease.map[p] : (p = this.vars.ease, this._yoyoEase = p = p ? p instanceof Ease ? p : "function" == typeof p ? new Ease(p, this.vars.easeParams) : Ease.map[p] || i.defaultEase : i.defaultEase)), this.ratio = p ? 1 - p.getRatio((y - this._time) / y) : 0)), this._time > y ? this._time = y : this._time < 0 && (this._time = 0)), this._easeType && !p ? (l = this._time / y, c = this._easeType, u = this._easePower, (1 === c || 3 === c && l >= .5) && (l = 1 - l), 3 === c && (l *= 2), 1 === u ? l *= l : 2 === u ? l *= l * l : 3 === u ? l *= l * l * l : 4 === u && (l *= l * l * l * l), 1 === c ? this.ratio = 1 - l : 2 === c ? this.ratio = l : this._time / y < .5 ? this.ratio = l / 2 : this.ratio = 1 - l / 2) : p || (this.ratio = this._ease.getRatio(this._time / y))), m === this._time && !n && g === this._cycle) return void(v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
                            if (!this._initted) {
                                if (this._init(), !this._initted || this._gc) return;
                                if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = m, this._totalTime = v, this._rawPrevTime = _, this._cycle = g, a.lazyTweens.push(this), void(this._lazy = [t, e]);
                                !this._time || r || p ? r && this._ease._calcEnd && !p && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / y)
                            }
                            for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== m && t >= 0 && (this._active = !0), 0 === v && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, n) : s || (s = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== y || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                            this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, !0, n), e || (this._totalTime !== v || s) && this._callback("onUpdate")), this._cycle !== g && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), s && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[s] && this._callback(s), 0 === y && 1e-10 === this._rawPrevTime && 1e-10 !== d && (this._rawPrevTime = 0)))
                        }, s.to = function(t, e, i) {
                            return new s(t, e, i)
                        }, s.from = function(t, e, i) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new s(t, e, i)
                        }, s.fromTo = function(t, e, i, n) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new s(t, e, n)
                        }, s.staggerTo = s.allTo = function(t, e, a, l, u, d, p) {
                            l = l || 0;
                            var f, m, v, g, y = 0,
                                _ = [],
                                x = function() {
                                    a.onComplete && a.onComplete.apply(a.onCompleteScope || this, arguments), u.apply(p || a.callbackScope || this, d || c)
                                },
                                b = a.cycle,
                                w = a.startAt && a.startAt.cycle;
                            for (h(t) || ("string" == typeof t && (t = i.selector(t) || t), o(t) && (t = n(t))), t = t || [], l < 0 && (t = n(t), t.reverse(), l *= -1), f = t.length - 1, v = 0; v <= f; v++) {
                                m = {};
                                for (g in a) m[g] = a[g];
                                if (b && (r(m, t, v), null != m.duration && (e = m.duration, delete m.duration)), w) {
                                    w = m.startAt = {};
                                    for (g in a.startAt) w[g] = a.startAt[g];
                                    r(m.startAt, t, v)
                                }
                                m.delay = y + (m.delay || 0), v === f && u && (m.onComplete = x), _[v] = new s(t[v], e, m), y += l
                            }
                            return _
                        }, s.staggerFrom = s.allFrom = function(t, e, i, n, r, a, o) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, s.staggerTo(t, e, i, n, r, a, o)
                        }, s.staggerFromTo = s.allFromTo = function(t, e, i, n, r, a, o, h) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, s.staggerTo(t, e, n, r, a, o, h)
                        }, s.delayedCall = function(t, e, i, n, r) {
                            return new s(e, 0, {
                                delay: t,
                                onComplete: e,
                                onCompleteParams: i,
                                callbackScope: n,
                                onReverseComplete: e,
                                onReverseCompleteParams: i,
                                immediateRender: !1,
                                useFrames: r,
                                overwrite: 0
                            })
                        }, s.set = function(t, e) {
                            return new s(t, 0, e)
                        }, s.isTweening = function(t) {
                            return i.getTweensOf(t, !0).length > 0
                        };
                        var u = function(t, e) {
                                for (var n = [], r = 0, s = t._first; s;) s instanceof i ? n[r++] = s : (e && (n[r++] = s), n = n.concat(u(s, e)), r = n.length), s = s._next;
                                return n
                            },
                            d = s.getAllTweens = function(e) {
                                return u(t._rootTimeline, e).concat(u(t._rootFramesTimeline, e))
                            };
                        s.killAll = function(t, i, n, r) {
                            null == i && (i = !0), null == n && (n = !0);
                            var s, a, o, h = d(0 != r),
                                l = h.length,
                                c = i && n && r;
                            for (o = 0; o < l; o++) a = h[o], (c || a instanceof e || (s = a.target === a.vars.onComplete) && n || i && !s) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
                        }, s.killChildTweensOf = function(t, e) {
                            if (null != t) {
                                var r, l, c, u, d, p = a.tweenLookup;
                                if ("string" == typeof t && (t = i.selector(t) || t), o(t) && (t = n(t)), h(t))
                                    for (u = t.length; --u > -1;) s.killChildTweensOf(t[u], e);
                                else {
                                    r = [];
                                    for (c in p)
                                        for (l = p[c].target.parentNode; l;) l === t && (r = r.concat(p[c].tweens)), l = l.parentNode;
                                    for (d = r.length, u = 0; u < d; u++) e && r[u].totalTime(r[u].totalDuration()), r[u]._enabled(!1, !1)
                                }
                            }
                        };
                        var p = function(t, i, n, r) {
                            i = !1 !== i, n = !1 !== n, r = !1 !== r;
                            for (var s, a, o = d(r), h = i && n && r, l = o.length; --l > -1;) a = o[l], (h || a instanceof e || (s = a.target === a.vars.onComplete) && n || i && !s) && a.paused(t)
                        };
                        return s.pauseAll = function(t, e, i) {
                            p(!0, t, e, i)
                        }, s.resumeAll = function(t, e, i) {
                            p(!1, t, e, i)
                        }, s.globalTimeScale = function(e) {
                            var n = t._rootTimeline,
                                r = i.ticker.time;
                            return arguments.length ? (e = e || 1e-10, n._startTime = r - (r - n._startTime) * n._timeScale / e, n = t._rootFramesTimeline, r = i.ticker.frame, n._startTime = r - (r - n._startTime) * n._timeScale / e, n._timeScale = t._rootTimeline._timeScale = e, e) : n._timeScale
                        }, l.progress = function(t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
                        }, l.totalProgress = function(t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                        }, l.time = function(t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, l.duration = function(e) {
                            return arguments.length ? t.prototype.duration.call(this, e) : this._duration
                        }, l.totalDuration = function(t) {
                            return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                        }, l.repeat = function(t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, l.repeatDelay = function(t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, l.yoyo = function(t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, s
                    }, !0), s._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                        var n = function(t) {
                                e.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                                var i, n, r = this.vars;
                                for (n in r) i = r[n], h(i) && -1 !== i.join("").indexOf("{self}") && (r[n] = this._swapSelfInParams(i));
                                h(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                            },
                            r = i._internals,
                            a = n._internals = {},
                            o = r.isSelector,
                            h = r.isArray,
                            l = r.lazyTweens,
                            c = r.lazyRender,
                            u = s._gsDefine.globals,
                            d = function(t) {
                                var e, i = {};
                                for (e in t) i[e] = t[e];
                                return i
                            },
                            p = function(t, e, i) {
                                var n, r, s = t.cycle;
                                for (n in s) r = s[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                                delete t.cycle
                            },
                            f = a.pauseCallback = function() {},
                            m = function(t) {
                                var e, i = [],
                                    n = t.length;
                                for (e = 0; e !== n; i.push(t[e++]));
                                return i
                            },
                            v = n.prototype = new e;
                        return n.version = "1.20.3", v.constructor = n, v.kill()._gc = v._forcingPlayhead = v._hasPause = !1, v.to = function(t, e, n, r) {
                            var s = n.repeat && u.TweenMax || i;
                            return e ? this.add(new s(t, e, n), r) : this.set(t, n, r)
                        }, v.from = function(t, e, n, r) {
                            return this.add((n.repeat && u.TweenMax || i).from(t, e, n), r)
                        }, v.fromTo = function(t, e, n, r, s) {
                            var a = r.repeat && u.TweenMax || i;
                            return e ? this.add(a.fromTo(t, e, n, r), s) : this.set(t, r, s)
                        }, v.staggerTo = function(t, e, r, s, a, h, l, c) {
                            var u, f, v = new n({
                                    onComplete: h,
                                    onCompleteParams: l,
                                    callbackScope: c,
                                    smoothChildTiming: this.smoothChildTiming
                                }),
                                g = r.cycle;
                            for ("string" == typeof t && (t = i.selector(t) || t), t = t || [], o(t) && (t = m(t)), s = s || 0, s < 0 && (t = m(t), t.reverse(), s *= -1), f = 0; f < t.length; f++) u = d(r), u.startAt && (u.startAt = d(u.startAt), u.startAt.cycle && p(u.startAt, t, f)), g && (p(u, t, f), null != u.duration && (e = u.duration, delete u.duration)), v.to(t[f], e, u, f * s);
                            return this.add(v, a)
                        }, v.staggerFrom = function(t, e, i, n, r, s, a, o) {
                            return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, r, s, a, o)
                        }, v.staggerFromTo = function(t, e, i, n, r, s, a, o, h) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, r, s, a, o, h)
                        }, v.call = function(t, e, n, r) {
                            return this.add(i.delayedCall(0, t, e, n), r)
                        }, v.set = function(t, e, n) {
                            return n = this._parseTimeOrLabel(n, 0, !0), null == e.immediateRender && (e.immediateRender = n === this._time && !this._paused), this.add(new i(t, 0, e), n)
                        }, n.exportRoot = function(t, e) {
                            t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0);
                            var r, s, a, o, h = new n(t),
                                l = h._timeline;
                            for (null == e && (e = !0), l._remove(h, !0), h._startTime = 0, h._rawPrevTime = h._time = h._totalTime = l._time, a = l._first; a;) o = a._next, e && a instanceof i && a.target === a.vars.onComplete || (s = a._startTime - a._delay, s < 0 && (r = 1), h.add(a, s)), a = o;
                            return l.add(h, 0), r && h.totalDuration(), h
                        }, v.add = function(r, s, a, o) {
                            var l, c, u, d, p, f;
                            if ("number" != typeof s && (s = this._parseTimeOrLabel(s, 0, !0, r)), !(r instanceof t)) {
                                if (r instanceof Array || r && r.push && h(r)) {
                                    for (a = a || "normal", o = o || 0, l = s, c = r.length, u = 0; u < c; u++) h(d = r[u]) && (d = new n({
                                        tweens: d
                                    })), this.add(d, l), "string" != typeof d && "function" != typeof d && ("sequence" === a ? l = d._startTime + d.totalDuration() / d._timeScale : "start" === a && (d._startTime -= d.delay())), l += o;
                                    return this._uncache(!0)
                                }
                                if ("string" == typeof r) return this.addLabel(r, s);
                                if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
                                r = i.delayedCall(0, r)
                            }
                            if (e.prototype.add.call(this, r, s), r._time && r.render((this.rawTime() - r._startTime) * r._timeScale, !1, !1), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                                for (p = this, f = p.rawTime() > r._startTime; p._timeline;) f && p._timeline.smoothChildTiming ? p.totalTime(p._totalTime, !0) : p._gc && p._enabled(!0, !1), p = p._timeline;
                            return this
                        }, v.remove = function(e) {
                            if (e instanceof t) {
                                this._remove(e, !1);
                                var i = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
                                return e._startTime = (e._paused ? e._pauseTime : i._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
                            }
                            if (e instanceof Array || e && e.push && h(e)) {
                                for (var n = e.length; --n > -1;) this.remove(e[n]);
                                return this
                            }
                            return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
                        }, v._remove = function(t, i) {
                            return e.prototype._remove.call(this, t, i), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                        }, v.append = function(t, e) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
                        }, v.insert = v.insertMultiple = function(t, e, i, n) {
                            return this.add(t, e || 0, i, n)
                        }, v.appendMultiple = function(t, e, i, n) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
                        }, v.addLabel = function(t, e) {
                            return this._labels[t] = this._parseTimeOrLabel(e), this
                        }, v.addPause = function(t, e, n, r) {
                            var s = i.delayedCall(0, f, n, r || this);
                            return s.vars.onComplete = s.vars.onReverseComplete = e, s.data = "isPause", this._hasPause = !0, this.add(s, t)
                        }, v.removeLabel = function(t) {
                            return delete this._labels[t], this
                        }, v.getLabelTime = function(t) {
                            return null != this._labels[t] ? this._labels[t] : -1
                        }, v._parseTimeOrLabel = function(e, i, n, r) {
                            var s, a;
                            if (r instanceof t && r.timeline === this) this.remove(r);
                            else if (r && (r instanceof Array || r.push && h(r)))
                                for (a = r.length; --a > -1;) r[a] instanceof t && r[a].timeline === this && this.remove(r[a]);
                            if (s = "number" != typeof e || i ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof i) return this._parseTimeOrLabel(i, n && "number" == typeof e && null == this._labels[i] ? e - s : 0, n);
                            if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = s);
                            else {
                                if (-1 === (a = e.indexOf("="))) return null == this._labels[e] ? n ? this._labels[e] = s + i : i : this._labels[e] + i;
                                i = parseInt(e.charAt(a - 1) + "1", 10) * Number(e.substr(a + 1)), e = a > 1 ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, n) : s
                            }
                            return Number(e) + i
                        }, v.seek = function(t, e) {
                            return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
                        }, v.stop = function() {
                            return this.paused(!0)
                        }, v.gotoAndPlay = function(t, e) {
                            return this.play(t, e)
                        }, v.gotoAndStop = function(t, e) {
                            return this.pause(t, e)
                        }, v.render = function(t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var n, r, s, a, o, h, u, d = this._time,
                                p = this._dirty ? this.totalDuration() : this._totalDuration,
                                f = this._startTime,
                                m = this._timeScale,
                                v = this._paused;
                            if (d !== this._time && (t += this._time - d), t >= p - 1e-7 && t >= 0) this._totalTime = this._time = p, this._reversed || this._hasPausedChild() || (r = !0, a = "onComplete", o = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || 1e-10 === this._rawPrevTime) && this._rawPrevTime !== t && this._first && (o = !0, this._rawPrevTime > 1e-10 && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, t = p + 1e-4;
                            else if (t < 1e-7)
                                if (this._totalTime = this._time = 0, (0 !== d || 0 === this._duration && 1e-10 !== this._rawPrevTime && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (a = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (o = r = !0, a = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (o = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                                        for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                                    t = 0, this._initted || (o = !0)
                                }
                            else {
                                if (this._hasPause && !this._forcingPlayhead && !e) {
                                    if (t >= d)
                                        for (n = this._first; n && n._startTime <= t && !h;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (h = n), n = n._next;
                                    else
                                        for (n = this._last; n && n._startTime >= t && !h;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (h = n), n = n._prev;
                                    h && (this._time = t = h._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                                }
                                this._totalTime = this._time = this._rawPrevTime = t
                            }
                            if (this._time !== d && this._first || i || o || h) {
                                if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== d && t > 0 && (this._active = !0), 0 === d && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (u = this._time) >= d)
                                    for (n = this._first; n && (s = n._next, u === this._time && (!this._paused || v));)(n._active || n._startTime <= u && !n._paused && !n._gc) && (h === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = s;
                                else
                                    for (n = this._last; n && (s = n._prev, u === this._time && (!this._paused || v));) {
                                        if (n._active || n._startTime <= d && !n._paused && !n._gc) {
                                            if (h === n) {
                                                for (h = n._prev; h && h.endTime() > this._time;) h.render(h._reversed ? h.totalDuration() - (t - h._startTime) * h._timeScale : (t - h._startTime) * h._timeScale, e, i), h = h._prev;
                                                h = null, this.pause()
                                            }
                                            n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                        }
                                        n = s
                                    }
                                this._onUpdate && (e || (l.length && c(), this._callback("onUpdate"))), a && (this._gc || f !== this._startTime && m === this._timeScale || (0 === this._time || p >= this.totalDuration()) && (r && (l.length && c(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a)))
                            }
                        }, v._hasPausedChild = function() {
                            for (var t = this._first; t;) {
                                if (t._paused || t instanceof n && t._hasPausedChild()) return !0;
                                t = t._next
                            }
                            return !1
                        }, v.getChildren = function(t, e, n, r) {
                            r = r || -9999999999;
                            for (var s = [], a = this._first, o = 0; a;) a._startTime < r || (a instanceof i ? !1 !== e && (s[o++] = a) : (!1 !== n && (s[o++] = a), !1 !== t && (s = s.concat(a.getChildren(!0, e, n)), o = s.length))), a = a._next;
                            return s
                        }, v.getTweensOf = function(t, e) {
                            var n, r, s = this._gc,
                                a = [],
                                o = 0;
                            for (s && this._enabled(!0, !0), n = i.getTweensOf(t), r = n.length; --r > -1;)(n[r].timeline === this || e && this._contains(n[r])) && (a[o++] = n[r]);
                            return s && this._enabled(!1, !0), a
                        }, v.recent = function() {
                            return this._recent
                        }, v._contains = function(t) {
                            for (var e = t.timeline; e;) {
                                if (e === this) return !0;
                                e = e.timeline
                            }
                            return !1
                        }, v.shiftChildren = function(t, e, i) {
                            i = i || 0;
                            for (var n, r = this._first, s = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                            if (e)
                                for (n in s) s[n] >= i && (s[n] += t);
                            return this._uncache(!0)
                        }, v._kill = function(t, e) {
                            if (!t && !e) return this._enabled(!1, !1);
                            for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1;) i[n]._kill(t, e) && (r = !0);
                            return r
                        }, v.clear = function(t) {
                            var e = this.getChildren(!1, !0, !0),
                                i = e.length;
                            for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
                            return !1 !== t && (this._labels = {}), this._uncache(!0)
                        }, v.invalidate = function() {
                            for (var e = this._first; e;) e.invalidate(), e = e._next;
                            return t.prototype.invalidate.call(this)
                        }, v._enabled = function(t, i) {
                            if (t === this._gc)
                                for (var n = this._first; n;) n._enabled(t, !0), n = n._next;
                            return e.prototype._enabled.call(this, t, i)
                        }, v.totalTime = function(e, i, n) {
                            this._forcingPlayhead = !0;
                            var r = t.prototype.totalTime.apply(this, arguments);
                            return this._forcingPlayhead = !1, r
                        }, v.duration = function(t) {
                            return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
                        }, v.totalDuration = function(t) {
                            if (!arguments.length) {
                                if (this._dirty) {
                                    for (var e, i, n = 0, r = this._last, s = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > s && this._sortChildren && !r._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(r, r._startTime - r._delay), this._calculatingDuration = 0) : s = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale, this._time -= r._startTime, this._totalTime -= r._startTime, this._rawPrevTime -= r._startTime), this.shiftChildren(-r._startTime, !1, -9999999999), s = 0), i = r._startTime + r._totalDuration / r._timeScale, i > n && (n = i), r = e;
                                    this._duration = this._totalDuration = n, this._dirty = !1
                                }
                                return this._totalDuration
                            }
                            return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
                        }, v.paused = function(e) {
                            if (!e)
                                for (var i = this._first, n = this._time; i;) i._startTime === n && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
                            return t.prototype.paused.apply(this, arguments)
                        }, v.usesFrames = function() {
                            for (var e = this._timeline; e._timeline;) e = e._timeline;
                            return e === t._rootFramesTimeline
                        }, v.rawTime = function(t) {
                            return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
                        }, n
                    }, !0), s._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, i) {
                        var n = function(e) {
                                t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
                            },
                            r = e._internals,
                            a = r.lazyTweens,
                            o = r.lazyRender,
                            h = s._gsDefine.globals,
                            l = new i(null, null, 1, 0),
                            c = n.prototype = new t;
                        return c.constructor = n, c.kill()._gc = !1, n.version = "1.20.3", c.invalidate = function() {
                            return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
                        }, c.addCallback = function(t, i, n, r) {
                            return this.add(e.delayedCall(0, t, n, r), i)
                        }, c.removeCallback = function(t, e) {
                            if (t)
                                if (null == e) this._kill(null, t);
                                else
                                    for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); --n > -1;) i[n]._startTime === r && i[n]._enabled(!1, !1);
                            return this
                        }, c.removePause = function(e) {
                            return this.removeCallback(t._internals.pauseCallback, e)
                        }, c.tweenTo = function(t, i) {
                            i = i || {};
                            var n, r, s, a = {
                                    ease: l,
                                    useFrames: this.usesFrames(),
                                    immediateRender: !1
                                },
                                o = i.repeat && h.TweenMax || e;
                            for (r in i) a[r] = i[r];
                            return a.time = this._parseTimeOrLabel(t), n = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, s = new o(this, n, a), a.onStart = function() {
                                s.target.paused(!0), s.vars.time !== s.target.time() && n === s.duration() && s.duration(Math.abs(s.vars.time - s.target.time()) / s.target._timeScale), i.onStart && i.onStart.apply(i.onStartScope || i.callbackScope || s, i.onStartParams || [])
                            }, s
                        }, c.tweenFromTo = function(t, e, i) {
                            i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                                onComplete: this.seek,
                                onCompleteParams: [t],
                                callbackScope: this
                            }, i.immediateRender = !1 !== i.immediateRender;
                            var n = this.tweenTo(e, i);
                            return n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
                        }, c.render = function(t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var n, r, s, h, l, c, u, d, p = this._time,
                                f = this._dirty ? this.totalDuration() : this._totalDuration,
                                m = this._duration,
                                v = this._totalTime,
                                g = this._startTime,
                                y = this._timeScale,
                                _ = this._rawPrevTime,
                                x = this._paused,
                                b = this._cycle;
                            if (p !== this._time && (t += this._time - p), t >= f - 1e-7 && t >= 0) this._locked || (this._totalTime = f, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (r = !0, h = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || _ < 0 || 1e-10 === _) && _ !== t && this._first && (l = !0, _ > 1e-10 && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : (this._time = m, t = m + 1e-4);
                            else if (t < 1e-7)
                                if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== p || 0 === m && 1e-10 !== _ && (_ > 0 || t < 0 && _ >= 0) && !this._locked) && (h = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = r = !0, h = "onReverseComplete") : _ >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = m || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                                        for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                                    t = 0, this._initted || (l = !0)
                                }
                            else if (0 === m && _ < 0 && (l = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (c = m + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && v <= t && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 != (1 & this._cycle) && (this._time = m - this._time), this._time > m ? (this._time = m, t = m + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) {
                                if ((t = this._time) >= p || this._repeat && b !== this._cycle)
                                    for (n = this._first; n && n._startTime <= t && !u;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (u = n), n = n._next;
                                else
                                    for (n = this._last; n && n._startTime >= t && !u;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (u = n), n = n._prev;
                                u && u._startTime < m && (this._time = t = u._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                            }
                            if (this._cycle !== b && !this._locked) {
                                var w = this._yoyo && 0 != (1 & b),
                                    T = w === (this._yoyo && 0 != (1 & this._cycle)),
                                    M = this._totalTime,
                                    E = this._cycle,
                                    S = this._rawPrevTime,
                                    A = this._time;
                                if (this._totalTime = b * m, this._cycle < b ? w = !w : this._totalTime += m, this._time = p, this._rawPrevTime = 0 === m ? _ - 1e-4 : _, this._cycle = b, this._locked = !0, p = w ? 0 : m, this.render(p, e, 0 === m), e || this._gc || this.vars.onRepeat && (this._cycle = E, this._locked = !1, this._callback("onRepeat")), p !== this._time) return;
                                if (T && (this._cycle = b, this._locked = !0, p = w ? m + 1e-4 : -1e-4, this.render(p, !0, !1)), this._locked = !1, this._paused && !x) return;
                                this._time = A, this._totalTime = M, this._cycle = E, this._rawPrevTime = S
                            }
                            if (!(this._time !== p && this._first || i || l || u)) return void(v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
                            if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== v && t > 0 && (this._active = !0), 0 === v && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (d = this._time) >= p)
                                for (n = this._first; n && (s = n._next, d === this._time && (!this._paused || x));)(n._active || n._startTime <= this._time && !n._paused && !n._gc) && (u === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = s;
                            else
                                for (n = this._last; n && (s = n._prev, d === this._time && (!this._paused || x));) {
                                    if (n._active || n._startTime <= p && !n._paused && !n._gc) {
                                        if (u === n) {
                                            for (u = n._prev; u && u.endTime() > this._time;) u.render(u._reversed ? u.totalDuration() - (t - u._startTime) * u._timeScale : (t - u._startTime) * u._timeScale, e, i), u = u._prev;
                                            u = null, this.pause()
                                        }
                                        n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                    }
                                    n = s
                                }
                            this._onUpdate && (e || (a.length && o(), this._callback("onUpdate"))), h && (this._locked || this._gc || g !== this._startTime && y === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (r && (a.length && o(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[h] && this._callback(h)))
                        }, c.getActive = function(t, e, i) {
                            null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
                            var n, r, s = [],
                                a = this.getChildren(t, e, i),
                                o = 0,
                                h = a.length;
                            for (n = 0; n < h; n++) r = a[n], r.isActive() && (s[o++] = r);
                            return s
                        }, c.getLabelAfter = function(t) {
                            t || 0 !== t && (t = this._time);
                            var e, i = this.getLabelsArray(),
                                n = i.length;
                            for (e = 0; e < n; e++)
                                if (i[e].time > t) return i[e].name;
                            return null
                        }, c.getLabelBefore = function(t) {
                            null == t && (t = this._time);
                            for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                                if (e[i].time < t) return e[i].name;
                            return null
                        }, c.getLabelsArray = function() {
                            var t, e = [],
                                i = 0;
                            for (t in this._labels) e[i++] = {
                                time: this._labels[t],
                                name: t
                            };
                            return e.sort(function(t, e) {
                                return t.time - e.time
                            }), e
                        }, c.invalidate = function() {
                            return this._locked = !1, t.prototype.invalidate.call(this)
                        }, c.progress = function(t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
                        }, c.totalProgress = function(t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
                        }, c.totalDuration = function(e) {
                            return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                        }, c.time = function(t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, c.repeat = function(t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, c.repeatDelay = function(t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, c.yoyo = function(t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, c.currentLabel = function(t) {
                            return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
                        }, n
                    }, !0),
                    function() {
                        var t = 180 / Math.PI,
                            e = [],
                            i = [],
                            n = [],
                            r = {},
                            a = s._gsDefine.globals,
                            o = function(t, e, i, n) {
                                i === n && (i = n - (n - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
                            },
                            h = function(t, e, i, n) {
                                var r = {
                                        a: t
                                    },
                                    s = {},
                                    a = {},
                                    o = {
                                        c: n
                                    },
                                    h = (t + e) / 2,
                                    l = (e + i) / 2,
                                    c = (i + n) / 2,
                                    u = (h + l) / 2,
                                    d = (l + c) / 2,
                                    p = (d - u) / 8;
                                return r.b = h + (t - h) / 4, s.b = u + p, r.c = s.a = (r.b + s.b) / 2, s.c = a.a = (u + d) / 2, a.b = d - p, o.b = c + (n - c) / 4, a.c = o.a = (a.b + o.b) / 2, [r, s, a, o]
                            },
                            l = function(t, r, s, a, o) {
                                var l, c, u, d, p, f, m, v, g, y, _, x, b, w = t.length - 1,
                                    T = 0,
                                    M = t[0].a;
                                for (l = 0; l < w; l++) p = t[T], c = p.a, u = p.d, d = t[T + 1].d, o ? (_ = e[l], x = i[l], b = (x + _) * r * .25 / (a ? .5 : n[l] || .5), f = u - (u - c) * (a ? .5 * r : 0 !== _ ? b / _ : 0), m = u + (d - u) * (a ? .5 * r : 0 !== x ? b / x : 0), v = u - (f + ((m - f) * (3 * _ / (_ + x) + .5) / 4 || 0))) : (f = u - (u - c) * r * .5, m = u + (d - u) * r * .5, v = u - (f + m) / 2), f += v, m += v, p.c = g = f, p.b = 0 !== l ? M : M = p.a + .6 * (p.c - p.a), p.da = u - c, p.ca = g - c, p.ba = M - c, s ? (y = h(c, M, g, u), t.splice(T, 1, y[0], y[1], y[2], y[3]), T += 4) : T++, M = m;
                                p = t[T], p.b = M, p.c = M + .4 * (p.d - M), p.da = p.d - p.a, p.ca = p.c - p.a, p.ba = M - p.a, s && (y = h(p.a, M, p.c, p.d), t.splice(T, 1, y[0], y[1], y[2], y[3]))
                            },
                            c = function(t, n, r, s) {
                                var a, h, l, c, u, d, p = [];
                                if (s)
                                    for (t = [s].concat(t), h = t.length; --h > -1;) "string" == typeof(d = t[h][n]) && "=" === d.charAt(1) && (t[h][n] = s[n] + Number(d.charAt(0) + d.substr(2)));
                                if ((a = t.length - 2) < 0) return p[0] = new o(t[0][n], 0, 0, t[0][n]), p;
                                for (h = 0; h < a; h++) l = t[h][n], c = t[h + 1][n], p[h] = new o(l, 0, 0, c), r && (u = t[h + 2][n], e[h] = (e[h] || 0) + (c - l) * (c - l), i[h] = (i[h] || 0) + (u - c) * (u - c));
                                return p[h] = new o(t[h][n], 0, 0, t[h + 1][n]), p
                            },
                            u = function(t, s, a, o, h, u) {
                                var d, p, f, m, v, g, y, _, x = {},
                                    b = [],
                                    w = u || t[0];
                                h = "string" == typeof h ? "," + h + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == s && (s = 1);
                                for (p in t[0]) b.push(p);
                                if (t.length > 1) {
                                    for (_ = t[t.length - 1], y = !0, d = b.length; --d > -1;)
                                        if (p = b[d], Math.abs(w[p] - _[p]) > .05) {
                                            y = !1;
                                            break
                                        }
                                    y && (t = t.concat(), u && t.unshift(u), t.push(t[1]), u = t[t.length - 3])
                                }
                                for (e.length = i.length = n.length = 0, d = b.length; --d > -1;) p = b[d], r[p] = -1 !== h.indexOf("," + p + ","), x[p] = c(t, p, r[p], u);
                                for (d = e.length; --d > -1;) e[d] = Math.sqrt(e[d]), i[d] = Math.sqrt(i[d]);
                                if (!o) {
                                    for (d = b.length; --d > -1;)
                                        if (r[p])
                                            for (f = x[b[d]], g = f.length - 1, m = 0; m < g; m++) v = f[m + 1].da / i[m] + f[m].da / e[m] || 0, n[m] = (n[m] || 0) + v * v;
                                    for (d = n.length; --d > -1;) n[d] = Math.sqrt(n[d])
                                }
                                for (d = b.length, m = a ? 4 : 1; --d > -1;) p = b[d], f = x[p], l(f, s, a, o, r[p]), y && (f.splice(0, m), f.splice(f.length - m, m));
                                return x
                            },
                            d = function(t, e, i) {
                                e = e || "soft";
                                var n, r, s, a, h, l, c, u, d, p, f, m = {},
                                    v = "cubic" === e ? 3 : 2,
                                    g = "soft" === e,
                                    y = [];
                                if (g && i && (t = [i].concat(t)), null == t || t.length < v + 1) throw "invalid Bezier data";
                                for (d in t[0]) y.push(d);
                                for (l = y.length; --l > -1;) {
                                    for (d = y[l], m[d] = h = [], p = 0, u = t.length, c = 0; c < u; c++) n = null == i ? t[c][d] : "string" == typeof(f = t[c][d]) && "=" === f.charAt(1) ? i[d] + Number(f.charAt(0) + f.substr(2)) : Number(f), g && c > 1 && c < u - 1 && (h[p++] = (n + h[p - 2]) / 2), h[p++] = n;
                                    for (u = p - v + 1, p = 0, c = 0; c < u; c += v) n = h[c], r = h[c + 1], s = h[c + 2], a = 2 === v ? 0 : h[c + 3], h[p++] = f = 3 === v ? new o(n, r, s, a) : new o(n, (2 * r + n) / 3, (2 * r + s) / 3, s);
                                    h.length = p
                                }
                                return m
                            },
                            p = function(t, e, i) {
                                for (var n, r, s, a, o, h, l, c, u, d, p, f = 1 / i, m = t.length; --m > -1;)
                                    for (d = t[m], s = d.a, a = d.d - s, o = d.c - s, h = d.b - s, n = r = 0, c = 1; c <= i; c++) l = f * c, u = 1 - l, n = r - (r = (l * l * a + 3 * u * (l * o + u * h)) * l), p = m * i + c - 1, e[p] = (e[p] || 0) + n * n
                            },
                            f = function(t, e) {
                                e = e >> 0 || 6;
                                var i, n, r, s, a = [],
                                    o = [],
                                    h = 0,
                                    l = 0,
                                    c = e - 1,
                                    u = [],
                                    d = [];
                                for (i in t) p(t[i], a, e);
                                for (r = a.length, n = 0; n < r; n++) h += Math.sqrt(a[n]), s = n % e, d[s] = h, s === c && (l += h, s = n / e >> 0, u[s] = d, o[s] = l, h = 0, d = []);
                                return {
                                    length: l,
                                    lengths: o,
                                    segments: u
                                }
                            },
                            m = s._gsDefine.plugin({
                                propName: "bezier",
                                priority: -1,
                                version: "1.3.8",
                                API: 2,
                                global: !0,
                                init: function(t, e, i) {
                                    this._target = t, e instanceof Array && (e = {
                                        values: e
                                    }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                                    var n, r, s, a, o, h = e.values || [],
                                        l = {},
                                        c = h[0],
                                        p = e.autoRotate || i.vars.orientToBezier;
                                    this._autoRotate = p ? p instanceof Array ? p : [
                                        ["x", "y", "rotation", !0 === p ? 0 : Number(p) || 0]
                                    ] : null;
                                    for (n in c) this._props.push(n);
                                    for (s = this._props.length; --s > -1;) n = this._props[s], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], l[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), o || l[n] !== h[0][n] && (o = l);
                                    if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? u(h, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, o) : d(h, e.type, l), this._segCount = this._beziers[n].length, this._timeRes) {
                                        var m = f(this._beziers, this._timeRes);
                                        this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                                    }
                                    if (p = this._autoRotate)
                                        for (this._initialRotations = [], p[0] instanceof Array || (this._autoRotate = p = [p]), s = p.length; --s > -1;) {
                                            for (a = 0; a < 3; a++) n = p[s][a], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                                            n = p[s][2], this._initialRotations[s] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n)
                                        }
                                    return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                                },
                                set: function(e) {
                                    var i, n, r, s, a, o, h, l, c, u, d = this._segCount,
                                        p = this._func,
                                        f = this._target,
                                        m = e !== this._startRatio;
                                    if (this._timeRes) {
                                        if (c = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && r < d - 1) {
                                            for (l = d - 1; r < l && (this._l2 = c[++r]) <= e;);
                                            this._l1 = c[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0]
                                        } else if (e < this._l1 && r > 0) {
                                            for (; r > 0 && (this._l1 = c[--r]) >= e;);
                                            0 === r && e < this._l1 ? this._l1 = 0 : r++, this._l2 = c[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                                        }
                                        if (i = r, e -= this._l1, r = this._si, e > this._s2 && r < u.length - 1) {
                                            for (l = u.length - 1; r < l && (this._s2 = u[++r]) <= e;);
                                            this._s1 = u[r - 1], this._si = r
                                        } else if (e < this._s1 && r > 0) {
                                            for (; r > 0 && (this._s1 = u[--r]) >= e;);
                                            0 === r && e < this._s1 ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r
                                        }
                                        o = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                                    } else i = e < 0 ? 0 : e >= 1 ? d - 1 : d * e >> 0, o = (e - i * (1 / d)) * d;
                                    for (n = 1 - o, r = this._props.length; --r > -1;) s = this._props[r], a = this._beziers[s][i], h = (o * o * a.da + 3 * n * (o * a.ca + n * a.ba)) * o + a.a, this._mod[s] && (h = this._mod[s](h, f)), p[s] ? f[s](h) : f[s] = h;
                                    if (this._autoRotate) {
                                        var v, g, y, _, x, b, w, T = this._autoRotate;
                                        for (r = T.length; --r > -1;) s = T[r][2], b = T[r][3] || 0, w = !0 === T[r][4] ? 1 : t, a = this._beziers[T[r][0]], v = this._beziers[T[r][1]], a && v && (a = a[i], v = v[i], g = a.a + (a.b - a.a) * o, _ = a.b + (a.c - a.b) * o, g += (_ - g) * o, _ += (a.c + (a.d - a.c) * o - _) * o, y = v.a + (v.b - v.a) * o, x = v.b + (v.c - v.b) * o, y += (x - y) * o, x += (v.c + (v.d - v.c) * o - x) * o, h = m ? Math.atan2(x - y, _ - g) * w + b : this._initialRotations[r], this._mod[s] && (h = this._mod[s](h, f)), p[s] ? f[s](h) : f[s] = h)
                                    }
                                }
                            }),
                            v = m.prototype;
                        m.bezierThrough = u, m.cubicToQuadratic = h, m._autoCSS = !0, m.quadraticToCubic = function(t, e, i) {
                            return new o(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
                        }, m._cssRegister = function() {
                            var t = a.CSSPlugin;
                            if (t) {
                                var e = t._internals,
                                    i = e._parseToProxy,
                                    n = e._setPluginRatio,
                                    r = e.CSSPropTween;
                                e._registerComplexSpecialProp("bezier", {
                                    parser: function(t, e, s, a, o, h) {
                                        e instanceof Array && (e = {
                                            values: e
                                        }), h = new m;
                                        var l, c, u, d = e.values,
                                            p = d.length - 1,
                                            f = [],
                                            v = {};
                                        if (p < 0) return o;
                                        for (l = 0; l <= p; l++) u = i(t, d[l], a, o, h, p !== l), f[l] = u.end;
                                        for (c in e) v[c] = e[c];
                                        return v.values = f, o = new r(t, "bezier", 0, 0, u.pt, 2), o.data = u, o.plugin = h, o.setRatio = n, 0 === v.autoRotate && (v.autoRotate = !0), !v.autoRotate || v.autoRotate instanceof Array || (l = !0 === v.autoRotate ? 0 : Number(v.autoRotate), v.autoRotate = null != u.end.left ? [
                                            ["left", "top", "rotation", l, !1]
                                        ] : null != u.end.x && [
                                            ["x", "y", "rotation", l, !1]
                                        ]), v.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, a._overwriteProps.push("rotation")), h._onInitTween(u.proxy, v, a._tween), o
                                    }
                                })
                            }
                        }, v._mod = function(t) {
                            for (var e, i = this._overwriteProps, n = i.length; --n > -1;)(e = t[i[n]]) && "function" == typeof e && (this._mod[i[n]] = e)
                        }, v._kill = function(t) {
                            var e, i, n = this._props;
                            for (e in this._beziers)
                                if (e in t)
                                    for (delete this._beziers[e], delete this._func[e], i = n.length; --i > -1;) n[i] === e && n.splice(i, 1);
                            if (n = this._autoRotate)
                                for (i = n.length; --i > -1;) t[n[i][2]] && n.splice(i, 1);
                            return this._super._kill.call(this, t)
                        }
                    }(), s._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) {
                        var i, n, r, a, o = function() {
                                t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = o.prototype.setRatio
                            },
                            h = s._gsDefine.globals,
                            l = {},
                            c = o.prototype = new t("css");
                        c.constructor = o, o.version = "1.20.3", o.API = 2, o.defaultTransformPerspective = 0, o.defaultSkewType = "compensated", o.defaultSmoothOrigin = !0, c = "px", o.suffixMap = {
                            top: c,
                            right: c,
                            bottom: c,
                            left: c,
                            width: c,
                            height: c,
                            fontSize: c,
                            padding: c,
                            margin: c,
                            perspective: c,
                            lineHeight: ""
                        };
                        var u, d, p, f, m, v, g, y, _ = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                            x = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                            b = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                            w = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                            T = /(?:\d|\-|\+|=|#|\.)*/g,
                            M = /opacity *= *([^)]*)/i,
                            E = /opacity:([^;]*)/i,
                            S = /alpha\(opacity *=.+?\)/i,
                            A = /^(rgb|hsl)/,
                            P = /([A-Z])/g,
                            R = /-([a-z])/gi,
                            C = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                            L = function(t, e) {
                                return e.toUpperCase()
                            },
                            O = /(?:Left|Right|Width)/i,
                            I = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                            D = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                            z = /,(?=[^\)]*(?:\(|$))/gi,
                            U = /[\s,\(]/i,
                            N = Math.PI / 180,
                            k = 180 / Math.PI,
                            F = {},
                            B = {
                                style: {}
                            },
                            G = s.document || {
                                createElement: function() {
                                    return B
                                }
                            },
                            H = function(t, e) {
                                return G.createElementNS ? G.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : G.createElement(t)
                            },
                            j = H("div"),
                            V = H("img"),
                            W = o._internals = {
                                _specialProps: l
                            },
                            X = (s.navigator || {}).userAgent || "",
                            q = function() {
                                var t = X.indexOf("Android"),
                                    e = H("a");
                                return p = -1 !== X.indexOf("Safari") && -1 === X.indexOf("Chrome") && (-1 === t || parseFloat(X.substr(t + 8, 2)) > 3), m = p && parseFloat(X.substr(X.indexOf("Version/") + 8, 2)) < 6, f = -1 !== X.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(X) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(X)) && (v = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
                            }(),
                            Y = function(t) {
                                return M.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                            },
                            Z = function(t) {
                                s.console && console.log(t)
                            },
                            $ = "",
                            Q = "",
                            J = function(t, e) {
                                e = e || j;
                                var i, n, r = e.style;
                                if (void 0 !== r[t]) return t;
                                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === r[i[n] + t];);
                                return n >= 0 ? (Q = 3 === n ? "ms" : i[n], $ = "-" + Q.toLowerCase() + "-", Q + t) : null
                            },
                            K = G.defaultView ? G.defaultView.getComputedStyle : function() {},
                            tt = o.getStyle = function(t, e, i, n, r) {
                                var s;
                                return q || "opacity" !== e ? (!n && t.style[e] ? s = t.style[e] : (i = i || K(t)) ? s = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(P, "-$1").toLowerCase()) : t.currentStyle && (s = t.currentStyle[e]), null == r || s && "none" !== s && "auto" !== s && "auto auto" !== s ? s : r) : Y(t)
                            },
                            et = W.convertToPixels = function(t, i, n, r, s) {
                                if ("px" === r || !r && "lineHeight" !== i) return n;
                                if ("auto" === r || !n) return 0;
                                var a, h, l, c = O.test(i),
                                    u = t,
                                    d = j.style,
                                    p = n < 0,
                                    f = 1 === n;
                                if (p && (n = -n), f && (n *= 100), "lineHeight" !== i || r)
                                    if ("%" === r && -1 !== i.indexOf("border")) a = n / 100 * (c ? t.clientWidth : t.clientHeight);
                                    else {
                                        if (d.cssText = "border:0 solid red;position:" + tt(t, "position") + ";line-height:0;", "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[c ? "borderLeftWidth" : "borderTopWidth"] = n + r;
                                        else {
                                            if (u = t.parentNode || G.body, -1 !== tt(u, "display").indexOf("flex") && (d.position = "absolute"), h = u._gsCache, l = e.ticker.frame, h && c && h.time === l) return h.width * n / 100;
                                            d[c ? "width" : "height"] = n + r
                                        }
                                        u.appendChild(j), a = parseFloat(j[c ? "offsetWidth" : "offsetHeight"]), u.removeChild(j), c && "%" === r && !1 !== o.cacheWidths && (h = u._gsCache = u._gsCache || {}, h.time = l, h.width = a / n * 100), 0 !== a || s || (a = et(t, i, n, r, !0))
                                    }
                                else h = K(t).lineHeight, t.style.lineHeight = n, a = parseFloat(K(t).lineHeight), t.style.lineHeight = h;
                                return f && (a /= 100), p ? -a : a
                            },
                            it = W.calculateOffset = function(t, e, i) {
                                if ("absolute" !== tt(t, "position", i)) return 0;
                                var n = "left" === e ? "Left" : "Top",
                                    r = tt(t, "margin" + n, i);
                                return t["offset" + n] - (et(t, e, parseFloat(r), r.replace(T, "")) || 0)
                            },
                            nt = function(t, e) {
                                var i, n, r, s = {};
                                if (e = e || K(t, null))
                                    if (i = e.length)
                                        for (; --i > -1;) r = e[i], -1 !== r.indexOf("-transform") && Ct !== r || (s[r.replace(R, L)] = e.getPropertyValue(r));
                                    else
                                        for (i in e) - 1 !== i.indexOf("Transform") && Rt !== i || (s[i] = e[i]);
                                else if (e = t.currentStyle || t.style)
                                    for (i in e) "string" == typeof i && void 0 === s[i] && (s[i.replace(R, L)] = e[i]);
                                return q || (s.opacity = Y(t)), n = Vt(t, e, !1), s.rotation = n.rotation, s.skewX = n.skewX, s.scaleX = n.scaleX, s.scaleY = n.scaleY, s.x = n.x, s.y = n.y, Ot && (s.z = n.z, s.rotationX = n.rotationX, s.rotationY = n.rotationY, s.scaleZ = n.scaleZ), s.filters && delete s.filters, s
                            },
                            rt = function(t, e, i, n, r) {
                                var s, a, o, h = {},
                                    l = t.style;
                                for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (s = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" != typeof s && "string" != typeof s || (h[a] = "auto" !== s || "left" !== a && "top" !== a ? "" !== s && "auto" !== s && "none" !== s || "string" != typeof e[a] || "" === e[a].replace(w, "") ? s : 0 : it(t, a), void 0 !== l[a] && (o = new _t(l, a, l[a], o))));
                                if (n)
                                    for (a in n) "className" !== a && (h[a] = n[a]);
                                return {
                                    difs: h,
                                    firstMPT: o
                                }
                            },
                            st = {
                                width: ["Left", "Right"],
                                height: ["Top", "Bottom"]
                            },
                            at = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                            ot = function(t, e, i) {
                                if ("svg" === (t.nodeName + "").toLowerCase()) return (i || K(t))[e] || 0;
                                if (t.getCTM && Gt(t)) return t.getBBox()[e] || 0;
                                var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                                    r = st[e],
                                    s = r.length;
                                for (i = i || K(t, null); --s > -1;) n -= parseFloat(tt(t, "padding" + r[s], i, !0)) || 0, n -= parseFloat(tt(t, "border" + r[s] + "Width", i, !0)) || 0;
                                return n
                            },
                            ht = function(t, e) {
                                if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                                null != t && "" !== t || (t = "0 0");
                                var i, n = t.split(" "),
                                    r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : n[0],
                                    s = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : n[1];
                                if (n.length > 3 && !e) {
                                    for (n = t.split(", ").join(",").split(","), t = [], i = 0; i < n.length; i++) t.push(ht(n[i]));
                                    return t.join(",")
                                }
                                return null == s ? s = "center" === r ? "50%" : "0" : "center" === s && (s = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t = r + " " + s + (n.length > 2 ? " " + n[2] : ""), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== s.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === s.charAt(1), e.ox = parseFloat(r.replace(w, "")), e.oy = parseFloat(s.replace(w, "")), e.v = t), e || t
                            },
                            lt = function(t, e) {
                                return "function" == typeof t && (t = t(y, g)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
                            },
                            ct = function(t, e) {
                                return "function" == typeof t && (t = t(y, g)), null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
                            },
                            ut = function(t, e, i, n) {
                                var r, s, a, o, h;
                                return "function" == typeof t && (t = t(y, g)), null == t ? o = e : "number" == typeof t ? o = t : (r = 360, s = t.split("_"), h = "=" === t.charAt(1), a = (h ? parseInt(t.charAt(0) + "1", 10) * parseFloat(s[0].substr(2)) : parseFloat(s[0])) * (-1 === t.indexOf("rad") ? 1 : k) - (h ? 0 : e), s.length && (n && (n[i] = e + a), -1 !== t.indexOf("short") && (a %= r) !== a % (r / 2) && (a = a < 0 ? a + r : a - r), -1 !== t.indexOf("_cw") && a < 0 ? a = (a + 9999999999 * r) % r - (a / r | 0) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (a / r | 0) * r)), o = e + a), o < 1e-6 && o > -1e-6 && (o = 0), o
                            },
                            dt = {
                                aqua: [0, 255, 255],
                                lime: [0, 255, 0],
                                silver: [192, 192, 192],
                                black: [0, 0, 0],
                                maroon: [128, 0, 0],
                                teal: [0, 128, 128],
                                blue: [0, 0, 255],
                                navy: [0, 0, 128],
                                white: [255, 255, 255],
                                fuchsia: [255, 0, 255],
                                olive: [128, 128, 0],
                                yellow: [255, 255, 0],
                                orange: [255, 165, 0],
                                gray: [128, 128, 128],
                                purple: [128, 0, 128],
                                green: [0, 128, 0],
                                red: [255, 0, 0],
                                pink: [255, 192, 203],
                                cyan: [0, 255, 255],
                                transparent: [255, 255, 255, 0]
                            },
                            pt = function(t, e, i) {
                                return t = t < 0 ? t + 1 : t > 1 ? t - 1 : t, 255 * (6 * t < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
                            },
                            ft = o.parseColor = function(t, e) {
                                var i, n, r, s, a, o, h, l, c, u, d;
                                if (t)
                                    if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                                    else {
                                        if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), dt[t]) i = dt[t];
                                        else if ("#" === t.charAt(0)) 4 === t.length && (n = t.charAt(1), r = t.charAt(2), s = t.charAt(3), t = "#" + n + n + r + r + s + s), t = parseInt(t.substr(1), 16), i = [t >> 16, t >> 8 & 255, 255 & t];
                                        else if ("hsl" === t.substr(0, 3))
                                            if (i = d = t.match(_), e) {
                                                if (-1 !== t.indexOf("=")) return t.match(x)
                                            } else a = Number(i[0]) % 360 / 360, o = Number(i[1]) / 100, h = Number(i[2]) / 100, r = h <= .5 ? h * (o + 1) : h + o - h * o, n = 2 * h - r, i.length > 3 && (i[3] = Number(i[3])), i[0] = pt(a + 1 / 3, n, r), i[1] = pt(a, n, r), i[2] = pt(a - 1 / 3, n, r);
                                        else i = t.match(_) || dt.transparent;
                                        i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                                    }
                                else i = dt.black;
                                return e && !d && (n = i[0] / 255, r = i[1] / 255, s = i[2] / 255, l = Math.max(n, r, s), c = Math.min(n, r, s), h = (l + c) / 2, l === c ? a = o = 0 : (u = l - c, o = h > .5 ? u / (2 - l - c) : u / (l + c), a = l === n ? (r - s) / u + (r < s ? 6 : 0) : l === r ? (s - n) / u + 2 : (n - r) / u + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * o + .5 | 0, i[2] = 100 * h + .5 | 0), i
                            },
                            mt = function(t, e) {
                                var i, n, r, s = t.match(vt) || [],
                                    a = 0,
                                    o = "";
                                if (!s.length) return t;
                                for (i = 0; i < s.length; i++) n = s[i], r = t.substr(a, t.indexOf(n, a) - a), a += r.length + n.length, n = ft(n, e), 3 === n.length && n.push(1), o += r + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                                return o + t.substr(a)
                            },
                            vt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                        for (c in dt) vt += "|" + c + "\\b";
                        vt = new RegExp(vt + ")", "gi"), o.colorStringFilter = function(t) {
                            var e, i = t[0] + " " + t[1];
                            vt.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = mt(t[0], e), t[1] = mt(t[1], e)), vt.lastIndex = 0
                        }, e.defaultStringFilter || (e.defaultStringFilter = o.colorStringFilter);
                        var gt = function(t, e, i, n) {
                                if (null == t) return function(t) {
                                    return t
                                };
                                var r, s = e ? (t.match(vt) || [""])[0] : "",
                                    a = t.split(s).join("").match(b) || [],
                                    o = t.substr(0, t.indexOf(a[0])),
                                    h = ")" === t.charAt(t.length - 1) ? ")" : "",
                                    l = -1 !== t.indexOf(" ") ? " " : ",",
                                    c = a.length,
                                    u = c > 0 ? a[0].replace(_, "") : "";
                                return c ? r = e ? function(t) {
                                    var e, d, p, f;
                                    if ("number" == typeof t) t += u;
                                    else if (n && z.test(t)) {
                                        for (f = t.replace(z, "|").split("|"), p = 0; p < f.length; p++) f[p] = r(f[p]);
                                        return f.join(",")
                                    }
                                    if (e = (t.match(vt) || [s])[0], d = t.split(e).join("").match(b) || [], p = d.length, c > p--)
                                        for (; ++p < c;) d[p] = i ? d[(p - 1) / 2 | 0] : a[p];
                                    return o + d.join(l) + l + e + h + (-1 !== t.indexOf("inset") ? " inset" : "")
                                } : function(t) {
                                    var e, s, d;
                                    if ("number" == typeof t) t += u;
                                    else if (n && z.test(t)) {
                                        for (s = t.replace(z, "|").split("|"), d = 0; d < s.length; d++) s[d] = r(s[d]);
                                        return s.join(",")
                                    }
                                    if (e = t.match(b) || [], d = e.length, c > d--)
                                        for (; ++d < c;) e[d] = i ? e[(d - 1) / 2 | 0] : a[d];
                                    return o + e.join(l) + h
                                } : function(t) {
                                    return t
                                }
                            },
                            yt = function(t) {
                                return t = t.split(","),
                                    function(e, i, n, r, s, a, o) {
                                        var h, l = (i + "").split(" ");
                                        for (o = {}, h = 0; h < 4; h++) o[t[h]] = l[h] = l[h] || l[(h - 1) / 2 >> 0];
                                        return r.parse(e, o, s, a)
                                    }
                            },
                            _t = (W._setPluginRatio = function(t) {
                                this.plugin.setRatio(t);
                                for (var e, i, n, r, s, a = this.data, o = a.proxy, h = a.firstMPT; h;) e = o[h.v], h.r ? e = Math.round(e) : e < 1e-6 && e > -1e-6 && (e = 0), h.t[h.p] = e, h = h._next;
                                if (a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod(o.rotation, this.t) : o.rotation), 1 === t || 0 === t)
                                    for (h = a.firstMPT, s = 1 === t ? "e" : "b"; h;) {
                                        if (i = h.t, i.type) {
                                            if (1 === i.type) {
                                                for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                                i[s] = r
                                            }
                                        } else i[s] = i.s + i.xs0;
                                        h = h._next
                                    }
                            }, function(t, e, i, n, r) {
                                this.t = t, this.p = e, this.v = i, this.r = r, n && (n._prev = this, this._next = n)
                            }),
                            xt = (W._parseToProxy = function(t, e, i, n, r, s) {
                                var a, o, h, l, c, u = n,
                                    d = {},
                                    p = {},
                                    f = i._transform,
                                    m = F;
                                for (i._transform = null, F = e, n = c = i.parse(t, e, n, r), F = m, s && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) {
                                    if (n.type <= 1 && (o = n.p, p[o] = n.s + n.c, d[o] = n.s, s || (l = new _t(n, "s", o, l, n.r), n.c = 0), 1 === n.type))
                                        for (a = n.l; --a > 0;) h = "xn" + a, o = n.p + "_" + h, p[o] = n.data[h], d[o] = n[h], s || (l = new _t(n, h, o, l, n.rxp[h]));
                                    n = n._next
                                }
                                return {
                                    proxy: d,
                                    end: p,
                                    firstMPT: l,
                                    pt: c
                                }
                            }, W.CSSPropTween = function(t, e, n, r, s, o, h, l, c, u, d) {
                                this.t = t, this.p = e, this.s = n, this.c = r, this.n = h || e, t instanceof xt || a.push(this.n), this.r = l, this.type = o || 0, c && (this.pr = c, i = !0), this.b = void 0 === u ? n : u, this.e = void 0 === d ? n + r : d, s && (this._next = s, s._prev = this)
                            }),
                            bt = function(t, e, i, n, r, s) {
                                var a = new xt(t, e, i, n - i, r, -1, s);
                                return a.b = i, a.e = a.xs0 = n, a
                            },
                            wt = o.parseComplex = function(t, e, i, n, r, s, a, h, l, c) {
                                i = i || s || "", "function" == typeof n && (n = n(y, g)), a = new xt(t, e, 0, 0, a, c ? 2 : 1, null, !1, h, i, n), n += "", r && vt.test(n + i) && (n = [i, n], o.colorStringFilter(n), i = n[0], n = n[1]);
                                var d, p, f, m, v, b, w, T, M, E, S, A, P, R = i.split(", ").join(",").split(" "),
                                    C = n.split(", ").join(",").split(" "),
                                    L = R.length,
                                    O = !1 !== u;
                                for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (-1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (R = R.join(" ").replace(z, ", ").split(" "), C = C.join(" ").replace(z, ", ").split(" ")) : (R = R.join(" ").split(",").join(", ").split(" "), C = C.join(" ").split(",").join(", ").split(" ")), L = R.length), L !== C.length && (R = (s || "").split(" "), L = R.length), a.plugin = l, a.setRatio = c, vt.lastIndex = 0, d = 0; d < L; d++)
                                    if (m = R[d], v = C[d], (T = parseFloat(m)) || 0 === T) a.appendXtra("", T, lt(v, T), v.replace(x, ""), O && -1 !== v.indexOf("px"), !0);
                                    else if (r && vt.test(m)) A = v.indexOf(")") + 1, A = ")" + (A ? v.substr(A) : ""), P = -1 !== v.indexOf("hsl") && q, E = v, m = ft(m, P), v = ft(v, P), M = m.length + v.length > 6, M && !q && 0 === v[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(C[d]).join("transparent")) : (q || (M = !1), P ? a.appendXtra(E.substr(0, E.indexOf("hsl")) + (M ? "hsla(" : "hsl("), m[0], lt(v[0], m[0]), ",", !1, !0).appendXtra("", m[1], lt(v[1], m[1]), "%,", !1).appendXtra("", m[2], lt(v[2], m[2]), M ? "%," : "%" + A, !1) : a.appendXtra(E.substr(0, E.indexOf("rgb")) + (M ? "rgba(" : "rgb("), m[0], v[0] - m[0], ",", !0, !0).appendXtra("", m[1], v[1] - m[1], ",", !0).appendXtra("", m[2], v[2] - m[2], M ? "," : A, !0), M && (m = m.length < 4 ? 1 : m[3], a.appendXtra("", m, (v.length < 4 ? 1 : v[3]) - m, A, !1))), vt.lastIndex = 0;
                                else if (b = m.match(_)) {
                                    if (!(w = v.match(x)) || w.length !== b.length) return a;
                                    for (f = 0, p = 0; p < b.length; p++) S = b[p], E = m.indexOf(S, f), a.appendXtra(m.substr(f, E - f), Number(S), lt(w[p], S), "", O && "px" === m.substr(E + S.length, 2), 0 === p), f = E + S.length;
                                    a["xs" + a.l] += m.substr(f)
                                } else a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + v : v;
                                if (-1 !== n.indexOf("=") && a.data) {
                                    for (A = a.xs0 + a.data.s, d = 1; d < a.l; d++) A += a["xs" + d] + a.data["xn" + d];
                                    a.e = A + a["xs" + d]
                                }
                                return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                            },
                            Tt = 9;
                        for (c = xt.prototype, c.l = c.pr = 0; --Tt > 0;) c["xn" + Tt] = 0, c["xs" + Tt] = "";
                        c.xs0 = "", c._next = c._prev = c.xfirst = c.data = c.plugin = c.setRatio = c.rxp = null, c.appendXtra = function(t, e, i, n, r, s) {
                            var a = this,
                                o = a.l;
                            return a["xs" + o] += s && (o || a["xs" + o]) ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = n || "", o > 0 ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = r, a["xn" + o] = e, a.plugin || (a.xfirst = new xt(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                                s: e + i
                            }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + o] += e + (n || ""), a)
                        };
                        var Mt = function(t, e) {
                                e = e || {}, this.p = e.prefix ? J(t) || t : t, l[t] = l[this.p] = this, this.format = e.formatter || gt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
                            },
                            Et = W._registerComplexSpecialProp = function(t, e, i) {
                                "object" != typeof e && (e = {
                                    parser: i
                                });
                                var n, r = t.split(","),
                                    s = e.defaultValue;
                                for (i = i || [s], n = 0; n < r.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || s, new Mt(r[n], e)
                            },
                            St = W._registerPluginProp = function(t) {
                                if (!l[t]) {
                                    var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                                    Et(t, {
                                        parser: function(t, i, n, r, s, a, o) {
                                            var c = h.com.greensock.plugins[e];
                                            return c ? (c._cssRegister(), l[n].parse(t, i, n, r, s, a, o)) : (Z("Error: " + e + " js file not loaded."), s)
                                        }
                                    })
                                }
                            };
                        c = Mt.prototype, c.parseComplex = function(t, e, i, n, r, s) {
                            var a, o, h, l, c, u, d = this.keyword;
                            if (this.multi && (z.test(i) || z.test(e) ? (o = e.replace(z, "|").split("|"), h = i.replace(z, "|").split("|")) : d && (o = [e], h = [i])), h) {
                                for (l = h.length > o.length ? h.length : o.length, a = 0; a < l; a++) e = o[a] = o[a] || this.dflt, i = h[a] = h[a] || this.dflt, d && (c = e.indexOf(d), u = i.indexOf(d), c !== u && (-1 === u ? o[a] = o[a].split(d).join("") : -1 === c && (o[a] += " " + d)));
                                e = o.join(", "), i = h.join(", ")
                            }
                            return wt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, s)
                        }, c.parse = function(t, e, i, n, s, a, o) {
                            return this.parseComplex(t.style, this.format(tt(t, this.p, r, !1, this.dflt)), this.format(e), s, a)
                        }, o.registerSpecialProp = function(t, e, i) {
                            Et(t, {
                                parser: function(t, n, r, s, a, o, h) {
                                    var l = new xt(t, r, 0, 0, a, 2, r, !1, i);
                                    return l.plugin = o, l.setRatio = e(t, n, s._tween, r), l
                                },
                                priority: i
                            })
                        }, o.useSVGTransformAttr = !0;
                        var At, Pt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                            Rt = J("transform"),
                            Ct = $ + "transform",
                            Lt = J("transformOrigin"),
                            Ot = null !== J("perspective"),
                            It = W.Transform = function() {
                                this.perspective = parseFloat(o.defaultTransformPerspective) || 0, this.force3D = !(!1 === o.defaultForce3D || !Ot) && (o.defaultForce3D || "auto")
                            },
                            Dt = s.SVGElement,
                            zt = function(t, e, i) {
                                var n, r = G.createElementNS("http://www.w3.org/2000/svg", t),
                                    s = /([a-z])([A-Z])/g;
                                for (n in i) r.setAttributeNS(null, n.replace(s, "$1-$2").toLowerCase(), i[n]);
                                return e.appendChild(r), r
                            },
                            Ut = G.documentElement || {},
                            Nt = function() {
                                var t, e, i, n = v || /Android/i.test(X) && !s.chrome;
                                return G.createElementNS && !n && (t = zt("svg", Ut), e = zt("rect", t, {
                                    width: 100,
                                    height: 50,
                                    x: 100
                                }), i = e.getBoundingClientRect().width, e.style[Lt] = "50% 50%", e.style[Rt] = "scaleX(0.5)", n = i === e.getBoundingClientRect().width && !(f && Ot), Ut.removeChild(t)), n
                            }(),
                            kt = function(t, e, i, n, r, s) {
                                var a, h, l, c, u, d, p, f, m, v, g, y, _, x, b = t._gsTransform,
                                    w = jt(t, !0);
                                b && (_ = b.xOrigin, x = b.yOrigin), (!n || (a = n.split(" ")).length < 2) && (p = t.getBBox(), 0 === p.x && 0 === p.y && p.width + p.height === 0 && (p = {
                                    x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                                    y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                                    width: 0,
                                    height: 0
                                }), e = ht(e).split(" "), a = [(-1 !== e[0].indexOf("%") ? parseFloat(e[0]) / 100 * p.width : parseFloat(e[0])) + p.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * p.height : parseFloat(e[1])) + p.y]), i.xOrigin = c = parseFloat(a[0]), i.yOrigin = u = parseFloat(a[1]), n && w !== Ht && (d = w[0], p = w[1], f = w[2], m = w[3], v = w[4], g = w[5], (y = d * m - p * f) && (h = c * (m / y) + u * (-f / y) + (f * g - m * v) / y, l = c * (-p / y) + u * (d / y) - (d * g - p * v) / y, c = i.xOrigin = a[0] = h, u = i.yOrigin = a[1] = l)), b && (s && (i.xOffset = b.xOffset, i.yOffset = b.yOffset, b = i), r || !1 !== r && !1 !== o.defaultSmoothOrigin ? (h = c - _, l = u - x, b.xOffset += h * w[0] + l * w[2] - h, b.yOffset += h * w[1] + l * w[3] - l) : b.xOffset = b.yOffset = 0), s || t.setAttribute("data-svg-origin", a.join(" "))
                            },
                            Ft = function(t) {
                                var e, i = H("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                    n = this.parentNode,
                                    r = this.nextSibling,
                                    s = this.style.cssText;
                                if (Ut.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                                    e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ft
                                } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox());
                                return r ? n.insertBefore(this, r) : n.appendChild(this), Ut.removeChild(i), this.style.cssText = s, e
                            },
                            Bt = function(t) {
                                try {
                                    return t.getBBox()
                                } catch (e) {
                                    return Ft.call(t, !0)
                                }
                            },
                            Gt = function(t) {
                                return !(!Dt || !t.getCTM || t.parentNode && !t.ownerSVGElement || !Bt(t))
                            },
                            Ht = [1, 0, 0, 1, 0, 0],
                            jt = function(t, e) {
                                var i, n, r, s, a, o, h = t._gsTransform || new It,
                                    l = t.style;
                                if (Rt ? n = tt(t, Ct, null, !0) : t.currentStyle && (n = t.currentStyle.filter.match(I), n = n && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), h.x || 0, h.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, !Rt || !(o = !K(t) || "none" === K(t).display) && t.parentNode || (o && (s = l.display, l.display = "block"), t.parentNode || (a = 1, Ut.appendChild(t)), n = tt(t, Ct, null, !0), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, s ? l.display = s : o && Yt(l, "display"), a && Ut.removeChild(t)), (h.svg || t.getCTM && Gt(t)) && (i && -1 !== (l[Rt] + "").indexOf("matrix") && (n = l[Rt], i = 0), r = t.getAttribute("transform"), i && r && (-1 !== r.indexOf("matrix") ? (n = r, i = 0) : -1 !== r.indexOf("translate") && (n = "matrix(1,0,0,1," + r.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", i = 0))), i) return Ht;
                                for (r = (n || "").match(_) || [], Tt = r.length; --Tt > -1;) s = Number(r[Tt]), r[Tt] = (a = s - (s |= 0)) ? (1e5 * a + (a < 0 ? -.5 : .5) | 0) / 1e5 + s : s;
                                return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                            },
                            Vt = W.getTransform = function(t, i, n, r) {
                                if (t._gsTransform && n && !r) return t._gsTransform;
                                var s, a, h, l, c, u, d = n ? t._gsTransform || new It : new It,
                                    p = d.scaleX < 0,
                                    f = Ot ? parseFloat(tt(t, Lt, i, !1, "0 0 0").split(" ")[2]) || d.zOrigin || 0 : 0,
                                    m = parseFloat(o.defaultTransformPerspective) || 0;
                                if (d.svg = !(!t.getCTM || !Gt(t)), d.svg && (kt(t, tt(t, Lt, i, !1, "50% 50%") + "", d, t.getAttribute("data-svg-origin")), At = o.useSVGTransformAttr || Nt), (s = jt(t)) !== Ht) {
                                    if (16 === s.length) {
                                        var v, g, y, _, x, b = s[0],
                                            w = s[1],
                                            T = s[2],
                                            M = s[3],
                                            E = s[4],
                                            S = s[5],
                                            A = s[6],
                                            P = s[7],
                                            R = s[8],
                                            C = s[9],
                                            L = s[10],
                                            O = s[12],
                                            I = s[13],
                                            D = s[14],
                                            z = s[11],
                                            U = Math.atan2(A, L);
                                        d.zOrigin && (D = -d.zOrigin, O = R * D - s[12], I = C * D - s[13], D = L * D + d.zOrigin - s[14]), d.rotationX = U * k, U && (_ = Math.cos(-U), x = Math.sin(-U), v = E * _ + R * x, g = S * _ + C * x, y = A * _ + L * x, R = E * -x + R * _, C = S * -x + C * _, L = A * -x + L * _, z = P * -x + z * _, E = v, S = g, A = y), U = Math.atan2(-T, L), d.rotationY = U * k, U && (_ = Math.cos(-U), x = Math.sin(-U), v = b * _ - R * x, g = w * _ - C * x, y = T * _ - L * x, C = w * x + C * _, L = T * x + L * _, z = M * x + z * _, b = v, w = g, T = y), U = Math.atan2(w, b), d.rotation = U * k, U && (_ = Math.cos(U), x = Math.sin(U), v = b * _ + w * x, g = E * _ + S * x, y = R * _ + C * x, w = w * _ - b * x, S = S * _ - E * x, C = C * _ - R * x, b = v, E = g, R = y), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), U = Math.atan2(E, S), d.scaleX = (1e5 * Math.sqrt(b * b + w * w + T * T) + .5 | 0) / 1e5, d.scaleY = (1e5 * Math.sqrt(S * S + A * A) + .5 | 0) / 1e5, d.scaleZ = (1e5 * Math.sqrt(R * R + C * C + L * L) + .5 | 0) / 1e5, b /= d.scaleX, E /= d.scaleY, w /= d.scaleX, S /= d.scaleY, Math.abs(U) > 2e-5 ? (d.skewX = U * k, E = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(U))) : d.skewX = 0, d.perspective = z ? 1 / (z < 0 ? -z : z) : 0, d.x = O, d.y = I, d.z = D, d.svg && (d.x -= d.xOrigin - (d.xOrigin * b - d.yOrigin * E), d.y -= d.yOrigin - (d.yOrigin * w - d.xOrigin * S))
                                    } else if (!Ot || r || !s.length || d.x !== s[4] || d.y !== s[5] || !d.rotationX && !d.rotationY) {
                                        var N = s.length >= 6,
                                            F = N ? s[0] : 1,
                                            B = s[1] || 0,
                                            G = s[2] || 0,
                                            H = N ? s[3] : 1;
                                        d.x = s[4] || 0, d.y = s[5] || 0, h = Math.sqrt(F * F + B * B), l = Math.sqrt(H * H + G * G), c = F || B ? Math.atan2(B, F) * k : d.rotation || 0, u = G || H ? Math.atan2(G, H) * k + c : d.skewX || 0, d.scaleX = h, d.scaleY = l, d.rotation = c, d.skewX = u, Ot && (d.rotationX = d.rotationY = d.z = 0, d.perspective = m, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * F + d.yOrigin * G), d.y -= d.yOrigin - (d.xOrigin * B + d.yOrigin * H))
                                    }
                                    Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (p ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = f;
                                    for (a in d) d[a] < 2e-5 && d[a] > -2e-5 && (d[a] = 0)
                                }
                                return n && (t._gsTransform = d, d.svg && (At && t.style[Rt] ? e.delayedCall(.001, function() {
                                    Yt(t.style, Rt)
                                }) : !At && t.getAttribute("transform") && e.delayedCall(.001, function() {
                                    t.removeAttribute("transform")
                                }))), d
                            },
                            Wt = function(t) {
                                var e, i, n = this.data,
                                    r = -n.rotation * N,
                                    s = r + n.skewX * N,
                                    a = (Math.cos(r) * n.scaleX * 1e5 | 0) / 1e5,
                                    o = (Math.sin(r) * n.scaleX * 1e5 | 0) / 1e5,
                                    h = (Math.sin(s) * -n.scaleY * 1e5 | 0) / 1e5,
                                    l = (Math.cos(s) * n.scaleY * 1e5 | 0) / 1e5,
                                    c = this.t.style,
                                    u = this.t.currentStyle;
                                if (u) {
                                    i = o, o = -h, h = -i, e = u.filter, c.filter = "";
                                    var d, p, f = this.t.offsetWidth,
                                        m = this.t.offsetHeight,
                                        g = "absolute" !== u.position,
                                        y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + o + ", M21=" + h + ", M22=" + l,
                                        _ = n.x + f * n.xPercent / 100,
                                        x = n.y + m * n.yPercent / 100;
                                    if (null != n.ox && (d = (n.oxp ? f * n.ox * .01 : n.ox) - f / 2, p = (n.oyp ? m * n.oy * .01 : n.oy) - m / 2, _ += d - (d * a + p * o), x += p - (d * h + p * l)), g ? (d = f / 2, p = m / 2, y += ", Dx=" + (d - (d * a + p * o) + _) + ", Dy=" + (p - (d * h + p * l) + x) + ")") : y += ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? c.filter = e.replace(D, y) : c.filter = y + " " + e, 0 !== t && 1 !== t || 1 === a && 0 === o && 0 === h && 1 === l && (g && -1 === y.indexOf("Dx=0, Dy=0") || M.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && c.removeAttribute("filter")), !g) {
                                        var b, w, E, S = v < 8 ? 1 : -1;
                                        for (d = n.ieOffsetX || 0, p = n.ieOffsetY || 0, n.ieOffsetX = Math.round((f - ((a < 0 ? -a : a) * f + (o < 0 ? -o : o) * m)) / 2 + _), n.ieOffsetY = Math.round((m - ((l < 0 ? -l : l) * m + (h < 0 ? -h : h) * f)) / 2 + x), Tt = 0; Tt < 4; Tt++) w = at[Tt], b = u[w], i = -1 !== b.indexOf("px") ? parseFloat(b) : et(this.t, w, parseFloat(b), b.replace(T, "")) || 0, E = i !== n[w] ? Tt < 2 ? -n.ieOffsetX : -n.ieOffsetY : Tt < 2 ? d - n.ieOffsetX : p - n.ieOffsetY, c[w] = (n[w] = Math.round(i - E * (0 === Tt || 2 === Tt ? 1 : S))) + "px"
                                    }
                                }
                            },
                            Xt = W.set3DTransformRatio = W.setTransformRatio = function(t) {
                                var e, i, n, r, s, a, o, h, l, c, u, d, p, m, v, g, y, _, x, b, w, T, M, E = this.data,
                                    S = this.t.style,
                                    A = E.rotation,
                                    P = E.rotationX,
                                    R = E.rotationY,
                                    C = E.scaleX,
                                    L = E.scaleY,
                                    O = E.scaleZ,
                                    I = E.x,
                                    D = E.y,
                                    z = E.z,
                                    U = E.svg,
                                    k = E.perspective,
                                    F = E.force3D,
                                    B = E.skewY,
                                    G = E.skewX;
                                if (B && (G += B, A += B), ((1 === t || 0 === t) && "auto" === F && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !F) && !z && !k && !R && !P && 1 === O || At && U || !Ot) return void(A || G || U ? (A *= N, T = G * N, M = 1e5, i = Math.cos(A) * C, s = Math.sin(A) * C, n = Math.sin(A - T) * -L, a = Math.cos(A - T) * L, T && "simple" === E.skewType && (e = Math.tan(T - B * N), e = Math.sqrt(1 + e * e), n *= e, a *= e, B && (e = Math.tan(B * N), e = Math.sqrt(1 + e * e), i *= e, s *= e)), U && (I += E.xOrigin - (E.xOrigin * i + E.yOrigin * n) + E.xOffset, D += E.yOrigin - (E.xOrigin * s + E.yOrigin * a) + E.yOffset, At && (E.xPercent || E.yPercent) && (v = this.t.getBBox(), I += .01 * E.xPercent * v.width, D += .01 * E.yPercent * v.height), v = 1e-6, I < v && I > -v && (I = 0), D < v && D > -v && (D = 0)), x = (i * M | 0) / M + "," + (s * M | 0) / M + "," + (n * M | 0) / M + "," + (a * M | 0) / M + "," + I + "," + D + ")", U && At ? this.t.setAttribute("transform", "matrix(" + x) : S[Rt] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix(" : "matrix(") + x) : S[Rt] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix(" : "matrix(") + C + ",0,0," + L + "," + I + "," + D + ")");
                                if (f && (v = 1e-4, C < v && C > -v && (C = O = 2e-5), L < v && L > -v && (L = O = 2e-5), !k || E.z || E.rotationX || E.rotationY || (k = 0)), A || G) A *= N, g = i = Math.cos(A), y = s = Math.sin(A), G && (A -= G * N, g = Math.cos(A), y = Math.sin(A), "simple" === E.skewType && (e = Math.tan((G - B) * N), e = Math.sqrt(1 + e * e), g *= e, y *= e, E.skewY && (e = Math.tan(B * N), e = Math.sqrt(1 + e * e), i *= e, s *= e))), n = -y, a = g;
                                else {
                                    if (!(R || P || 1 !== O || k || U)) return void(S[Rt] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) translate3d(" : "translate3d(") + I + "px," + D + "px," + z + "px)" + (1 !== C || 1 !== L ? " scale(" + C + "," + L + ")" : ""));
                                    i = a = 1, n = s = 0
                                }
                                c = 1, r = o = h = l = u = d = 0, p = k ? -1 / k : 0, m = E.zOrigin, v = 1e-6, b = ",", w = "0", A = R * N, A && (g = Math.cos(A), y = Math.sin(A), h = -y, u = p * -y, r = i * y, o = s * y, c = g, p *= g, i *= g, s *= g), A = P * N, A && (g = Math.cos(A), y = Math.sin(A), e = n * g + r * y, _ = a * g + o * y, l = c * y, d = p * y, r = n * -y + r * g, o = a * -y + o * g, c *= g, p *= g, n = e, a = _), 1 !== O && (r *= O, o *= O, c *= O, p *= O), 1 !== L && (n *= L, a *= L, l *= L, d *= L), 1 !== C && (i *= C, s *= C, h *= C, u *= C), (m || U) && (m && (I += r * -m, D += o * -m, z += c * -m + m), U && (I += E.xOrigin - (E.xOrigin * i + E.yOrigin * n) + E.xOffset, D += E.yOrigin - (E.xOrigin * s + E.yOrigin * a) + E.yOffset), I < v && I > -v && (I = w), D < v && D > -v && (D = w), z < v && z > -v && (z = 0)), x = E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix3d(" : "matrix3d(", x += (i < v && i > -v ? w : i) + b + (s < v && s > -v ? w : s) + b + (h < v && h > -v ? w : h), x += b + (u < v && u > -v ? w : u) + b + (n < v && n > -v ? w : n) + b + (a < v && a > -v ? w : a), P || R || 1 !== O ? (x += b + (l < v && l > -v ? w : l) + b + (d < v && d > -v ? w : d) + b + (r < v && r > -v ? w : r), x += b + (o < v && o > -v ? w : o) + b + (c < v && c > -v ? w : c) + b + (p < v && p > -v ? w : p) + b) : x += ",0,0,0,0,1,0,", x += I + b + D + b + z + b + (k ? 1 + -z / k : 1) + ")", S[Rt] = x
                            };
                        c = It.prototype, c.x = c.y = c.z = c.skewX = c.skewY = c.rotation = c.rotationX = c.rotationY = c.zOrigin = c.xPercent = c.yPercent = c.xOffset = c.yOffset = 0, c.scaleX = c.scaleY = c.scaleZ = 1, Et("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                            parser: function(t, e, i, n, s, a, h) {
                                if (n._lastParsedTransform === h) return s;
                                n._lastParsedTransform = h;
                                var l, c = h.scale && "function" == typeof h.scale ? h.scale : 0;
                                "function" == typeof h[i] && (l = h[i], h[i] = e), c && (h.scale = c(y, t));
                                var u, d, p, f, m, v, _, x, b, w = t._gsTransform,
                                    T = t.style,
                                    M = Pt.length,
                                    E = h,
                                    S = {},
                                    A = Vt(t, r, !0, E.parseTransform),
                                    P = E.transform && ("function" == typeof E.transform ? E.transform(y, g) : E.transform);
                                if (A.skewType = E.skewType || A.skewType || o.defaultSkewType, n._transform = A, P && "string" == typeof P && Rt) d = j.style, d[Rt] = P, d.display = "block", d.position = "absolute", G.body.appendChild(j), u = Vt(j, null, !1), "simple" === A.skewType && (u.scaleY *= Math.cos(u.skewX * N)), A.svg && (v = A.xOrigin, _ = A.yOrigin, u.x -= A.xOffset, u.y -= A.yOffset, (E.transformOrigin || E.svgOrigin) && (P = {}, kt(t, ht(E.transformOrigin), P, E.svgOrigin, E.smoothOrigin, !0), v = P.xOrigin, _ = P.yOrigin, u.x -= P.xOffset - A.xOffset, u.y -= P.yOffset - A.yOffset), (v || _) && (x = jt(j, !0), u.x -= v - (v * x[0] + _ * x[2]), u.y -= _ - (v * x[1] + _ * x[3]))), G.body.removeChild(j), u.perspective || (u.perspective = A.perspective), null != E.xPercent && (u.xPercent = ct(E.xPercent, A.xPercent)), null != E.yPercent && (u.yPercent = ct(E.yPercent, A.yPercent));
                                else if ("object" == typeof E) {
                                    if (u = {
                                            scaleX: ct(null != E.scaleX ? E.scaleX : E.scale, A.scaleX),
                                            scaleY: ct(null != E.scaleY ? E.scaleY : E.scale, A.scaleY),
                                            scaleZ: ct(E.scaleZ, A.scaleZ),
                                            x: ct(E.x, A.x),
                                            y: ct(E.y, A.y),
                                            z: ct(E.z, A.z),
                                            xPercent: ct(E.xPercent, A.xPercent),
                                            yPercent: ct(E.yPercent, A.yPercent),
                                            perspective: ct(E.transformPerspective, A.perspective)
                                        }, null != (m = E.directionalRotation))
                                        if ("object" == typeof m)
                                            for (d in m) E[d] = m[d];
                                        else E.rotation = m;
                                    "string" == typeof E.x && -1 !== E.x.indexOf("%") && (u.x = 0, u.xPercent = ct(E.x, A.xPercent)), "string" == typeof E.y && -1 !== E.y.indexOf("%") && (u.y = 0, u.yPercent = ct(E.y, A.yPercent)), u.rotation = ut("rotation" in E ? E.rotation : "shortRotation" in E ? E.shortRotation + "_short" : "rotationZ" in E ? E.rotationZ : A.rotation, A.rotation, "rotation", S), Ot && (u.rotationX = ut("rotationX" in E ? E.rotationX : "shortRotationX" in E ? E.shortRotationX + "_short" : A.rotationX || 0, A.rotationX, "rotationX", S), u.rotationY = ut("rotationY" in E ? E.rotationY : "shortRotationY" in E ? E.shortRotationY + "_short" : A.rotationY || 0, A.rotationY, "rotationY", S)), u.skewX = ut(E.skewX, A.skewX), u.skewY = ut(E.skewY, A.skewY)
                                }
                                for (Ot && null != E.force3D && (A.force3D = E.force3D, f = !0), p = A.force3D || A.z || A.rotationX || A.rotationY || u.z || u.rotationX || u.rotationY || u.perspective, p || null == E.scale || (u.scaleZ = 1); --M > -1;) b = Pt[M], ((P = u[b] - A[b]) > 1e-6 || P < -1e-6 || null != E[b] || null != F[b]) && (f = !0, s = new xt(A, b, A[b], P, s), b in S && (s.e = S[b]), s.xs0 = 0, s.plugin = a, n._overwriteProps.push(s.n));
                                return P = E.transformOrigin, A.svg && (P || E.svgOrigin) && (v = A.xOffset, _ = A.yOffset, kt(t, ht(P), u, E.svgOrigin, E.smoothOrigin), s = bt(A, "xOrigin", (w ? A : u).xOrigin, u.xOrigin, s, "transformOrigin"), s = bt(A, "yOrigin", (w ? A : u).yOrigin, u.yOrigin, s, "transformOrigin"), v === A.xOffset && _ === A.yOffset || (s = bt(A, "xOffset", w ? v : A.xOffset, A.xOffset, s, "transformOrigin"), s = bt(A, "yOffset", w ? _ : A.yOffset, A.yOffset, s, "transformOrigin")), P = "0px 0px"), (P || Ot && p && A.zOrigin) && (Rt ? (f = !0, b = Lt, P = (P || tt(t, b, r, !1, "50% 50%")) + "", s = new xt(T, b, 0, 0, s, -1, "transformOrigin"), s.b = T[b], s.plugin = a, Ot ? (d = A.zOrigin, P = P.split(" "), A.zOrigin = (P.length > 2 && (0 === d || "0px" !== P[2]) ? parseFloat(P[2]) : d) || 0, s.xs0 = s.e = P[0] + " " + (P[1] || "50%") + " 0px", s = new xt(A, "zOrigin", 0, 0, s, -1, s.n), s.b = d, s.xs0 = s.e = A.zOrigin) : s.xs0 = s.e = P) : ht(P + "", A)), f && (n._transformType = A.svg && At || !p && 3 !== this._transformType ? 2 : 3), l && (h[i] = l), c && (h.scale = c), s
                            },
                            prefix: !0
                        }), Et("boxShadow", {
                            defaultValue: "0px 0px 0px 0px #999",
                            prefix: !0,
                            color: !0,
                            multi: !0,
                            keyword: "inset"
                        }), Et("borderRadius", {
                            defaultValue: "0px",
                            parser: function(t, e, i, s, a, o) {
                                e = this.format(e);
                                var h, l, c, u, d, p, f, m, v, g, y, _, x, b, w, T, M = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                    E = t.style;
                                for (v = parseFloat(t.offsetWidth), g = parseFloat(t.offsetHeight), h = e.split(" "), l = 0; l < M.length; l++) this.p.indexOf("border") && (M[l] = J(M[l])), d = u = tt(t, M[l], r, !1, "0px"), -1 !== d.indexOf(" ") && (u = d.split(" "), d = u[0], u = u[1]), p = c = h[l], f = parseFloat(d), _ = d.substr((f + "").length), x = "=" === p.charAt(1), x ? (m = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), m *= parseFloat(p), y = p.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(p), y = p.substr((m + "").length)), "" === y && (y = n[i] || _), y !== _ && (b = et(t, "borderLeft", f, _), w = et(t, "borderTop", f, _), "%" === y ? (d = b / v * 100 + "%", u = w / g * 100 + "%") : "em" === y ? (T = et(t, "borderLeft", 1, "em"), d = b / T + "em", u = w / T + "em") : (d = b + "px", u = w + "px"), x && (p = parseFloat(d) + m + y, c = parseFloat(u) + m + y)), a = wt(E, M[l], d + " " + u, p + " " + c, !1, "0px", a);
                                return a
                            },
                            prefix: !0,
                            formatter: gt("0px 0px 0px 0px", !1, !0)
                        }), Et("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                            defaultValue: "0px",
                            parser: function(t, e, i, n, s, a) {
                                return wt(t.style, i, this.format(tt(t, i, r, !1, "0px 0px")), this.format(e), !1, "0px", s)
                            },
                            prefix: !0,
                            formatter: gt("0px 0px", !1, !0)
                        }), Et("backgroundPosition", {
                            defaultValue: "0 0",
                            parser: function(t, e, i, n, s, a) {
                                var o, h, l, c, u, d, p = "background-position",
                                    f = r || K(t, null),
                                    m = this.format((f ? v ? f.getPropertyValue(p + "-x") + " " + f.getPropertyValue(p + "-y") : f.getPropertyValue(p) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                                    g = this.format(e);
                                if (-1 !== m.indexOf("%") != (-1 !== g.indexOf("%")) && g.split(",").length < 2 && (d = tt(t, "backgroundImage").replace(C, "")) && "none" !== d) {
                                    for (o = m.split(" "), h = g.split(" "), V.setAttribute("src", d), l = 2; --l > -1;) m = o[l], (c = -1 !== m.indexOf("%")) !== (-1 !== h[l].indexOf("%")) && (u = 0 === l ? t.offsetWidth - V.width : t.offsetHeight - V.height, o[l] = c ? parseFloat(m) / 100 * u + "px" : parseFloat(m) / u * 100 + "%");
                                    m = o.join(" ")
                                }
                                return this.parseComplex(t.style, m, g, s, a)
                            },
                            formatter: ht
                        }), Et("backgroundSize", {
                            defaultValue: "0 0",
                            formatter: function(t) {
                                return t += "", ht(-1 === t.indexOf(" ") ? t + " " + t : t)
                            }
                        }), Et("perspective", {
                            defaultValue: "0px",
                            prefix: !0
                        }), Et("perspectiveOrigin", {
                            defaultValue: "50% 50%",
                            prefix: !0
                        }), Et("transformStyle", {
                            prefix: !0
                        }), Et("backfaceVisibility", {
                            prefix: !0
                        }), Et("userSelect", {
                            prefix: !0
                        }), Et("margin", {
                            parser: yt("marginTop,marginRight,marginBottom,marginLeft")
                        }), Et("padding", {
                            parser: yt("paddingTop,paddingRight,paddingBottom,paddingLeft")
                        }), Et("clip", {
                            defaultValue: "rect(0px,0px,0px,0px)",
                            parser: function(t, e, i, n, s, a) {
                                var o, h, l;
                                return v < 9 ? (h = t.currentStyle, l = v < 8 ? " " : ",", o = "rect(" + h.clipTop + l + h.clipRight + l + h.clipBottom + l + h.clipLeft + ")", e = this.format(e).split(",").join(l)) : (o = this.format(tt(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, o, e, s, a)
                            }
                        }), Et("textShadow", {
                            defaultValue: "0px 0px 0px #999",
                            color: !0,
                            multi: !0
                        }), Et("autoRound,strictUnits", {
                            parser: function(t, e, i, n, r) {
                                return r
                            }
                        }), Et("border", {
                            defaultValue: "0px solid #000",
                            parser: function(t, e, i, n, s, a) {
                                var o = tt(t, "borderTopWidth", r, !1, "0px"),
                                    h = this.format(e).split(" "),
                                    l = h[0].replace(T, "");
                                return "px" !== l && (o = parseFloat(o) / et(t, "borderTopWidth", 1, l) + l), this.parseComplex(t.style, this.format(o + " " + tt(t, "borderTopStyle", r, !1, "solid") + " " + tt(t, "borderTopColor", r, !1, "#000")), h.join(" "), s, a)
                            },
                            color: !0,
                            formatter: function(t) {
                                var e = t.split(" ");
                                return e[0] + " " + (e[1] || "solid") + " " + (t.match(vt) || ["#000"])[0]
                            }
                        }), Et("borderWidth", {
                            parser: yt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                        }), Et("float,cssFloat,styleFloat", {
                            parser: function(t, e, i, n, r, s) {
                                var a = t.style,
                                    o = "cssFloat" in a ? "cssFloat" : "styleFloat";
                                return new xt(a, o, 0, 0, r, -1, i, !1, 0, a[o], e)
                            }
                        });
                        var qt = function(t) {
                            var e, i = this.t,
                                n = i.filter || tt(this.data, "filter") || "",
                                r = this.s + this.c * t | 0;
                            100 === r && (-1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), e = !tt(this.data, "filter")) : (i.filter = n.replace(S, ""), e = !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(M, "opacity=" + r))
                        };
                        Et("opacity,alpha,autoAlpha", {
                            defaultValue: "1",
                            parser: function(t, e, i, n, s, a) {
                                var o = parseFloat(tt(t, "opacity", r, !1, "1")),
                                    h = t.style,
                                    l = "autoAlpha" === i;
                                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + o), l && 1 === o && "hidden" === tt(t, "visibility", r) && 0 !== e && (o = 0), q ? s = new xt(h, "opacity", o, e - o, s) : (s = new xt(h, "opacity", 100 * o, 100 * (e - o), s), s.xn1 = l ? 1 : 0, h.zoom = 1, s.type = 2, s.b = "alpha(opacity=" + s.s + ")", s.e = "alpha(opacity=" + (s.s + s.c) + ")", s.data = t, s.plugin = a, s.setRatio = qt), l && (s = new xt(h, "visibility", 0, 0, s, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), s.xs0 = "inherit", n._overwriteProps.push(s.n), n._overwriteProps.push(i)), s
                            }
                        });
                        var Yt = function(t, e) {
                                e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(P, "-$1").toLowerCase())) : t.removeAttribute(e))
                            },
                            Zt = function(t) {
                                if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                                    this.t.setAttribute("class", 0 === t ? this.b : this.e);
                                    for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Yt(i, e.p), e = e._next;
                                    1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                            };
                        Et("className", {
                            parser: function(t, e, n, s, a, o, h) {
                                var l, c, u, d, p, f = t.getAttribute("class") || "",
                                    m = t.style.cssText;
                                if (a = s._classNamePT = new xt(t, n, 0, 0, a, 2), a.setRatio = Zt, a.pr = -11, i = !0, a.b = f, c = nt(t, r), u = t._gsClassPT) {
                                    for (d = {}, p = u.data; p;) d[p.p] = 1, p = p._next;
                                    u.setRatio(1)
                                }
                                return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : f.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", a.e), l = rt(t, c, nt(t), h, d), t.setAttribute("class", f), a.data = l.firstMPT, t.style.cssText = m, a = a.xfirst = s.parse(t, l.difs, a, o)
                            }
                        });
                        var $t = function(t) {
                            if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                var e, i, n, r, s, a = this.t.style,
                                    o = l.transform.parse;
                                if ("all" === this.e) a.cssText = "", r = !0;
                                else
                                    for (e = this.e.split(" ").join("").split(","), n = e.length; --n > -1;) i = e[n], l[i] && (l[i].parse === o ? r = !0 : i = "transformOrigin" === i ? Lt : l[i].p), Yt(a, i);
                                r && (Yt(a, Rt), (s = this.t._gsTransform) && (s.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                            }
                        };
                        for (Et("clearProps", {
                                parser: function(t, e, n, r, s) {
                                    return s = new xt(t, n, 0, 0, s, 2), s.setRatio = $t, s.e = e, s.pr = -10, s.data = r._tween, i = !0, s
                                }
                            }), c = "bezier,throwProps,physicsProps,physics2D".split(","), Tt = c.length; Tt--;) St(c[Tt]);
                        c = o.prototype, c._firstPT = c._lastParsedTransform = c._transform = null, c._onInitTween = function(t, e, s, h) {
                            if (!t.nodeType) return !1;
                            this._target = g = t, this._tween = s, this._vars = e, y = h, u = e.autoRound, i = !1, n = e.suffixMap || o.suffixMap, r = K(t, ""), a = this._overwriteProps;
                            var c, f, v, _, x, b, w, T, M, S = t.style;
                            if (d && "" === S.zIndex && ("auto" !== (c = tt(t, "zIndex", r)) && "" !== c || this._addLazySet(S, "zIndex", 0)), "string" == typeof e && (_ = S.cssText, c = nt(t, r), S.cssText = _ + ";" + e, c = rt(t, c, nt(t)).difs, !q && E.test(e) && (c.opacity = parseFloat(RegExp.$1)), e = c, S.cssText = _), e.className ? this._firstPT = f = l.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = f = this.parse(t, e, null), this._transformType) {
                                for (M = 3 === this._transformType, Rt ? p && (d = !0, "" === S.zIndex && ("auto" !== (w = tt(t, "zIndex", r)) && "" !== w || this._addLazySet(S, "zIndex", 0)), m && this._addLazySet(S, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (M ? "visible" : "hidden"))) : S.zoom = 1, v = f; v && v._next;) v = v._next;
                                T = new xt(t, "transform", 0, 0, null, 2), this._linkCSSP(T, null, v), T.setRatio = Rt ? Xt : Wt, T.data = this._transform || Vt(t, r, !0), T.tween = s, T.pr = -1, a.pop()
                            }
                            if (i) {
                                for (; f;) {
                                    for (b = f._next, v = _; v && v.pr > f.pr;) v = v._next;
                                    (f._prev = v ? v._prev : x) ? f._prev._next = f: _ = f, (f._next = v) ? v._prev = f : x = f, f = b
                                }
                                this._firstPT = _
                            }
                            return !0
                        }, c.parse = function(t, e, i, s) {
                            var a, o, h, c, d, p, f, m, v, _, x = t.style;
                            for (a in e) {
                                if (p = e[a], "function" == typeof p && (p = p(y, g)), o = l[a]) i = o.parse(t, p, a, this, i, s, e);
                                else {
                                    if ("--" === a.substr(0, 2)) {
                                        this._tween._propLookup[a] = this._addTween.call(this._tween, t.style, "setProperty", K(t).getPropertyValue(a) + "", p + "", a, !1, a);
                                        continue
                                    }
                                    d = tt(t, a, r) + "", v = "string" == typeof p, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || v && A.test(p) ? (v || (p = ft(p), p = (p.length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), i = wt(x, a, d, p, !0, "transparent", i, 0, s)) : v && U.test(p) ? i = wt(x, a, d, p, !0, null, i, 0, s) : (h = parseFloat(d), f = h || 0 === h ? d.substr((h + "").length) : "", "" !== d && "auto" !== d || ("width" === a || "height" === a ? (h = ot(t, a, r), f = "px") : "left" === a || "top" === a ? (h = it(t, a, r), f = "px") : (h = "opacity" !== a ? 0 : 1, f = "")), _ = v && "=" === p.charAt(1), _ ? (c = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), c *= parseFloat(p), m = p.replace(T, "")) : (c = parseFloat(p), m = v ? p.replace(T, "") : ""), "" === m && (m = a in n ? n[a] : f), p = c || 0 === c ? (_ ? c + h : c) + m : e[a], f !== m && ("" === m && "lineHeight" !== a || (c || 0 === c) && h && (h = et(t, a, h, f), "%" === m ? (h /= et(t, a, 100, "%") / 100, !0 !== e.strictUnits && (d = h + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? h /= et(t, a, 1, m) : "px" !== m && (c = et(t, a, c, m), m = "px"), _ && (c || 0 === c) && (p = c + h + m))), _ && (c += h), !h && 0 !== h || !c && 0 !== c ? void 0 !== x[a] && (p || p + "" != "NaN" && null != p) ? (i = new xt(x, a, c || h || 0, 0, i, -1, a, !1, 0, d, p), i.xs0 = "none" !== p || "display" !== a && -1 === a.indexOf("Style") ? p : d) : Z("invalid " + a + " tween value: " + e[a]) : (i = new xt(x, a, h, c - h, i, 0, a, !1 !== u && ("px" === m || "zIndex" === a), 0, d, p), i.xs0 = m))
                                }
                                s && i && !i.plugin && (i.plugin = s)
                            }
                            return i
                        }, c.setRatio = function(t) {
                            var e, i, n, r = this._firstPT;
                            if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                                    for (; r;) {
                                        if (e = r.c * t + r.s, r.r ? e = Math.round(e) : e < 1e-6 && e > -1e-6 && (e = 0), r.type)
                                            if (1 === r.type)
                                                if (2 === (n = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                                else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                        else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                        else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                        else {
                                            for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                            r.t[r.p] = i
                                        } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                                        else r.t[r.p] = e + r.xs0;
                                        r = r._next
                                    } else
                                        for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                                else
                                    for (; r;) {
                                        if (2 !== r.type)
                                            if (r.r && -1 !== r.type)
                                                if (e = Math.round(r.s + r.c), r.type) {
                                                    if (1 === r.type) {
                                                        for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                                        r.t[r.p] = i
                                                    }
                                                } else r.t[r.p] = e + r.xs0;
                                        else r.t[r.p] = r.e;
                                        else r.setRatio(t);
                                        r = r._next
                                    }
                        }, c._enableTransforms = function(t) {
                            this._transform = this._transform || Vt(this._target, r, !0), this._transformType = this._transform.svg && At || !t && 3 !== this._transformType ? 2 : 3
                        };
                        var Qt = function(t) {
                            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                        };
                        c._addLazySet = function(t, e, i) {
                            var n = this._firstPT = new xt(t, e, 0, 0, this._firstPT, 2);
                            n.e = i, n.setRatio = Qt, n.data = this
                        }, c._linkCSSP = function(t, e, i, n) {
                            return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
                        }, c._mod = function(t) {
                            for (var e = this._firstPT; e;) "function" == typeof t[e.p] && t[e.p] === Math.round && (e.r = 1), e = e._next
                        }, c._kill = function(e) {
                            var i, n, r, s = e;
                            if (e.autoAlpha || e.alpha) {
                                s = {};
                                for (n in e) s[n] = e[n];
                                s.opacity = 1, s.autoAlpha && (s.visibility = 1)
                            }
                            for (e.className && (i = this._classNamePT) && (r = i.xfirst, r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), i = this._firstPT; i;) i.plugin && i.plugin !== n && i.plugin._kill && (i.plugin._kill(e), n = i.plugin), i = i._next;
                            return t.prototype._kill.call(this, s)
                        };
                        var Jt = function(t, e, i) {
                            var n, r, s, a;
                            if (t.slice)
                                for (r = t.length; --r > -1;) Jt(t[r], e, i);
                            else
                                for (n = t.childNodes, r = n.length; --r > -1;) s = n[r], a = s.type, s.style && (e.push(nt(s)), i && i.push(s)), 1 !== a && 9 !== a && 11 !== a || !s.childNodes.length || Jt(s, e, i)
                        };
                        return o.cascadeTo = function(t, i, n) {
                            var r, s, a, o, h = e.to(t, i, n),
                                l = [h],
                                c = [],
                                u = [],
                                d = [],
                                p = e._internals.reservedProps;
                            for (t = h._targets || h.target, Jt(t, c, d), h.render(i, !0, !0), Jt(t, u), h.render(0, !0, !0), h._enabled(!0), r = d.length; --r > -1;)
                                if (s = rt(d[r], c[r], u[r]), s.firstMPT) {
                                    s = s.difs;
                                    for (a in n) p[a] && (s[a] = n[a]);
                                    o = {};
                                    for (a in s) o[a] = c[r][a];
                                    l.push(e.fromTo(d[r], i, o, s))
                                }
                            return l
                        }, t.activate([o]), o
                    }, !0),
                    function() {
                        var t = s._gsDefine.plugin({
                                propName: "roundProps",
                                version: "1.6.0",
                                priority: -1,
                                API: 2,
                                init: function(t, e, i) {
                                    return this._tween = i, !0
                                }
                            }),
                            e = function(t) {
                                for (; t;) t.f || t.blob || (t.m = Math.round), t = t._next
                            },
                            i = t.prototype;
                        i._onInitAllProps = function() {
                            for (var t, i, n, r = this._tween, s = r.vars.roundProps.join ? r.vars.roundProps : r.vars.roundProps.split(","), a = s.length, o = {}, h = r._propLookup.roundProps; --a > -1;) o[s[a]] = Math.round;
                            for (a = s.length; --a > -1;)
                                for (t = s[a], i = r._firstPT; i;) n = i._next, i.pg ? i.t._mod(o) : i.n === t && (2 === i.f && i.t ? e(i.t._firstPT) : (this._add(i.t, t, i.s, i.c), n && (n._prev = i._prev), i._prev ? i._prev._next = n : r._firstPT === i && (r._firstPT = n), i._next = i._prev = null, r._propLookup[t] = h)), i = n;
                            return !1
                        }, i._add = function(t, e, i, n) {
                            this._addTween(t, e, i, i + n, e, Math.round), this._overwriteProps.push(e)
                        }
                    }(),
                    function() {
                        s._gsDefine.plugin({
                            propName: "attr",
                            API: 2,
                            version: "0.6.1",
                            init: function(t, e, i, n) {
                                var r, s;
                                if ("function" != typeof t.setAttribute) return !1;
                                for (r in e) s = e[r], "function" == typeof s && (s = s(n, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", s + "", r, !1, r), this._overwriteProps.push(r);
                                return !0
                            }
                        })
                    }(), s._gsDefine.plugin({
                        propName: "directionalRotation",
                        version: "0.3.1",
                        API: 2,
                        init: function(t, e, i, n) {
                            "object" != typeof e && (e = {
                                rotation: e
                            }), this.finals = {};
                            var r, s, a, o, h, l, c = !0 === e.useRadians ? 2 * Math.PI : 360;
                            for (r in e) "useRadians" !== r && (o = e[r], "function" == typeof o && (o = o(n, t)), l = (o + "").split("_"), s = l[0], a = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), o = this.finals[r] = "string" == typeof s && "=" === s.charAt(1) ? a + parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2)) : Number(s) || 0, h = o - a, l.length && (s = l.join("_"), -1 !== s.indexOf("short") && (h %= c) !== h % (c / 2) && (h = h < 0 ? h + c : h - c), -1 !== s.indexOf("_cw") && h < 0 ? h = (h + 9999999999 * c) % c - (h / c | 0) * c : -1 !== s.indexOf("ccw") && h > 0 && (h = (h - 9999999999 * c) % c - (h / c | 0) * c)), (h > 1e-6 || h < -1e-6) && (this._addTween(t, r, a, a + h, r), this._overwriteProps.push(r)));
                            return !0
                        },
                        set: function(t) {
                            var e;
                            if (1 !== t) this._super.setRatio.call(this, t);
                            else
                                for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
                        }
                    })._autoCSS = !0, s._gsDefine("easing.Back", ["easing.Ease"], function(t) {
                        var e, i, n, r = s.GreenSockGlobals || s,
                            a = r.com.greensock,
                            o = 2 * Math.PI,
                            h = Math.PI / 2,
                            l = a._class,
                            c = function(e, i) {
                                var n = l("easing." + e, function() {}, !0),
                                    r = n.prototype = new t;
                                return r.constructor = n, r.getRatio = i, n
                            },
                            u = t.register || function() {},
                            d = function(t, e, i, n, r) {
                                var s = l("easing." + t, {
                                    easeOut: new e,
                                    easeIn: new i,
                                    easeInOut: new n
                                }, !0);
                                return u(s, t), s
                            },
                            p = function(t, e, i) {
                                this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
                            },
                            f = function(e, i) {
                                var n = l("easing." + e, function(t) {
                                        this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                                    }, !0),
                                    r = n.prototype = new t;
                                return r.constructor = n, r.getRatio = i, r.config = function(t) {
                                    return new n(t)
                                }, n
                            },
                            m = d("Back", f("BackOut", function(t) {
                                return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                            }), f("BackIn", function(t) {
                                return t * t * ((this._p1 + 1) * t - this._p1)
                            }), f("BackInOut", function(t) {
                                return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                            })),
                            v = l("easing.SlowMo", function(t, e, i) {
                                e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
                            }, !0),
                            g = v.prototype = new t;
                        return g.constructor = v, g.getRatio = function(t) {
                            var e = t + (.5 - t) * this._p;
                            return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
                        }, v.ease = new v(.7, .7), g.config = v.config = function(t, e, i) {
                            return new v(t, e, i)
                        }, e = l("easing.SteppedEase", function(t, e) {
                            t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
                        }, !0), g = e.prototype = new t, g.constructor = e, g.getRatio = function(t) {
                            return t < 0 ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
                        }, g.config = e.config = function(t, i) {
                            return new e(t, i)
                        }, i = l("easing.RoughEase", function(e) {
                            e = e || {};
                            for (var i, n, r, s, a, o, h = e.taper || "none", l = [], c = 0, u = 0 | (e.points || 20), d = u, f = !1 !== e.randomize, m = !0 === e.clamp, v = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --d > -1;) i = f ? Math.random() : 1 / u * d, n = v ? v.getRatio(i) : i, "none" === h ? r = g : "out" === h ? (s = 1 - i, r = s * s * g) : "in" === h ? r = i * i * g : i < .5 ? (s = 2 * i, r = s * s * .5 * g) : (s = 2 * (1 - i), r = s * s * .5 * g), f ? n += Math.random() * r - .5 * r : d % 2 ? n += .5 * r : n -= .5 * r, m && (n > 1 ? n = 1 : n < 0 && (n = 0)), l[c++] = {
                                x: i,
                                y: n
                            };
                            for (l.sort(function(t, e) {
                                    return t.x - e.x
                                }), o = new p(1, 1, null), d = u; --d > -1;) a = l[d], o = new p(a.x, a.y, o);
                            this._prev = new p(0, 0, 0 !== o.t ? o : o.next)
                        }, !0), g = i.prototype = new t, g.constructor = i, g.getRatio = function(t) {
                            var e = this._prev;
                            if (t > e.t) {
                                for (; e.next && t >= e.t;) e = e.next;
                                e = e.prev
                            } else
                                for (; e.prev && t <= e.t;) e = e.prev;
                            return this._prev = e, e.v + (t - e.t) / e.gap * e.c
                        }, g.config = function(t) {
                            return new i(t)
                        }, i.ease = new i, d("Bounce", c("BounceOut", function(t) {
                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                        }), c("BounceIn", function(t) {
                            return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
                        }), c("BounceInOut", function(t) {
                            var e = t < .5;
                            return t = e ? 1 - 2 * t : 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
                        })), d("Circ", c("CircOut", function(t) {
                            return Math.sqrt(1 - (t -= 1) * t)
                        }), c("CircIn", function(t) {
                            return -(Math.sqrt(1 - t * t) - 1)
                        }), c("CircInOut", function(t) {
                            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                        })), n = function(e, i, n) {
                            var r = l("easing." + e, function(t, e) {
                                    this._p1 = t >= 1 ? t : 1, this._p2 = (e || n) / (t < 1 ? t : 1), this._p3 = this._p2 / o * (Math.asin(1 / this._p1) || 0), this._p2 = o / this._p2
                                }, !0),
                                s = r.prototype = new t;
                            return s.constructor = r, s.getRatio = i, s.config = function(t, e) {
                                return new r(t, e)
                            }, r
                        }, d("Elastic", n("ElasticOut", function(t) {
                            return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
                        }, .3), n("ElasticIn", function(t) {
                            return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)
                        }, .3), n("ElasticInOut", function(t) {
                            return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
                        }, .45)), d("Expo", c("ExpoOut", function(t) {
                            return 1 - Math.pow(2, -10 * t)
                        }), c("ExpoIn", function(t) {
                            return Math.pow(2, 10 * (t - 1)) - .001
                        }), c("ExpoInOut", function(t) {
                            return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                        })), d("Sine", c("SineOut", function(t) {
                            return Math.sin(t * h)
                        }), c("SineIn", function(t) {
                            return 1 - Math.cos(t * h)
                        }), c("SineInOut", function(t) {
                            return -.5 * (Math.cos(Math.PI * t) - 1)
                        })), l("easing.EaseLookup", {
                            find: function(e) {
                                return t.map[e]
                            }
                        }, !0), u(r.SlowMo, "SlowMo", "ease,"), u(i, "RoughEase", "ease,"), u(e, "SteppedEase", "ease,"), m
                    }, !0)
            }), s._gsDefine && s._gsQueue.pop()(),
            function(i, s) {
                "use strict";
                var a = {},
                    o = i.document,
                    h = i.GreenSockGlobals = i.GreenSockGlobals || i;
                if (!h.TweenLite) {
                    var l, c, u, d, p, f = function(t) {
                            var e, i = t.split("."),
                                n = h;
                            for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                            return n
                        },
                        m = f("com.greensock"),
                        v = function(t) {
                            var e, i = [],
                                n = t.length;
                            for (e = 0; e !== n; i.push(t[e++]));
                            return i
                        },
                        g = function() {},
                        y = function() {
                            var t = Object.prototype.toString,
                                e = t.call([]);
                            return function(i) {
                                return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                            }
                        }(),
                        _ = {},
                        x = function(i, s, o, l) {
                            this.sc = _[i] ? _[i].sc : [], _[i] = this, this.gsClass = null, this.func = o;
                            var c = [];
                            this.check = function(u) {
                                for (var d, p, m, v, g = s.length, y = g; --g > -1;)(d = _[s[g]] || new x(s[g], [])).gsClass ? (c[g] = d.gsClass, y--) : u && d.sc.push(this);
                                if (0 === y && o) {
                                    if (p = ("com.greensock." + i).split("."), m = p.pop(), v = f(p.join("."))[m] = this.gsClass = o.apply(o, c), l)
                                        if (h[m] = a[m] = v, void 0 !== t && t.exports)
                                            if ("TweenMax" === i) {
                                                t.exports = a.TweenMax = v;
                                                for (g in a) v[g] = a[g]
                                            } else a.TweenMax && (a.TweenMax[m] = v);
                                    else n = [], void 0 !== (r = function() {
                                        return v
                                    }.apply(e, n)) && (t.exports = r);
                                    for (g = 0; g < this.sc.length; g++) this.sc[g].check()
                                }
                            }, this.check(!0)
                        },
                        b = i._gsDefine = function(t, e, i, n) {
                            return new x(t, e, i, n)
                        },
                        w = m._class = function(t, e, i) {
                            return e = e || function() {}, b(t, [], function() {
                                return e
                            }, i), e
                        };
                    b.globals = h;
                    var T = [0, 0, 1, 1],
                        M = w("easing.Ease", function(t, e, i, n) {
                            this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? T.concat(e) : T
                        }, !0),
                        E = M.map = {},
                        S = M.register = function(t, e, i, n) {
                            for (var r, s, a, o, h = e.split(","), l = h.length, c = (i || "easeIn,easeOut,easeInOut").split(","); --l > -1;)
                                for (s = h[l], r = n ? w("easing." + s, null, !0) : m.easing[s] || {}, a = c.length; --a > -1;) o = c[a], E[s + "." + o] = E[o + s] = r[o] = t.getRatio ? t : t[o] || new t
                        };
                    for (u = M.prototype, u._calcEnd = !1, u.getRatio = function(t) {
                            if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                            var e = this._type,
                                i = this._power,
                                n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                            return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                        }, l = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], c = l.length; --c > -1;) u = l[c] + ",Power" + c, S(new M(null, null, 1, c), u, "easeOut", !0), S(new M(null, null, 2, c), u, "easeIn" + (0 === c ? ",easeNone" : "")), S(new M(null, null, 3, c), u, "easeInOut");
                    E.linear = m.easing.Linear.easeIn, E.swing = m.easing.Quad.easeInOut;
                    var A = w("events.EventDispatcher", function(t) {
                        this._listeners = {}, this._eventTarget = t || this
                    });
                    u = A.prototype, u.addEventListener = function(t, e, i, n, r) {
                        r = r || 0;
                        var s, a, o = this._listeners[t],
                            h = 0;
                        for (this !== d || p || d.wake(), null == o && (this._listeners[t] = o = []), a = o.length; --a > -1;) s = o[a], s.c === e && s.s === i ? o.splice(a, 1) : 0 === h && s.pr < r && (h = a + 1);
                        o.splice(h, 0, {
                            c: e,
                            s: i,
                            up: n,
                            pr: r
                        })
                    }, u.removeEventListener = function(t, e) {
                        var i, n = this._listeners[t];
                        if (n)
                            for (i = n.length; --i > -1;)
                                if (n[i].c === e) return void n.splice(i, 1)
                    }, u.dispatchEvent = function(t) {
                        var e, i, n, r = this._listeners[t];
                        if (r)
                            for (e = r.length, e > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                                type: t,
                                target: i
                            }) : n.c.call(n.s || i))
                    };
                    var P = i.requestAnimationFrame,
                        R = i.cancelAnimationFrame,
                        C = Date.now || function() {
                            return (new Date).getTime()
                        },
                        L = C();
                    for (l = ["ms", "moz", "webkit", "o"], c = l.length; --c > -1 && !P;) P = i[l[c] + "RequestAnimationFrame"], R = i[l[c] + "CancelAnimationFrame"] || i[l[c] + "CancelRequestAnimationFrame"];
                    w("Ticker", function(t, e) {
                        var i, n, r, s, a, h = this,
                            l = C(),
                            c = !(!1 === e || !P) && "auto",
                            u = 500,
                            f = 33,
                            m = function(t) {
                                var e, o, c = C() - L;
                                c > u && (l += c - f), L += c, h.time = (L - l) / 1e3, e = h.time - a, (!i || e > 0 || !0 === t) && (h.frame++, a += e + (e >= s ? .004 : s - e), o = !0), !0 !== t && (r = n(m)), o && h.dispatchEvent("tick")
                            };
                        A.call(h), h.time = h.frame = 0, h.tick = function() {
                            m(!0)
                        }, h.lagSmoothing = function(t, e) {
                            if (!arguments.length) return u < 1e10;
                            u = t || 1e10, f = Math.min(e, u, 0)
                        }, h.sleep = function() {
                            null != r && (c && R ? R(r) : clearTimeout(r), n = g, r = null, h === d && (p = !1))
                        }, h.wake = function(t) {
                            null !== r ? h.sleep() : t ? l += -L + (L = C()) : h.frame > 10 && (L = C() - u + 5), n = 0 === i ? g : c && P ? P : function(t) {
                                return setTimeout(t, 1e3 * (a - h.time) + 1 | 0)
                            }, h === d && (p = !0), m(2)
                        }, h.fps = function(t) {
                            if (!arguments.length) return i;
                            i = t, s = 1 / (i || 60), a = this.time + s, h.wake()
                        }, h.useRAF = function(t) {
                            if (!arguments.length) return c;
                            h.sleep(), c = t, h.fps(i)
                        }, h.fps(t), setTimeout(function() {
                            "auto" === c && h.frame < 5 && "hidden" !== o.visibilityState && h.useRAF(!1)
                        }, 1500)
                    }), u = m.Ticker.prototype = new m.events.EventDispatcher, u.constructor = m.Ticker;
                    var O = w("core.Animation", function(t, e) {
                        if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, J) {
                            p || d.wake();
                            var i = this.vars.useFrames ? Q : J;
                            i.add(this, i._time), this.vars.paused && this.paused(!0)
                        }
                    });
                    d = O.ticker = new m.Ticker, u = O.prototype, u._dirty = u._gc = u._initted = u._paused = !1, u._totalTime = u._time = 0, u._rawPrevTime = -1, u._next = u._last = u._onUpdate = u._timeline = u.timeline = null, u._paused = !1;
                    var I = function() {
                        p && C() - L > 2e3 && ("hidden" !== o.visibilityState || !d.lagSmoothing()) && d.wake();
                        var t = setTimeout(I, 2e3);
                        t.unref && t.unref()
                    };
                    I(), u.play = function(t, e) {
                        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                    }, u.pause = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!0)
                    }, u.resume = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!1)
                    }, u.seek = function(t, e) {
                        return this.totalTime(Number(t), !1 !== e)
                    }, u.restart = function(t, e) {
                        return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
                    }, u.reverse = function(t, e) {
                        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                    }, u.render = function(t, e, i) {}, u.invalidate = function() {
                        return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                    }, u.isActive = function() {
                        var t, e = this._timeline,
                            i = this._startTime;
                        return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
                    }, u._enabled = function(t, e) {
                        return p || d.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                    }, u._kill = function(t, e) {
                        return this._enabled(!1, !1)
                    }, u.kill = function(t, e) {
                        return this._kill(t, e), this
                    }, u._uncache = function(t) {
                        for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                        return this
                    }, u._swapSelfInParams = function(t) {
                        for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                        return i
                    }, u._callback = function(t) {
                        var e = this.vars,
                            i = e[t],
                            n = e[t + "Params"],
                            r = e[t + "Scope"] || e.callbackScope || this;
                        switch (n ? n.length : 0) {
                            case 0:
                                i.call(r);
                                break;
                            case 1:
                                i.call(r, n[0]);
                                break;
                            case 2:
                                i.call(r, n[0], n[1]);
                                break;
                            default:
                                i.apply(r, n)
                        }
                    }, u.eventCallback = function(t, e, i, n) {
                        if ("on" === (t || "").substr(0, 2)) {
                            var r = this.vars;
                            if (1 === arguments.length) return r[t];
                            null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = y(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                        }
                        return this
                    }, u.delay = function(t) {
                        return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                    }, u.duration = function(t) {
                        return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                    }, u.totalDuration = function(t) {
                        return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                    }, u.time = function(t, e) {
                        return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                    }, u.totalTime = function(t, e, i) {
                        if (p || d.wake(), !arguments.length) return this._totalTime;
                        if (this._timeline) {
                            if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                                this._dirty && this.totalDuration();
                                var n = this._totalDuration,
                                    r = this._timeline;
                                if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                    for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                            }
                            this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (k.length && tt(), this.render(t, e, !1), k.length && tt())
                        }
                        return this
                    }, u.progress = u.totalProgress = function(t, e) {
                        var i = this.duration();
                        return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
                    }, u.startTime = function(t) {
                        return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                    }, u.endTime = function(t) {
                        return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                    }, u.timeScale = function(t) {
                        if (!arguments.length) return this._timeScale;
                        var e, i;
                        for (t = t || 1e-10, this._timeline && this._timeline.smoothChildTiming && (e = this._pauseTime, i = e || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
                        return this
                    }, u.reversed = function(t) {
                        return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                    }, u.paused = function(t) {
                        if (!arguments.length) return this._paused;
                        var e, i, n = this._timeline;
                        return t != this._paused && n && (p || t || d.wake(), e = n.rawTime(), i = e - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                    };
                    var D = w("core.SimpleTimeline", function(t) {
                        O.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                    });
                    u = D.prototype = new O, u.constructor = D, u.kill()._gc = !1, u._first = u._last = u._recent = null, u._sortChildren = !1, u.add = u.insert = function(t, e, i, n) {
                        var r, s;
                        if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                            for (s = t._startTime; r && r._startTime > s;) r = r._prev;
                        return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
                    }, u._remove = function(t, e) {
                        return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                    }, u.render = function(t, e, i) {
                        var n, r = this._first;
                        for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
                    }, u.rawTime = function() {
                        return p || d.wake(), this._totalTime
                    };
                    var z = w("TweenLite", function(t, e, n) {
                            if (O.call(this, e, n), this.render = z.prototype.render, null == t) throw "Cannot tween a null target.";
                            this.target = t = "string" != typeof t ? t : z.selector(t) || t;
                            var r, s, a, o = t.jquery || t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType),
                                h = this.vars.overwrite;
                            if (this._overwrite = h = null == h ? $[z.defaultOverwrite] : "number" == typeof h ? h >> 0 : $[h], (o || t instanceof Array || t.push && y(t)) && "number" != typeof t[0])
                                for (this._targets = a = v(t), this._propLookup = [], this._siblings = [], r = 0; r < a.length; r++) s = a[r], s ? "string" != typeof s ? s.length && s !== i && s[0] && (s[0] === i || s[0].nodeType && s[0].style && !s.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(v(s))) : (this._siblings[r] = et(s, this, !1), 1 === h && this._siblings[r].length > 1 && nt(s, this, null, 1, this._siblings[r])) : "string" == typeof(s = a[r--] = z.selector(s)) && a.splice(r + 1, 1) : a.splice(r--, 1);
                            else this._propLookup = {}, this._siblings = et(t, this, !1), 1 === h && this._siblings.length > 1 && nt(t, this, null, 1, this._siblings);
                            (this.vars.immediateRender || 0 === e && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay)))
                        }, !0),
                        U = function(t) {
                            return t && t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType)
                        },
                        N = function(t, e) {
                            var i, n = {};
                            for (i in t) Z[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!X[i] || X[i] && X[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                            t.css = n
                        };
                    u = z.prototype = new O, u.constructor = z, u.kill()._gc = !1, u.ratio = 0, u._firstPT = u._targets = u._overwrittenProps = u._startAt = null, u._notifyPluginsOfEnabled = u._lazy = !1, z.version = "1.20.3", z.defaultEase = u._ease = new M(null, null, 1, 1), z.defaultOverwrite = "auto", z.ticker = d, z.autoSleep = 120, z.lagSmoothing = function(t, e) {
                        d.lagSmoothing(t, e)
                    }, z.selector = i.$ || i.jQuery || function(t) {
                        var e = i.$ || i.jQuery;
                        return e ? (z.selector = e, e(t)) : void 0 === o ? t : o.querySelectorAll ? o.querySelectorAll(t) : o.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
                    };
                    var k = [],
                        F = {},
                        B = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                        G = /[\+-]=-?[\.\d]/,
                        H = function(t) {
                            for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m(e, this._target || i.t) : e < 1e-6 && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                        },
                        j = function(t, e, i, n) {
                            var r, s, a, o, h, l, c, u = [],
                                d = 0,
                                p = "",
                                f = 0;
                            for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(B) || [], s = e.match(B) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), h = s.length, o = 0; o < h; o++) c = s[o], l = e.substr(d, e.indexOf(c, d) - d), p += l || !o ? l : ",", d += l.length, f ? f = (f + 1) % 5 : "rgba(" === l.substr(-5) && (f = 1), c === r[o] || r.length <= o ? p += c : (p && (u.push(p), p = ""), a = parseFloat(r[o]), u.push(a), u._firstPT = {
                                _next: u._firstPT,
                                t: u,
                                p: u.length - 1,
                                s: a,
                                c: ("=" === c.charAt(1) ? parseInt(c.charAt(0) + "1", 10) * parseFloat(c.substr(2)) : parseFloat(c) - a) || 0,
                                f: 0,
                                m: f && f < 4 ? Math.round : 0
                            }), d += c.length;
                            return p += e.substr(d), p && u.push(p), u.setRatio = H, G.test(e) && (u.end = null), u
                        },
                        V = function(t, e, i, n, r, s, a, o, h) {
                            "function" == typeof n && (n = n(h || 0, t));
                            var l, c = typeof t[e],
                                u = "function" !== c ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                                d = "get" !== i ? i : u ? a ? t[u](a) : t[u]() : t[e],
                                p = "string" == typeof n && "=" === n.charAt(1),
                                f = {
                                    t: t,
                                    p: e,
                                    s: d,
                                    f: "function" === c,
                                    pg: 0,
                                    n: r || e,
                                    m: s ? "function" == typeof s ? s : Math.round : 0,
                                    pr: 0,
                                    c: p ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - d || 0
                                };
                            if (("number" != typeof d || "number" != typeof n && !p) && (a || isNaN(d) || !p && isNaN(n) || "boolean" == typeof d || "boolean" == typeof n ? (f.fp = a, l = j(d, p ? parseFloat(f.s) + f.c : n, o || z.defaultStringFilter, f), f = {
                                    t: l,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 2,
                                    pg: 0,
                                    n: r || e,
                                    pr: 0,
                                    m: 0
                                }) : (f.s = parseFloat(d), p || (f.c = parseFloat(n) - f.s || 0))), f.c) return (f._next = this._firstPT) && (f._next._prev = f), this._firstPT = f, f
                        },
                        W = z._internals = {
                            isArray: y,
                            isSelector: U,
                            lazyTweens: k,
                            blobDif: j
                        },
                        X = z._plugins = {},
                        q = W.tweenLookup = {},
                        Y = 0,
                        Z = W.reservedProps = {
                            ease: 1,
                            delay: 1,
                            overwrite: 1,
                            onComplete: 1,
                            onCompleteParams: 1,
                            onCompleteScope: 1,
                            useFrames: 1,
                            runBackwards: 1,
                            startAt: 1,
                            onUpdate: 1,
                            onUpdateParams: 1,
                            onUpdateScope: 1,
                            onStart: 1,
                            onStartParams: 1,
                            onStartScope: 1,
                            onReverseComplete: 1,
                            onReverseCompleteParams: 1,
                            onReverseCompleteScope: 1,
                            onRepeat: 1,
                            onRepeatParams: 1,
                            onRepeatScope: 1,
                            easeParams: 1,
                            yoyo: 1,
                            immediateRender: 1,
                            repeat: 1,
                            repeatDelay: 1,
                            data: 1,
                            paused: 1,
                            reversed: 1,
                            autoCSS: 1,
                            lazy: 1,
                            onOverwrite: 1,
                            callbackScope: 1,
                            stringFilter: 1,
                            id: 1,
                            yoyoEase: 1
                        },
                        $ = {
                            none: 0,
                            all: 1,
                            auto: 2,
                            concurrent: 3,
                            allOnStart: 4,
                            preexisting: 5,
                            true: 1,
                            false: 0
                        },
                        Q = O._rootFramesTimeline = new D,
                        J = O._rootTimeline = new D,
                        K = 30,
                        tt = W.lazyRender = function() {
                            var t, e = k.length;
                            for (F = {}; --e > -1;)(t = k[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                            k.length = 0
                        };
                    J._startTime = d.time, Q._startTime = d.frame, J._active = Q._active = !0, setTimeout(tt, 1), O._updateRoot = z.render = function() {
                        var t, e, i;
                        if (k.length && tt(), J.render((d.time - J._startTime) * J._timeScale, !1, !1), Q.render((d.frame - Q._startTime) * Q._timeScale, !1, !1), k.length && tt(), d.frame >= K) {
                            K = d.frame + (parseInt(z.autoSleep, 10) || 120);
                            for (i in q) {
                                for (e = q[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);
                                0 === e.length && delete q[i]
                            }
                            if ((!(i = J._first) || i._paused) && z.autoSleep && !Q._first && 1 === d._listeners.tick.length) {
                                for (; i && i._paused;) i = i._next;
                                i || d.sleep()
                            }
                        }
                    }, d.addEventListener("tick", O._updateRoot);
                    var et = function(t, e, i) {
                            var n, r, s = t._gsTweenID;
                            if (q[s || (t._gsTweenID = s = "t" + Y++)] || (q[s] = {
                                    target: t,
                                    tweens: []
                                }), e && (n = q[s].tweens, n[r = n.length] = e, i))
                                for (; --r > -1;) n[r] === e && n.splice(r, 1);
                            return q[s].tweens
                        },
                        it = function(t, e, i, n) {
                            var r, s, a = t.vars.onOverwrite;
                            return a && (r = a(t, e, i, n)), a = z.onOverwrite, a && (s = a(t, e, i, n)), !1 !== r && !1 !== s
                        },
                        nt = function(t, e, i, n, r) {
                            var s, a, o, h;
                            if (1 === n || n >= 4) {
                                for (h = r.length, s = 0; s < h; s++)
                                    if ((o = r[s]) !== e) o._gc || o._kill(null, t, e) && (a = !0);
                                    else if (5 === n) break;
                                return a
                            }
                            var l, c = e._startTime + 1e-10,
                                u = [],
                                d = 0,
                                p = 0 === e._duration;
                            for (s = r.length; --s > -1;)(o = r[s]) === e || o._gc || o._paused || (o._timeline !== e._timeline ? (l = l || rt(e, 0, p), 0 === rt(o, l, p) && (u[d++] = o)) : o._startTime <= c && o._startTime + o.totalDuration() / o._timeScale > c && ((p || !o._initted) && c - o._startTime <= 2e-10 || (u[d++] = o)));
                            for (s = d; --s > -1;)
                                if (o = u[s], 2 === n && o._kill(i, t, e) && (a = !0), 2 !== n || !o._firstPT && o._initted) {
                                    if (2 !== n && !it(o, e)) continue;
                                    o._enabled(!1, !1) && (a = !0)
                                }
                            return a
                        },
                        rt = function(t, e, i) {
                            for (var n = t._timeline, r = n._timeScale, s = t._startTime; n._timeline;) {
                                if (s += n._startTime, r *= n._timeScale, n._paused) return -100;
                                n = n._timeline
                            }
                            return s /= r, s > e ? s - e : i && s === e || !t._initted && s - e < 2e-10 ? 1e-10 : (s += t.totalDuration() / t._timeScale / r) > e + 1e-10 ? 0 : s - e - 1e-10
                        };
                    u._init = function() {
                        var t, e, i, n, r, s, a = this.vars,
                            o = this._overwrittenProps,
                            h = this._duration,
                            l = !!a.immediateRender,
                            c = a.ease;
                        if (a.startAt) {
                            this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {};
                            for (n in a.startAt) r[n] = a.startAt[n];
                            if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = l && !1 !== a.lazy, r.startAt = r.delay = null, r.onUpdate = a.onUpdate, r.onUpdateParams = a.onUpdateParams, r.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = z.to(this.target, 0, r), l)
                                if (this._time > 0) this._startAt = null;
                                else if (0 !== h) return
                        } else if (a.runBackwards && 0 !== h)
                            if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                            else {
                                0 !== this._time && (l = !1), i = {};
                                for (n in a) Z[n] && "autoCSS" !== n || (i[n] = a[n]);
                                if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && !1 !== a.lazy, i.immediateRender = l, this._startAt = z.to(this.target, 0, i), l) {
                                    if (0 === this._time) return
                                } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                            }
                        if (this._ease = c = c ? c instanceof M ? c : "function" == typeof c ? new M(c, a.easeParams) : E[c] || z.defaultEase : z.defaultEase, a.easeParams instanceof Array && c.config && (this._ease = c.config.apply(c, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                            for (s = this._targets.length, t = 0; t < s; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], o ? o[t] : null, t) && (e = !0);
                        else e = this._initProps(this.target, this._propLookup, this._siblings, o, 0);
                        if (e && z._onPluginEvent("_onInitAllProps", this), o && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                            for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                        this._onUpdate = a.onUpdate, this._initted = !0
                    }, u._initProps = function(t, e, n, r, s) {
                        var a, o, h, l, c, u;
                        if (null == t) return !1;
                        F[t._gsTweenID] && tt(), this.vars.css || t.style && t !== i && t.nodeType && X.css && !1 !== this.vars.autoCSS && N(this.vars, t);
                        for (a in this.vars)
                            if (u = this.vars[a], Z[a]) u && (u instanceof Array || u.push && y(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[a] = u = this._swapSelfInParams(u, this));
                            else if (X[a] && (l = new X[a])._onInitTween(t, this.vars[a], this, s)) {
                            for (this._firstPT = c = {
                                    _next: this._firstPT,
                                    t: l,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 1,
                                    n: a,
                                    pg: 1,
                                    pr: l._priority,
                                    m: 0
                                }, o = l._overwriteProps.length; --o > -1;) e[l._overwriteProps[o]] = this._firstPT;
                            (l._priority || l._onInitAllProps) && (h = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), c._next && (c._next._prev = c)
                        } else e[a] = V.call(this, t, a, "get", u, a, 0, null, this.vars.stringFilter, s);
                        return r && this._kill(r, t) ? this._initProps(t, e, n, r, s) : this._overwrite > 1 && this._firstPT && n.length > 1 && nt(t, this, e, this._overwrite, n) ? (this._kill(e, t), this._initProps(t, e, n, r, s)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (F[t._gsTweenID] = !0), h)
                    }, u.render = function(t, e, i) {
                        var n, r, s, a, o = this._time,
                            h = this._duration,
                            l = this._rawPrevTime;
                        if (t >= h - 1e-7 && t >= 0) this._totalTime = this._time = h, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === h && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (l < 0 || t <= 0 && t >= -1e-7 || 1e-10 === l && "isPause" !== this.data) && l !== t && (i = !0, l > 1e-10 && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || l === t ? t : 1e-10);
                        else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== o || 0 === h && l > 0) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === h && (this._initted || !this.vars.lazy || i) && (l >= 0 && (1e-10 !== l || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || l === t ? t : 1e-10)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
                        else if (this._totalTime = this._time = t, this._easeType) {
                            var c = t / h,
                                u = this._easeType,
                                d = this._easePower;
                            (1 === u || 3 === u && c >= .5) && (c = 1 - c), 3 === u && (c *= 2), 1 === d ? c *= c : 2 === d ? c *= c * c : 3 === d ? c *= c * c * c : 4 === d && (c *= c * c * c * c), this.ratio = 1 === u ? 1 - c : 2 === u ? c : t / h < .5 ? c / 2 : 1 - c / 2
                        } else this.ratio = this._ease.getRatio(t / h);
                        if (this._time !== o || i) {
                            if (!this._initted) {
                                if (this._init(), !this._initted || this._gc) return;
                                if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = o, this._rawPrevTime = l, k.push(this), void(this._lazy = [t, e]);
                                this._time && !n ? this.ratio = this._ease.getRatio(this._time / h) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                            }
                            for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== o && t >= 0 && (this._active = !0), 0 === o && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== h || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                            this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== o || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === h && 1e-10 === this._rawPrevTime && 1e-10 !== a && (this._rawPrevTime = 0)))
                        }
                    }, u._kill = function(t, e, i) {
                        if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                        e = "string" != typeof e ? e || this._targets || this.target : z.selector(e) || e;
                        var n, r, s, a, o, h, l, c, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                        if ((y(e) || U(e)) && "number" != typeof e[0])
                            for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (h = !0);
                        else {
                            if (this._targets) {
                                for (n = this._targets.length; --n > -1;)
                                    if (e === this._targets[n]) {
                                        o = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                        break
                                    }
                            } else {
                                if (e !== this.target) return !1;
                                o = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                            }
                            if (o) {
                                if (l = t || o, c = t !== r && "all" !== r && t !== o && ("object" != typeof t || !t._tempKill), i && (z.onOverwrite || this.vars.onOverwrite)) {
                                    for (s in l) o[s] && (u || (u = []), u.push(s));
                                    if ((u || !t) && !it(this, i, e, u)) return !1
                                }
                                for (s in l)(a = o[s]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, h = !0), a.pg && a.t._kill(l) && (h = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete o[s]), c && (r[s] = 1);
                                !this._firstPT && this._initted && this._enabled(!1, !1)
                            }
                        }
                        return h
                    }, u.invalidate = function() {
                        return this._notifyPluginsOfEnabled && z._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], O.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this
                    }, u._enabled = function(t, e) {
                        if (p || d.wake(), t && this._gc) {
                            var i, n = this._targets;
                            if (n)
                                for (i = n.length; --i > -1;) this._siblings[i] = et(n[i], this, !0);
                            else this._siblings = et(this.target, this, !0)
                        }
                        return O.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && z._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                    }, z.to = function(t, e, i) {
                        return new z(t, e, i)
                    }, z.from = function(t, e, i) {
                        return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new z(t, e, i)
                    }, z.fromTo = function(t, e, i, n) {
                        return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new z(t, e, n)
                    }, z.delayedCall = function(t, e, i, n, r) {
                        return new z(e, 0, {
                            delay: t,
                            onComplete: e,
                            onCompleteParams: i,
                            callbackScope: n,
                            onReverseComplete: e,
                            onReverseCompleteParams: i,
                            immediateRender: !1,
                            lazy: !1,
                            useFrames: r,
                            overwrite: 0
                        })
                    }, z.set = function(t, e) {
                        return new z(t, 0, e)
                    }, z.getTweensOf = function(t, e) {
                        if (null == t) return [];
                        t = "string" != typeof t ? t : z.selector(t) || t;
                        var i, n, r, s;
                        if ((y(t) || U(t)) && "number" != typeof t[0]) {
                            for (i = t.length, n = []; --i > -1;) n = n.concat(z.getTweensOf(t[i], e));
                            for (i = n.length; --i > -1;)
                                for (s = n[i], r = i; --r > -1;) s === n[r] && n.splice(i, 1)
                        } else if (t._gsTweenID)
                            for (n = et(t).concat(), i = n.length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                        return n || []
                    }, z.killTweensOf = z.killDelayedCallsTo = function(t, e, i) {
                        "object" == typeof e && (i = e, e = !1);
                        for (var n = z.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
                    };
                    var st = w("plugins.TweenPlugin", function(t, e) {
                        this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = st.prototype
                    }, !0);
                    if (u = st.prototype, st.version = "1.19.0", st.API = 2, u._firstPT = null, u._addTween = V, u.setRatio = H, u._kill = function(t) {
                            var e, i = this._overwriteProps,
                                n = this._firstPT;
                            if (null != t[this._propName]) this._overwriteProps = [];
                            else
                                for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                            for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                            return !1
                        }, u._mod = u._roundProps = function(t) {
                            for (var e, i = this._firstPT; i;) e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")], e && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
                        }, z._onPluginEvent = function(t, e) {
                            var i, n, r, s, a, o = e._firstPT;
                            if ("_onInitAllProps" === t) {
                                for (; o;) {
                                    for (a = o._next, n = r; n && n.pr > o.pr;) n = n._next;
                                    (o._prev = n ? n._prev : s) ? o._prev._next = o: r = o, (o._next = n) ? n._prev = o : s = o, o = a
                                }
                                o = e._firstPT = r
                            }
                            for (; o;) o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next;
                            return i
                        }, st.activate = function(t) {
                            for (var e = t.length; --e > -1;) t[e].API === st.API && (X[(new t[e])._propName] = t[e]);
                            return !0
                        }, b.plugin = function(t) {
                            if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                            var e, i = t.propName,
                                n = t.priority || 0,
                                r = t.overwriteProps,
                                s = {
                                    init: "_onInitTween",
                                    set: "setRatio",
                                    kill: "_kill",
                                    round: "_mod",
                                    mod: "_mod",
                                    initAll: "_onInitAllProps"
                                },
                                a = w("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                                    st.call(this, i, n), this._overwriteProps = r || []
                                }, !0 === t.global),
                                o = a.prototype = new st(i);
                            o.constructor = a, a.API = t.API;
                            for (e in s) "function" == typeof t[e] && (o[s[e]] = t[e]);
                            return a.version = t.version, st.activate([a]), a
                        }, l = i._gsQueue) {
                        for (c = 0; c < l.length; c++) l[c]();
                        for (u in _) _[u].func || i.console.log("GSAP encountered missing dependency: " + u)
                    }
                    p = !1
                }
            }(void 0 !== t && t.exports && void 0 !== i ? i : this || window)
    }).call(e, i(3))
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(0),
        r = function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(n),
        s = function(t) {
            this.manager = void 0 !== t ? t : r.DefaultLoadingManager, this.debug = !1, this.group = null, this.position = 0, this.materials = [], this.meshes = [], this.path = ""
        };
    s.prototype = {
        constructor: s,
        load: function(t, e, i, n) {
            var s = this,
                a = new r.FileLoader(this.manager);
            a.setResponseType("arraybuffer"), a.load(t, function(t) {
                e(s.parse(t))
            }, i, n)
        },
        parse: function(t) {
            this.group = new r.Group, this.position = 0, this.materials = [], this.meshes = [], this.readFile(t);
            for (var e = 0; e < this.meshes.length; e++) this.group.add(this.meshes[e]);
            return this.group
        },
        readFile: function(t) {
            var e = new DataView(t),
                i = this.readChunk(e);
            if (i.id === o || i.id === h || i.id === a)
                for (var n = this.nextChunk(e, i); 0 !== n;) {
                    if (n === l) {
                        var r = this.readDWord(e);
                        this.debugMessage("3DS file version: " + r)
                    } else n === m ? (this.resetPosition(e), this.readMeshData(e)) : this.debugMessage("Unknown main chunk: " + n.toString(16));
                    n = this.nextChunk(e, i)
                }
            this.debugMessage("Parsed " + this.meshes.length + " meshes")
        },
        readMeshData: function(t) {
            for (var e = this.readChunk(t), i = this.nextChunk(t, e); 0 !== i;) {
                if (i === v) {
                    var n = +this.readDWord(t);
                    this.debugMessage("Mesh Version: " + n)
                } else if (i === g) {
                    var r = this.readFloat(t);
                    this.debugMessage("Master scale: " + r), this.group.scale.set(r, r, r)
                } else i === N ? (this.debugMessage("Named Object"), this.resetPosition(t), this.readNamedObject(t)) : i === y ? (this.debugMessage("Material"), this.resetPosition(t), this.readMaterialEntry(t)) : this.debugMessage("Unknown MDATA chunk: " + i.toString(16));
                i = this.nextChunk(t, e)
            }
        },
        readNamedObject: function(t) {
            var e = this.readChunk(t),
                i = this.readString(t, 64);
            e.cur = this.position;
            for (var n = this.nextChunk(t, e); 0 !== n;) {
                if (n === k) {
                    this.resetPosition(t);
                    var r = this.readMesh(t);
                    r.name = i, this.meshes.push(r)
                } else this.debugMessage("Unknown named object chunk: " + n.toString(16));
                n = this.nextChunk(t, e)
            }
            this.endChunk(e)
        },
        readMaterialEntry: function(t) {
            for (var e = this.readChunk(t), i = this.nextChunk(t, e), n = new r.MeshPhongMaterial; 0 !== i;) {
                if (i === _) n.name = this.readString(t, 64), this.debugMessage("   Name: " + n.name);
                else if (i === S) this.debugMessage("   Wireframe"), n.wireframe = !0;
                else if (i === A) {
                    var s = this.readByte(t);
                    n.wireframeLinewidth = s, this.debugMessage("   Wireframe Thickness: " + s)
                } else if (i === M) n.side = r.DoubleSide, this.debugMessage("   DoubleSided");
                else if (i === E) this.debugMessage("   Additive Blending"), n.blending = r.AdditiveBlending;
                else if (i === b) this.debugMessage("   Diffuse Color"), n.color = this.readColor(t);
                else if (i === w) this.debugMessage("   Specular Color"), n.specular = this.readColor(t);
                else if (i === x) this.debugMessage("   Ambient color"), n.color = this.readColor(t);
                else if (i === T) {
                    var a = this.readWord(t);
                    n.shininess = a, this.debugMessage("   Shininess : " + a)
                } else i === P ? (this.debugMessage("   ColorMap"), this.resetPosition(t), n.map = this.readMap(t)) : i === C ? (this.debugMessage("   BumpMap"), this.resetPosition(t), n.bumpMap = this.readMap(t)) : i == R ? (this.debugMessage("   OpacityMap"), this.resetPosition(t), n.alphaMap = this.readMap(t)) : i == L ? (this.debugMessage("   SpecularMap"), this.resetPosition(t), n.specularMap = this.readMap(t)) : this.debugMessage("   Unknown material chunk: " + i.toString(16));
                i = this.nextChunk(t, e)
            }
            this.endChunk(e), this.materials[n.name] = n
        },
        readMesh: function(t) {
            var e = this.readChunk(t),
                i = this.nextChunk(t, e),
                n = null,
                s = [];
            n = new r.Geometry;
            var a = new r.MeshPhongMaterial,
                o = new r.Mesh(n, a);
            for (o.name = "mesh"; 0 !== i;) {
                if (i === F) {
                    var h = this.readWord(t);
                    this.debugMessage("   Vertex: " + h);
                    for (var l, l = 0; l < h; l++) n.vertices.push(new r.Vector3(this.readFloat(t), this.readFloat(t), this.readFloat(t)))
                } else if (i === B) this.resetPosition(t), this.readFaceArray(t, o);
                else if (i === H) {
                    var c = this.readWord(t);
                    this.debugMessage("   UV: " + c);
                    var s, l;
                    s = [];
                    for (var l = 0; l < c; l++) s.push(new r.Vector2(this.readFloat(t), this.readFloat(t)))
                } else if (i === j) {
                    this.debugMessage("   Tranformation Matrix (TODO)");
                    for (var u = [], l = 0; l < 12; l++) u[l] = this.readFloat(t);
                    var d = new r.Matrix4;
                    d.elements[0] = u[0], d.elements[1] = u[6], d.elements[2] = u[3], d.elements[3] = u[9], d.elements[4] = u[2], d.elements[5] = u[8], d.elements[6] = u[5], d.elements[7] = u[11], d.elements[8] = u[1], d.elements[9] = u[7], d.elements[10] = u[4], d.elements[11] = u[10], d.elements[12] = 0, d.elements[13] = 0, d.elements[14] = 0, d.elements[15] = 1, d.transpose();
                    var p = new r.Matrix4;
                    p.getInverse(d, !0), n.applyMatrix(p), d.decompose(o.position, o.quaternion, o.scale)
                } else this.debugMessage("   Unknown mesh chunk: " + i.toString(16));
                i = this.nextChunk(t, e)
            }
            if (this.endChunk(e), s.length > 0) {
                for (var f = [], l = 0; l < n.faces.length; l++) f.push([s[n.faces[l].a], s[n.faces[l].b], s[n.faces[l].c]]);
                n.faceVertexUvs[0] = f
            }
            return n.computeVertexNormals(), o
        },
        readFaceArray: function(t, e) {
            var i = this.readChunk(t),
                n = this.readWord(t);
            this.debugMessage("   Faces: " + n);
            for (var s = 0; s < n; ++s) {
                e.geometry.faces.push(new r.Face3(this.readWord(t), this.readWord(t), this.readWord(t)));
                this.readWord(t)
            }
            for (; this.position < i.end;) {
                var i = this.readChunk(t);
                if (i.id === G) {
                    this.debugMessage("      Material Group"), this.resetPosition(t);
                    var a = this.readMaterialGroup(t),
                        o = this.materials[a.name];
                    void 0 !== o && (e.material = o, "" === o.name && (o.name = e.name))
                } else this.debugMessage("      Unknown face array chunk: " + i.toString(16));
                this.endChunk(i)
            }
            this.endChunk(i)
        },
        readMap: function(t) {
            var e = this.readChunk(t),
                i = this.nextChunk(t, e),
                n = {},
                s = new r.TextureLoader;
            for (s.setPath(this.path); 0 !== i;) {
                if (i === O) {
                    var a = this.readString(t, 128);
                    n = s.load(a), this.debugMessage("      File: " + this.path + a)
                } else i === z ? (n.offset.x = this.readFloat(t), this.debugMessage("      OffsetX: " + n.offset.x)) : i === U ? (n.offset.y = this.readFloat(t), this.debugMessage("      OffsetY: " + n.offset.y)) : i === I ? (n.repeat.x = this.readFloat(t), this.debugMessage("      RepeatX: " + n.repeat.x)) : i === D ? (n.repeat.y = this.readFloat(t), this.debugMessage("      RepeatY: " + n.repeat.y)) : this.debugMessage("      Unknown map chunk: " + i.toString(16));
                i = this.nextChunk(t, e)
            }
            return this.endChunk(e), n
        },
        readMaterialGroup: function(t) {
            var e = (this.readChunk(t), this.readString(t, 64)),
                i = this.readWord(t);
            this.debugMessage("         Name: " + e), this.debugMessage("         Faces: " + i);
            for (var n = [], r = 0; r < i; ++r) n.push(this.readWord(t));
            return {
                name: e,
                index: n
            }
        },
        readColor: function(t) {
            var e = this.readChunk(t),
                i = new r.Color;
            if (e.id === d || e.id === p) {
                var n = this.readByte(t),
                    s = this.readByte(t),
                    a = this.readByte(t);
                i.setRGB(n / 255, s / 255, a / 255), this.debugMessage("      Color: " + i.r + ", " + i.g + ", " + i.b)
            } else if (e.id === u || e.id === f) {
                var n = this.readFloat(t),
                    s = this.readFloat(t),
                    a = this.readFloat(t);
                i.setRGB(n, s, a), this.debugMessage("      Color: " + i.r + ", " + i.g + ", " + i.b)
            } else this.debugMessage("      Unknown color chunk: " + c.toString(16));
            return this.endChunk(e), i
        },
        readChunk: function(t) {
            var e = {};
            return e.cur = this.position, e.id = this.readWord(t), e.size = this.readDWord(t), e.end = e.cur + e.size, e.cur += 6, e
        },
        endChunk: function(t) {
            this.position = t.end
        },
        nextChunk: function(t, e) {
            if (e.cur >= e.end) return 0;
            this.position = e.cur;
            try {
                var i = this.readChunk(t);
                return e.cur += i.size, i.id
            } catch (t) {
                return this.debugMessage("Unable to read chunk at " + this.position), 0
            }
        },
        resetPosition: function(t, e) {
            this.position -= 6
        },
        readByte: function(t) {
            var e = t.getUint8(this.position, !0);
            return this.position += 1, e
        },
        readFloat: function(t) {
            try {
                var e = t.getFloat32(this.position, !0);
                return this.position += 4, e
            } catch (e) {
                this.debugMessage(e + " " + this.position + " " + t.byteLength)
            }
        },
        readInt: function(t) {
            var e = t.getInt32(this.position, !0);
            return this.position += 4, e
        },
        readShort: function(t) {
            var e = t.getInt16(this.position, !0);
            return this.position += 2, e
        },
        readDWord: function(t) {
            var e = t.getUint32(this.position, !0);
            return this.position += 4, e
        },
        readWord: function(t) {
            var e = t.getUint16(this.position, !0);
            return this.position += 2, e
        },
        readString: function(t, e) {
            for (var i = "", n = 0; n < e; n++) {
                var r = this.readByte(t);
                if (!r) break;
                i += String.fromCharCode(r)
            }
            return i
        },
        setPath: function(t) {
            return void 0 !== t && (this.path = t), this
        },
        debugMessage: function(t) {
            this.debug && console.log(t)
        }
    };
    var a = 19789,
        o = 15786,
        h = 49725,
        l = 2,
        u = 16,
        d = 17,
        p = 18,
        f = 19,
        m = 15677,
        v = 15678,
        g = 256,
        y = 45055,
        _ = 40960,
        x = 40976,
        b = 40992,
        w = 41008,
        T = 41024,
        M = 41089,
        E = 41091,
        S = 41093,
        A = 41095,
        P = 41472,
        R = 41488,
        C = 41520,
        L = 41476,
        O = 41728,
        I = 41812,
        D = 41814,
        z = 41816,
        U = 41818,
        N = 16384,
        k = 16640,
        F = 16656,
        B = 16672,
        G = 16688,
        H = 16704,
        j = 16736;
    e.default = s
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "varying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}"
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "float rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nuniform vec3 uColorStart;\nuniform vec3 uColorEnd;\nuniform float uAlphaStart;\nuniform float uAlphaEnd;\nuniform float uNoise;\nuniform float uAmplitude;\nuniform float uOffset;\n\nvarying vec2 vUv;\n\nvoid main()\n{\n    // Distance\n    float progress = clamp(distance(vUv, vec2(0.5)) - uOffset, 0.0, 1.0);\n    progress /= uAmplitude;\n    progress = clamp(progress, 0.0, 1.0);\n    progress = clamp(progress, 0.0, 1.0);\n\n    // Noise\n    if(uNoise > 0.0)\n    {\n        progress += (rand(vUv) - 0.5) * uNoise;\n    }\n\n    // color\n    vec3 color = mix(uColorStart, uColorEnd, progress);\n    float alpha = mix(uAlphaStart, uAlphaEnd, progress);\n\n    gl_FragColor = vec4(color, alpha);\n}"
}, function(t, e, i) {
    (function(i) {
        var n, r;
        /*!
         * VERSION: 1.20.3
         * DATE: 2017-10-02
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2017, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         * 
         * @author: Jack Doyle, jack@greensock.com
         */
        ! function(i, s) {
            "use strict";
            var a = {},
                o = i.document,
                h = i.GreenSockGlobals = i.GreenSockGlobals || i;
            if (!h.TweenLite) {
                var l, c, u, d, p, f = function(t) {
                        var e, i = t.split("."),
                            n = h;
                        for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                        return n
                    },
                    m = f("com.greensock"),
                    v = function(t) {
                        var e, i = [],
                            n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]));
                        return i
                    },
                    g = function() {},
                    y = function() {
                        var t = Object.prototype.toString,
                            e = t.call([]);
                        return function(i) {
                            return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                        }
                    }(),
                    _ = {},
                    x = function(i, s, o, l) {
                        this.sc = _[i] ? _[i].sc : [], _[i] = this, this.gsClass = null, this.func = o;
                        var c = [];
                        this.check = function(u) {
                            for (var d, p, m, v, g = s.length, y = g; --g > -1;)(d = _[s[g]] || new x(s[g], [])).gsClass ? (c[g] = d.gsClass, y--) : u && d.sc.push(this);
                            if (0 === y && o) {
                                if (p = ("com.greensock." + i).split("."), m = p.pop(), v = f(p.join("."))[m] = this.gsClass = o.apply(o, c), l)
                                    if (h[m] = a[m] = v, void 0 !== t && t.exports)
                                        if ("TweenLite" === i) {
                                            t.exports = a.TweenLite = v;
                                            for (g in a) v[g] = a[g]
                                        } else a.TweenLite && (a.TweenLite[m] = v);
                                else n = [], void 0 !== (r = function() {
                                    return v
                                }.apply(e, n)) && (t.exports = r);
                                for (g = 0; g < this.sc.length; g++) this.sc[g].check()
                            }
                        }, this.check(!0)
                    },
                    b = i._gsDefine = function(t, e, i, n) {
                        return new x(t, e, i, n)
                    },
                    w = m._class = function(t, e, i) {
                        return e = e || function() {}, b(t, [], function() {
                            return e
                        }, i), e
                    };
                b.globals = h;
                var T = [0, 0, 1, 1],
                    M = w("easing.Ease", function(t, e, i, n) {
                        this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? T.concat(e) : T
                    }, !0),
                    E = M.map = {},
                    S = M.register = function(t, e, i, n) {
                        for (var r, s, a, o, h = e.split(","), l = h.length, c = (i || "easeIn,easeOut,easeInOut").split(","); --l > -1;)
                            for (s = h[l], r = n ? w("easing." + s, null, !0) : m.easing[s] || {}, a = c.length; --a > -1;) o = c[a], E[s + "." + o] = E[o + s] = r[o] = t.getRatio ? t : t[o] || new t
                    };
                for (u = M.prototype, u._calcEnd = !1, u.getRatio = function(t) {
                        if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                        var e = this._type,
                            i = this._power,
                            n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                        return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                    }, l = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], c = l.length; --c > -1;) u = l[c] + ",Power" + c, S(new M(null, null, 1, c), u, "easeOut", !0), S(new M(null, null, 2, c), u, "easeIn" + (0 === c ? ",easeNone" : "")), S(new M(null, null, 3, c), u, "easeInOut");
                E.linear = m.easing.Linear.easeIn, E.swing = m.easing.Quad.easeInOut;
                var A = w("events.EventDispatcher", function(t) {
                    this._listeners = {}, this._eventTarget = t || this
                });
                u = A.prototype, u.addEventListener = function(t, e, i, n, r) {
                    r = r || 0;
                    var s, a, o = this._listeners[t],
                        h = 0;
                    for (this !== d || p || d.wake(), null == o && (this._listeners[t] = o = []), a = o.length; --a > -1;) s = o[a], s.c === e && s.s === i ? o.splice(a, 1) : 0 === h && s.pr < r && (h = a + 1);
                    o.splice(h, 0, {
                        c: e,
                        s: i,
                        up: n,
                        pr: r
                    })
                }, u.removeEventListener = function(t, e) {
                    var i, n = this._listeners[t];
                    if (n)
                        for (i = n.length; --i > -1;)
                            if (n[i].c === e) return void n.splice(i, 1)
                }, u.dispatchEvent = function(t) {
                    var e, i, n, r = this._listeners[t];
                    if (r)
                        for (e = r.length, e > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                            type: t,
                            target: i
                        }) : n.c.call(n.s || i))
                };
                var P = i.requestAnimationFrame,
                    R = i.cancelAnimationFrame,
                    C = Date.now || function() {
                        return (new Date).getTime()
                    },
                    L = C();
                for (l = ["ms", "moz", "webkit", "o"], c = l.length; --c > -1 && !P;) P = i[l[c] + "RequestAnimationFrame"], R = i[l[c] + "CancelAnimationFrame"] || i[l[c] + "CancelRequestAnimationFrame"];
                w("Ticker", function(t, e) {
                    var i, n, r, s, a, h = this,
                        l = C(),
                        c = !(!1 === e || !P) && "auto",
                        u = 500,
                        f = 33,
                        m = function(t) {
                            var e, o, c = C() - L;
                            c > u && (l += c - f), L += c, h.time = (L - l) / 1e3, e = h.time - a, (!i || e > 0 || !0 === t) && (h.frame++, a += e + (e >= s ? .004 : s - e), o = !0), !0 !== t && (r = n(m)), o && h.dispatchEvent("tick")
                        };
                    A.call(h), h.time = h.frame = 0, h.tick = function() {
                        m(!0)
                    }, h.lagSmoothing = function(t, e) {
                        if (!arguments.length) return u < 1e10;
                        u = t || 1e10, f = Math.min(e, u, 0)
                    }, h.sleep = function() {
                        null != r && (c && R ? R(r) : clearTimeout(r), n = g, r = null, h === d && (p = !1))
                    }, h.wake = function(t) {
                        null !== r ? h.sleep() : t ? l += -L + (L = C()) : h.frame > 10 && (L = C() - u + 5), n = 0 === i ? g : c && P ? P : function(t) {
                            return setTimeout(t, 1e3 * (a - h.time) + 1 | 0)
                        }, h === d && (p = !0), m(2)
                    }, h.fps = function(t) {
                        if (!arguments.length) return i;
                        i = t, s = 1 / (i || 60), a = this.time + s, h.wake()
                    }, h.useRAF = function(t) {
                        if (!arguments.length) return c;
                        h.sleep(), c = t, h.fps(i)
                    }, h.fps(t), setTimeout(function() {
                        "auto" === c && h.frame < 5 && "hidden" !== o.visibilityState && h.useRAF(!1)
                    }, 1500)
                }), u = m.Ticker.prototype = new m.events.EventDispatcher, u.constructor = m.Ticker;
                var O = w("core.Animation", function(t, e) {
                    if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, J) {
                        p || d.wake();
                        var i = this.vars.useFrames ? Q : J;
                        i.add(this, i._time), this.vars.paused && this.paused(!0)
                    }
                });
                d = O.ticker = new m.Ticker, u = O.prototype, u._dirty = u._gc = u._initted = u._paused = !1, u._totalTime = u._time = 0, u._rawPrevTime = -1, u._next = u._last = u._onUpdate = u._timeline = u.timeline = null, u._paused = !1;
                var I = function() {
                    p && C() - L > 2e3 && ("hidden" !== o.visibilityState || !d.lagSmoothing()) && d.wake();
                    var t = setTimeout(I, 2e3);
                    t.unref && t.unref()
                };
                I(), u.play = function(t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, u.pause = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, u.resume = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!1)
                }, u.seek = function(t, e) {
                    return this.totalTime(Number(t), !1 !== e)
                }, u.restart = function(t, e) {
                    return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
                }, u.reverse = function(t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, u.render = function(t, e, i) {}, u.invalidate = function() {
                    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                }, u.isActive = function() {
                    var t, e = this._timeline,
                        i = this._startTime;
                    return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
                }, u._enabled = function(t, e) {
                    return p || d.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                }, u._kill = function(t, e) {
                    return this._enabled(!1, !1)
                }, u.kill = function(t, e) {
                    return this._kill(t, e), this
                }, u._uncache = function(t) {
                    for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                    return this
                }, u._swapSelfInParams = function(t) {
                    for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                    return i
                }, u._callback = function(t) {
                    var e = this.vars,
                        i = e[t],
                        n = e[t + "Params"],
                        r = e[t + "Scope"] || e.callbackScope || this;
                    switch (n ? n.length : 0) {
                        case 0:
                            i.call(r);
                            break;
                        case 1:
                            i.call(r, n[0]);
                            break;
                        case 2:
                            i.call(r, n[0], n[1]);
                            break;
                        default:
                            i.apply(r, n)
                    }
                }, u.eventCallback = function(t, e, i, n) {
                    if ("on" === (t || "").substr(0, 2)) {
                        var r = this.vars;
                        if (1 === arguments.length) return r[t];
                        null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = y(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                    }
                    return this
                }, u.delay = function(t) {
                    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                }, u.duration = function(t) {
                    return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                }, u.totalDuration = function(t) {
                    return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                }, u.time = function(t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                }, u.totalTime = function(t, e, i) {
                    if (p || d.wake(), !arguments.length) return this._totalTime;
                    if (this._timeline) {
                        if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                            this._dirty && this.totalDuration();
                            var n = this._totalDuration,
                                r = this._timeline;
                            if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                        }
                        this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (k.length && tt(), this.render(t, e, !1), k.length && tt())
                    }
                    return this
                }, u.progress = u.totalProgress = function(t, e) {
                    var i = this.duration();
                    return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
                }, u.startTime = function(t) {
                    return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                }, u.endTime = function(t) {
                    return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                }, u.timeScale = function(t) {
                    if (!arguments.length) return this._timeScale;
                    var e, i;
                    for (t = t || 1e-10, this._timeline && this._timeline.smoothChildTiming && (e = this._pauseTime, i = e || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
                    return this
                }, u.reversed = function(t) {
                    return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                }, u.paused = function(t) {
                    if (!arguments.length) return this._paused;
                    var e, i, n = this._timeline;
                    return t != this._paused && n && (p || t || d.wake(), e = n.rawTime(), i = e - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                };
                var D = w("core.SimpleTimeline", function(t) {
                    O.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                });
                u = D.prototype = new O, u.constructor = D, u.kill()._gc = !1, u._first = u._last = u._recent = null, u._sortChildren = !1, u.add = u.insert = function(t, e, i, n) {
                    var r, s;
                    if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                        for (s = t._startTime; r && r._startTime > s;) r = r._prev;
                    return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
                }, u._remove = function(t, e) {
                    return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                }, u.render = function(t, e, i) {
                    var n, r = this._first;
                    for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
                }, u.rawTime = function() {
                    return p || d.wake(), this._totalTime
                };
                var z = w("TweenLite", function(t, e, n) {
                        if (O.call(this, e, n), this.render = z.prototype.render, null == t) throw "Cannot tween a null target.";
                        this.target = t = "string" != typeof t ? t : z.selector(t) || t;
                        var r, s, a, o = t.jquery || t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType),
                            h = this.vars.overwrite;
                        if (this._overwrite = h = null == h ? $[z.defaultOverwrite] : "number" == typeof h ? h >> 0 : $[h], (o || t instanceof Array || t.push && y(t)) && "number" != typeof t[0])
                            for (this._targets = a = v(t), this._propLookup = [], this._siblings = [], r = 0; r < a.length; r++) s = a[r], s ? "string" != typeof s ? s.length && s !== i && s[0] && (s[0] === i || s[0].nodeType && s[0].style && !s.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(v(s))) : (this._siblings[r] = et(s, this, !1), 1 === h && this._siblings[r].length > 1 && nt(s, this, null, 1, this._siblings[r])) : "string" == typeof(s = a[r--] = z.selector(s)) && a.splice(r + 1, 1) : a.splice(r--, 1);
                        else this._propLookup = {}, this._siblings = et(t, this, !1), 1 === h && this._siblings.length > 1 && nt(t, this, null, 1, this._siblings);
                        (this.vars.immediateRender || 0 === e && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay)))
                    }, !0),
                    U = function(t) {
                        return t && t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType)
                    },
                    N = function(t, e) {
                        var i, n = {};
                        for (i in t) Z[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!X[i] || X[i] && X[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                        t.css = n
                    };
                u = z.prototype = new O, u.constructor = z, u.kill()._gc = !1, u.ratio = 0, u._firstPT = u._targets = u._overwrittenProps = u._startAt = null, u._notifyPluginsOfEnabled = u._lazy = !1, z.version = "1.20.3", z.defaultEase = u._ease = new M(null, null, 1, 1), z.defaultOverwrite = "auto", z.ticker = d, z.autoSleep = 120, z.lagSmoothing = function(t, e) {
                    d.lagSmoothing(t, e)
                }, z.selector = i.$ || i.jQuery || function(t) {
                    var e = i.$ || i.jQuery;
                    return e ? (z.selector = e, e(t)) : void 0 === o ? t : o.querySelectorAll ? o.querySelectorAll(t) : o.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
                };
                var k = [],
                    F = {},
                    B = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    G = /[\+-]=-?[\.\d]/,
                    H = function(t) {
                        for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m(e, this._target || i.t) : e < 1e-6 && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                    },
                    j = function(t, e, i, n) {
                        var r, s, a, o, h, l, c, u = [],
                            d = 0,
                            p = "",
                            f = 0;
                        for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(B) || [], s = e.match(B) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), h = s.length, o = 0; o < h; o++) c = s[o], l = e.substr(d, e.indexOf(c, d) - d), p += l || !o ? l : ",", d += l.length, f ? f = (f + 1) % 5 : "rgba(" === l.substr(-5) && (f = 1), c === r[o] || r.length <= o ? p += c : (p && (u.push(p), p = ""), a = parseFloat(r[o]), u.push(a), u._firstPT = {
                            _next: u._firstPT,
                            t: u,
                            p: u.length - 1,
                            s: a,
                            c: ("=" === c.charAt(1) ? parseInt(c.charAt(0) + "1", 10) * parseFloat(c.substr(2)) : parseFloat(c) - a) || 0,
                            f: 0,
                            m: f && f < 4 ? Math.round : 0
                        }), d += c.length;
                        return p += e.substr(d), p && u.push(p), u.setRatio = H, G.test(e) && (u.end = null), u
                    },
                    V = function(t, e, i, n, r, s, a, o, h) {
                        "function" == typeof n && (n = n(h || 0, t));
                        var l, c = typeof t[e],
                            u = "function" !== c ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                            d = "get" !== i ? i : u ? a ? t[u](a) : t[u]() : t[e],
                            p = "string" == typeof n && "=" === n.charAt(1),
                            f = {
                                t: t,
                                p: e,
                                s: d,
                                f: "function" === c,
                                pg: 0,
                                n: r || e,
                                m: s ? "function" == typeof s ? s : Math.round : 0,
                                pr: 0,
                                c: p ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - d || 0
                            };
                        if (("number" != typeof d || "number" != typeof n && !p) && (a || isNaN(d) || !p && isNaN(n) || "boolean" == typeof d || "boolean" == typeof n ? (f.fp = a, l = j(d, p ? parseFloat(f.s) + f.c : n, o || z.defaultStringFilter, f), f = {
                                t: l,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 2,
                                pg: 0,
                                n: r || e,
                                pr: 0,
                                m: 0
                            }) : (f.s = parseFloat(d), p || (f.c = parseFloat(n) - f.s || 0))), f.c) return (f._next = this._firstPT) && (f._next._prev = f), this._firstPT = f, f
                    },
                    W = z._internals = {
                        isArray: y,
                        isSelector: U,
                        lazyTweens: k,
                        blobDif: j
                    },
                    X = z._plugins = {},
                    q = W.tweenLookup = {},
                    Y = 0,
                    Z = W.reservedProps = {
                        ease: 1,
                        delay: 1,
                        overwrite: 1,
                        onComplete: 1,
                        onCompleteParams: 1,
                        onCompleteScope: 1,
                        useFrames: 1,
                        runBackwards: 1,
                        startAt: 1,
                        onUpdate: 1,
                        onUpdateParams: 1,
                        onUpdateScope: 1,
                        onStart: 1,
                        onStartParams: 1,
                        onStartScope: 1,
                        onReverseComplete: 1,
                        onReverseCompleteParams: 1,
                        onReverseCompleteScope: 1,
                        onRepeat: 1,
                        onRepeatParams: 1,
                        onRepeatScope: 1,
                        easeParams: 1,
                        yoyo: 1,
                        immediateRender: 1,
                        repeat: 1,
                        repeatDelay: 1,
                        data: 1,
                        paused: 1,
                        reversed: 1,
                        autoCSS: 1,
                        lazy: 1,
                        onOverwrite: 1,
                        callbackScope: 1,
                        stringFilter: 1,
                        id: 1,
                        yoyoEase: 1
                    },
                    $ = {
                        none: 0,
                        all: 1,
                        auto: 2,
                        concurrent: 3,
                        allOnStart: 4,
                        preexisting: 5,
                        true: 1,
                        false: 0
                    },
                    Q = O._rootFramesTimeline = new D,
                    J = O._rootTimeline = new D,
                    K = 30,
                    tt = W.lazyRender = function() {
                        var t, e = k.length;
                        for (F = {}; --e > -1;)(t = k[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                        k.length = 0
                    };
                J._startTime = d.time, Q._startTime = d.frame, J._active = Q._active = !0, setTimeout(tt, 1), O._updateRoot = z.render = function() {
                    var t, e, i;
                    if (k.length && tt(), J.render((d.time - J._startTime) * J._timeScale, !1, !1), Q.render((d.frame - Q._startTime) * Q._timeScale, !1, !1), k.length && tt(), d.frame >= K) {
                        K = d.frame + (parseInt(z.autoSleep, 10) || 120);
                        for (i in q) {
                            for (e = q[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);
                            0 === e.length && delete q[i]
                        }
                        if ((!(i = J._first) || i._paused) && z.autoSleep && !Q._first && 1 === d._listeners.tick.length) {
                            for (; i && i._paused;) i = i._next;
                            i || d.sleep()
                        }
                    }
                }, d.addEventListener("tick", O._updateRoot);
                var et = function(t, e, i) {
                        var n, r, s = t._gsTweenID;
                        if (q[s || (t._gsTweenID = s = "t" + Y++)] || (q[s] = {
                                target: t,
                                tweens: []
                            }), e && (n = q[s].tweens, n[r = n.length] = e, i))
                            for (; --r > -1;) n[r] === e && n.splice(r, 1);
                        return q[s].tweens
                    },
                    it = function(t, e, i, n) {
                        var r, s, a = t.vars.onOverwrite;
                        return a && (r = a(t, e, i, n)), a = z.onOverwrite, a && (s = a(t, e, i, n)), !1 !== r && !1 !== s
                    },
                    nt = function(t, e, i, n, r) {
                        var s, a, o, h;
                        if (1 === n || n >= 4) {
                            for (h = r.length, s = 0; s < h; s++)
                                if ((o = r[s]) !== e) o._gc || o._kill(null, t, e) && (a = !0);
                                else if (5 === n) break;
                            return a
                        }
                        var l, c = e._startTime + 1e-10,
                            u = [],
                            d = 0,
                            p = 0 === e._duration;
                        for (s = r.length; --s > -1;)(o = r[s]) === e || o._gc || o._paused || (o._timeline !== e._timeline ? (l = l || rt(e, 0, p), 0 === rt(o, l, p) && (u[d++] = o)) : o._startTime <= c && o._startTime + o.totalDuration() / o._timeScale > c && ((p || !o._initted) && c - o._startTime <= 2e-10 || (u[d++] = o)));
                        for (s = d; --s > -1;)
                            if (o = u[s], 2 === n && o._kill(i, t, e) && (a = !0), 2 !== n || !o._firstPT && o._initted) {
                                if (2 !== n && !it(o, e)) continue;
                                o._enabled(!1, !1) && (a = !0)
                            }
                        return a
                    },
                    rt = function(t, e, i) {
                        for (var n = t._timeline, r = n._timeScale, s = t._startTime; n._timeline;) {
                            if (s += n._startTime, r *= n._timeScale, n._paused) return -100;
                            n = n._timeline
                        }
                        return s /= r, s > e ? s - e : i && s === e || !t._initted && s - e < 2e-10 ? 1e-10 : (s += t.totalDuration() / t._timeScale / r) > e + 1e-10 ? 0 : s - e - 1e-10
                    };
                u._init = function() {
                    var t, e, i, n, r, s, a = this.vars,
                        o = this._overwrittenProps,
                        h = this._duration,
                        l = !!a.immediateRender,
                        c = a.ease;
                    if (a.startAt) {
                        this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {};
                        for (n in a.startAt) r[n] = a.startAt[n];
                        if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = l && !1 !== a.lazy, r.startAt = r.delay = null, r.onUpdate = a.onUpdate, r.onUpdateParams = a.onUpdateParams, r.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = z.to(this.target, 0, r), l)
                            if (this._time > 0) this._startAt = null;
                            else if (0 !== h) return
                    } else if (a.runBackwards && 0 !== h)
                        if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                        else {
                            0 !== this._time && (l = !1), i = {};
                            for (n in a) Z[n] && "autoCSS" !== n || (i[n] = a[n]);
                            if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && !1 !== a.lazy, i.immediateRender = l, this._startAt = z.to(this.target, 0, i), l) {
                                if (0 === this._time) return
                            } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                        }
                    if (this._ease = c = c ? c instanceof M ? c : "function" == typeof c ? new M(c, a.easeParams) : E[c] || z.defaultEase : z.defaultEase, a.easeParams instanceof Array && c.config && (this._ease = c.config.apply(c, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                        for (s = this._targets.length, t = 0; t < s; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], o ? o[t] : null, t) && (e = !0);
                    else e = this._initProps(this.target, this._propLookup, this._siblings, o, 0);
                    if (e && z._onPluginEvent("_onInitAllProps", this), o && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                        for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                    this._onUpdate = a.onUpdate, this._initted = !0
                }, u._initProps = function(t, e, n, r, s) {
                    var a, o, h, l, c, u;
                    if (null == t) return !1;
                    F[t._gsTweenID] && tt(), this.vars.css || t.style && t !== i && t.nodeType && X.css && !1 !== this.vars.autoCSS && N(this.vars, t);
                    for (a in this.vars)
                        if (u = this.vars[a], Z[a]) u && (u instanceof Array || u.push && y(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[a] = u = this._swapSelfInParams(u, this));
                        else if (X[a] && (l = new X[a])._onInitTween(t, this.vars[a], this, s)) {
                        for (this._firstPT = c = {
                                _next: this._firstPT,
                                t: l,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 1,
                                n: a,
                                pg: 1,
                                pr: l._priority,
                                m: 0
                            }, o = l._overwriteProps.length; --o > -1;) e[l._overwriteProps[o]] = this._firstPT;
                        (l._priority || l._onInitAllProps) && (h = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), c._next && (c._next._prev = c)
                    } else e[a] = V.call(this, t, a, "get", u, a, 0, null, this.vars.stringFilter, s);
                    return r && this._kill(r, t) ? this._initProps(t, e, n, r, s) : this._overwrite > 1 && this._firstPT && n.length > 1 && nt(t, this, e, this._overwrite, n) ? (this._kill(e, t), this._initProps(t, e, n, r, s)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (F[t._gsTweenID] = !0), h)
                }, u.render = function(t, e, i) {
                    var n, r, s, a, o = this._time,
                        h = this._duration,
                        l = this._rawPrevTime;
                    if (t >= h - 1e-7 && t >= 0) this._totalTime = this._time = h, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === h && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (l < 0 || t <= 0 && t >= -1e-7 || 1e-10 === l && "isPause" !== this.data) && l !== t && (i = !0, l > 1e-10 && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || l === t ? t : 1e-10);
                    else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== o || 0 === h && l > 0) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === h && (this._initted || !this.vars.lazy || i) && (l >= 0 && (1e-10 !== l || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || l === t ? t : 1e-10)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
                    else if (this._totalTime = this._time = t, this._easeType) {
                        var c = t / h,
                            u = this._easeType,
                            d = this._easePower;
                        (1 === u || 3 === u && c >= .5) && (c = 1 - c), 3 === u && (c *= 2), 1 === d ? c *= c : 2 === d ? c *= c * c : 3 === d ? c *= c * c * c : 4 === d && (c *= c * c * c * c), this.ratio = 1 === u ? 1 - c : 2 === u ? c : t / h < .5 ? c / 2 : 1 - c / 2
                    } else this.ratio = this._ease.getRatio(t / h);
                    if (this._time !== o || i) {
                        if (!this._initted) {
                            if (this._init(), !this._initted || this._gc) return;
                            if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = o, this._rawPrevTime = l, k.push(this), void(this._lazy = [t, e]);
                            this._time && !n ? this.ratio = this._ease.getRatio(this._time / h) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                        }
                        for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== o && t >= 0 && (this._active = !0), 0 === o && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== h || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                        this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== o || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === h && 1e-10 === this._rawPrevTime && 1e-10 !== a && (this._rawPrevTime = 0)))
                    }
                }, u._kill = function(t, e, i) {
                    if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                    e = "string" != typeof e ? e || this._targets || this.target : z.selector(e) || e;
                    var n, r, s, a, o, h, l, c, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                    if ((y(e) || U(e)) && "number" != typeof e[0])
                        for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (h = !0);
                    else {
                        if (this._targets) {
                            for (n = this._targets.length; --n > -1;)
                                if (e === this._targets[n]) {
                                    o = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                    break
                                }
                        } else {
                            if (e !== this.target) return !1;
                            o = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                        }
                        if (o) {
                            if (l = t || o, c = t !== r && "all" !== r && t !== o && ("object" != typeof t || !t._tempKill), i && (z.onOverwrite || this.vars.onOverwrite)) {
                                for (s in l) o[s] && (u || (u = []), u.push(s));
                                if ((u || !t) && !it(this, i, e, u)) return !1
                            }
                            for (s in l)(a = o[s]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, h = !0), a.pg && a.t._kill(l) && (h = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete o[s]), c && (r[s] = 1);
                            !this._firstPT && this._initted && this._enabled(!1, !1)
                        }
                    }
                    return h
                }, u.invalidate = function() {
                    return this._notifyPluginsOfEnabled && z._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], O.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this
                }, u._enabled = function(t, e) {
                    if (p || d.wake(), t && this._gc) {
                        var i, n = this._targets;
                        if (n)
                            for (i = n.length; --i > -1;) this._siblings[i] = et(n[i], this, !0);
                        else this._siblings = et(this.target, this, !0)
                    }
                    return O.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && z._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                }, z.to = function(t, e, i) {
                    return new z(t, e, i)
                }, z.from = function(t, e, i) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new z(t, e, i)
                }, z.fromTo = function(t, e, i, n) {
                    return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new z(t, e, n)
                }, z.delayedCall = function(t, e, i, n, r) {
                    return new z(e, 0, {
                        delay: t,
                        onComplete: e,
                        onCompleteParams: i,
                        callbackScope: n,
                        onReverseComplete: e,
                        onReverseCompleteParams: i,
                        immediateRender: !1,
                        lazy: !1,
                        useFrames: r,
                        overwrite: 0
                    })
                }, z.set = function(t, e) {
                    return new z(t, 0, e)
                }, z.getTweensOf = function(t, e) {
                    if (null == t) return [];
                    t = "string" != typeof t ? t : z.selector(t) || t;
                    var i, n, r, s;
                    if ((y(t) || U(t)) && "number" != typeof t[0]) {
                        for (i = t.length, n = []; --i > -1;) n = n.concat(z.getTweensOf(t[i], e));
                        for (i = n.length; --i > -1;)
                            for (s = n[i], r = i; --r > -1;) s === n[r] && n.splice(i, 1)
                    } else if (t._gsTweenID)
                        for (n = et(t).concat(), i = n.length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                    return n || []
                }, z.killTweensOf = z.killDelayedCallsTo = function(t, e, i) {
                    "object" == typeof e && (i = e, e = !1);
                    for (var n = z.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
                };
                var st = w("plugins.TweenPlugin", function(t, e) {
                    this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = st.prototype
                }, !0);
                if (u = st.prototype, st.version = "1.19.0", st.API = 2, u._firstPT = null, u._addTween = V, u.setRatio = H, u._kill = function(t) {
                        var e, i = this._overwriteProps,
                            n = this._firstPT;
                        if (null != t[this._propName]) this._overwriteProps = [];
                        else
                            for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                        for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                        return !1
                    }, u._mod = u._roundProps = function(t) {
                        for (var e, i = this._firstPT; i;) e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")], e && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
                    }, z._onPluginEvent = function(t, e) {
                        var i, n, r, s, a, o = e._firstPT;
                        if ("_onInitAllProps" === t) {
                            for (; o;) {
                                for (a = o._next, n = r; n && n.pr > o.pr;) n = n._next;
                                (o._prev = n ? n._prev : s) ? o._prev._next = o: r = o, (o._next = n) ? n._prev = o : s = o, o = a
                            }
                            o = e._firstPT = r
                        }
                        for (; o;) o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next;
                        return i
                    }, st.activate = function(t) {
                        for (var e = t.length; --e > -1;) t[e].API === st.API && (X[(new t[e])._propName] = t[e]);
                        return !0
                    }, b.plugin = function(t) {
                        if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                        var e, i = t.propName,
                            n = t.priority || 0,
                            r = t.overwriteProps,
                            s = {
                                init: "_onInitTween",
                                set: "setRatio",
                                kill: "_kill",
                                round: "_mod",
                                mod: "_mod",
                                initAll: "_onInitAllProps"
                            },
                            a = w("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                                st.call(this, i, n), this._overwriteProps = r || []
                            }, !0 === t.global),
                            o = a.prototype = new st(i);
                        o.constructor = a, a.API = t.API;
                        for (e in s) "function" == typeof t[e] && (o[s[e]] = t[e]);
                        return a.version = t.version, st.activate([a]), a
                    }, l = i._gsQueue) {
                    for (c = 0; c < l.length; c++) l[c]();
                    for (u in _) _[u].func || i.console.log("GSAP encountered missing dependency: " + u)
                }
                p = !1
            }
        }(void 0 !== t && t.exports && void 0 !== i ? i : this || window)
    }).call(e, i(3))
}, function(t, e, i) {
    "use strict";
    i(12);
    var n = i(13),
        r = function(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(n);
    new r.default
}, function(t, e) {}, function(t, e, i) {
    "use strict";

    function n(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }

    function r(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        a = i(1),
        o = n(a),
        h = i(19),
        l = n(h),
        c = i(20),
        u = n(c),
        d = i(46),
        p = n(d),
        f = i(47),
        m = n(f),
        v = function() {
            function t() {
                r(this, t), 0 === window.location.hostname.indexOf("localhost") || 0 === window.location.hostname.indexOf("192.168") ? this.environment = "development" : 0 === window.location.hostname.indexOf("stage.loaded.gg") ? this.environment = "preprod" : this.environment = "production", this.popin = new l.default, this.isTouch = this.testTouch(), document.documentElement.classList.add(this.isTouch ? "touch" : "no-touch"), this.setSizes(), this.setDataBinding(), this.setExperience(), this.setCaseStudies(), this.setLazyLoad(), this.setParallax(), this.setNewsletter(), this.setNavigation()
            }
            return s(t, [{
                key: "setSizes",
                value: function() {
                    var t = this;
                    this.sizes = {}, this.sizes.$sizer = document.querySelector(".sizer"), this.sizes.$width = this.sizes.$sizer.querySelector(".width"), this.sizes.$height = this.sizes.$sizer.querySelector(".height"), this.sizes.width = this.sizes.$width.offsetWidth, this.sizes.height = this.sizes.$height.offsetHeight, this.sizes.update = function() {
                        t.sizes.width = t.sizes.$width.offsetWidth, t.sizes.height = t.sizes.$height.offsetHeight
                    }, window.addEventListener("resize", this.sizes.update)
                }
            }, {
                key: "setDataBinding",
                value: function() {
                    this.DataBinding = new p.default
                }
            }, {
                key: "testTouch",
                value: function() {
                    return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch)
                }
            }, {
                key: "setExperience",
                value: function() {
                    this.experience = new u.default({
                        canvas: document.querySelector(".experience")
                    })
                }
            }, {
                key: "setCaseStudies",
                value: function() {
                    var t = this,
                        e = (Array.from(document.querySelectorAll(".js-illustration")), Array.from(document.querySelectorAll(".js-scaler"))),
                        i = function() {
                            var i = t.sizes.height / 1100,
                                n = t.sizes.width / 1800,
                                r = Math.min(i, n);
                            r > 1 && (r = 1), r *= .85;
                            var s = !0,
                                a = !1,
                                o = void 0;
                            try {
                                for (var h, l = e[Symbol.iterator](); !(s = (h = l.next()).done); s = !0) {
                                    h.value.style.transform = "scale(" + r + ", " + r + ")"
                                }
                            } catch (t) {
                                a = !0, o = t
                            } finally {
                                try {
                                    !s && l.return && l.return()
                                } finally {
                                    if (a) throw o
                                }
                            }
                        };
                    window.addEventListener("resize", i), i()
                }
            }, {
                key: "setLazyLoad",
                value: function() {
                    var t = this;
                    this.$pictures = document.body.querySelectorAll(".lazy-load:not(.lazy-load-set)");
                    for (var e = 0, i = this.$pictures.length; e < i; e++) ! function(e, i) {
                        var n = t.$pictures[e],
                            r = n.querySelector(".lazy-load-image"),
                            s = n.querySelector(".lazy-load-source"),
                            a = new Image;
                        n.classList.add("lazy-load-set"), a.addEventListener("load", function() {
                            r.style.backgroundImage = "url(" + a.src + ")", n.classList.add("loaded")
                        }), a.src = s.src
                    }(e)
                }
            }, {
                key: "setParallax",
                value: function() {
                    var t = this,
                        e = Array.from(document.querySelectorAll(".js-parallax")),
                        i = this.sizes.width,
                        n = this.sizes.height,
                        r = window.scrollY,
                        s = function() {
                            var t = !0,
                                i = !1,
                                s = void 0;
                            try {
                                for (var a, o = e[Symbol.iterator](); !(t = (a = o.next()).done); t = !0) {
                                    var h = a.value,
                                        l = r + .5 * n - h.center,
                                        c = l / n * 60,
                                        u = Math.round(100 * c) / 100;
                                    h.center - .5 * h.height + u < r + n && h.center + .5 * h.height + u > r ? (h.style.transform = "translateY(" + u + "px) translateZ(0)", h.isIllustration && h.classList.add("visible")) : h.isIllustration && h.classList.remove("visible")
                                }
                            } catch (t) {
                                i = !0, s = t
                            } finally {
                                try {
                                    !t && o.return && o.return()
                                } finally {
                                    if (i) throw s
                                }
                            }
                        },
                        a = function() {
                            r = window.scrollY, s()
                        };
                    window.addEventListener("scroll", a);
                    var o = function() {
                        i = t.sizes.width, n = t.sizes.height;
                        var a = !0,
                            o = !1,
                            h = void 0;
                        try {
                            for (var l, c = e[Symbol.iterator](); !(a = (l = c.next()).done); a = !0) {
                                var u = l.value,
                                    d = u.style.transform;
                                u.style.transform = "";
                                var p = u.getBoundingClientRect();
                                u.height = p.height, u.center = r + p.top + .5 * p.height, u.isIllustration = u.classList.contains("illustration"), u.style.transform = d
                            }
                        } catch (t) {
                            o = !0, h = t
                        } finally {
                            try {
                                !a && c.return && c.return()
                            } finally {
                                if (o) throw h
                            }
                        }
                        s()
                    };
                    window.addEventListener("resize", o), o()
                }
            }, {
                key: "setNewsletter",
                value: function() {
                    var t = this,
                        e = document.querySelector(".js-newsletter-form"),
                        i = e.querySelector(".js-input"),
                        n = e.querySelector(".js-alert"),
                        r = (e.querySelector(".js-button"), /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/),
                        s = !1;
                    i.addEventListener("keyup", function(t) {
                        var e = r.test(i.value);
                        s && (e ? n.classList.remove("active") : n.classList.add("active"))
                    }), e.addEventListener("submit", function(a) {
                        if (a.preventDefault(), e.classList.contains("loading")) return !1;
                        if (e.classList.add("loading"), s = !0, r.test(i.value)) {
                            n.classList.remove("active");
                            var h = "development" === t.environment ? "http://loaded.dev" : "";
                            o.default.get(h + "/static/php/mailchimp-subscribe.php?email=" + i.value).end(function(t, i) {
                                console.log(t), console.log(i), e.classList.add("success")
                            })
                        } else e.classList.remove("loading"), n.classList.add("active")
                    })
                }
            }, {
                key: "setNavigation",
                value: function() {
                    this.navigation = new m.default({
                        popin: this.popin
                    })
                }
            }]), t
        }();
    e.default = v
}, function(t, e, i) {
    function n(t) {
        if (t) return r(t)
    }

    function r(t) {
        for (var e in n.prototype) t[e] = n.prototype[e];
        return t
    }
    t.exports = n, n.prototype.on = n.prototype.addEventListener = function(t, e) {
        return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this
    }, n.prototype.once = function(t, e) {
        function i() {
            this.off(t, i), e.apply(this, arguments)
        }
        return i.fn = e, this.on(t, i), this
    }, n.prototype.off = n.prototype.removeListener = n.prototype.removeAllListeners = n.prototype.removeEventListener = function(t, e) {
        if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
        var i = this._callbacks["$" + t];
        if (!i) return this;
        if (1 == arguments.length) return delete this._callbacks["$" + t], this;
        for (var n, r = 0; r < i.length; r++)
            if ((n = i[r]) === e || n.fn === e) {
                i.splice(r, 1);
                break
            }
        return this
    }, n.prototype.emit = function(t) {
        this._callbacks = this._callbacks || {};
        var e = [].slice.call(arguments, 1),
            i = this._callbacks["$" + t];
        if (i) {
            i = i.slice(0);
            for (var n = 0, r = i.length; n < r; ++n) i[n].apply(this, e)
        }
        return this
    }, n.prototype.listeners = function(t) {
        return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || []
    }, n.prototype.hasListeners = function(t) {
        return !!this.listeners(t).length
    }
}, function(t, e, i) {
    "use strict";

    function n(t) {
        if (t) return r(t)
    }

    function r(t) {
        for (var e in n.prototype) t[e] = n.prototype[e];
        return t
    }
    var s = i(4);
    t.exports = n, n.prototype.clearTimeout = function() {
        return clearTimeout(this._timer), clearTimeout(this._responseTimeoutTimer), delete this._timer, delete this._responseTimeoutTimer, this
    }, n.prototype.parse = function(t) {
        return this._parser = t, this
    }, n.prototype.responseType = function(t) {
        return this._responseType = t, this
    }, n.prototype.serialize = function(t) {
        return this._serializer = t, this
    }, n.prototype.timeout = function(t) {
        if (!t || "object" != typeof t) return this._timeout = t, this._responseTimeout = 0, this;
        for (var e in t) switch (e) {
            case "deadline":
                this._timeout = t.deadline;
                break;
            case "response":
                this._responseTimeout = t.response;
                break;
            default:
                console.warn("Unknown timeout option", e)
        }
        return this
    }, n.prototype.retry = function(t, e) {
        return 0 !== arguments.length && !0 !== t || (t = 1), t <= 0 && (t = 0), this._maxRetries = t, this._retries = 0, this._retryCallback = e, this
    };
    var a = ["ECONNRESET", "ETIMEDOUT", "EADDRINFO", "ESOCKETTIMEDOUT"];
    n.prototype._shouldRetry = function(t, e) {
        if (!this._maxRetries || this._retries++ >= this._maxRetries) return !1;
        if (this._retryCallback) try {
            var i = this._retryCallback(t, e);
            if (!0 === i) return !0;
            if (!1 === i) return !1
        } catch (t) {
            console.error(t)
        }
        if (e && e.status && e.status >= 500 && 501 != e.status) return !0;
        if (t) {
            if (t.code && ~a.indexOf(t.code)) return !0;
            if (t.timeout && "ECONNABORTED" == t.code) return !0;
            if (t.crossDomain) return !0
        }
        return !1
    }, n.prototype._retry = function() {
        return this.clearTimeout(), this.req && (this.req = null, this.req = this.request()), this._aborted = !1, this.timedout = !1, this._end()
    }, n.prototype.then = function(t, e) {
        if (!this._fullfilledPromise) {
            var i = this;
            this._endCalled && console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"), this._fullfilledPromise = new Promise(function(t, e) {
                i.end(function(i, n) {
                    i ? e(i) : t(n)
                })
            })
        }
        return this._fullfilledPromise.then(t, e)
    }, n.prototype.catch = function(t) {
        return this.then(void 0, t)
    }, n.prototype.use = function(t) {
        return t(this), this
    }, n.prototype.ok = function(t) {
        if ("function" != typeof t) throw Error("Callback required");
        return this._okCallback = t, this
    }, n.prototype._isResponseOK = function(t) {
        return !!t && (this._okCallback ? this._okCallback(t) : t.status >= 200 && t.status < 300)
    }, n.prototype.get = function(t) {
        return this._header[t.toLowerCase()]
    }, n.prototype.getHeader = n.prototype.get, n.prototype.set = function(t, e) {
        if (s(t)) {
            for (var i in t) this.set(i, t[i]);
            return this
        }
        return this._header[t.toLowerCase()] = e, this.header[t] = e, this
    }, n.prototype.unset = function(t) {
        return delete this._header[t.toLowerCase()], delete this.header[t], this
    }, n.prototype.field = function(t, e) {
        if (null === t || void 0 === t) throw new Error(".field(name, val) name can not be empty");
        if (this._data && console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"), s(t)) {
            for (var i in t) this.field(i, t[i]);
            return this
        }
        if (Array.isArray(e)) {
            for (var n in e) this.field(t, e[n]);
            return this
        }
        if (null === e || void 0 === e) throw new Error(".field(name, val) val can not be empty");
        return "boolean" == typeof e && (e = "" + e), this._getFormData().append(t, e), this
    }, n.prototype.abort = function() {
        return this._aborted ? this : (this._aborted = !0, this.xhr && this.xhr.abort(), this.req && this.req.abort(), this.clearTimeout(), this.emit("abort"), this)
    }, n.prototype._auth = function(t, e, i, n) {
        switch (i.type) {
            case "basic":
                this.set("Authorization", "Basic " + n(t + ":" + e));
                break;
            case "auto":
                this.username = t, this.password = e;
                break;
            case "bearer":
                this.set("Authorization", "Bearer " + t)
        }
        return this
    }, n.prototype.withCredentials = function(t) {
        return void 0 == t && (t = !0), this._withCredentials = t, this
    }, n.prototype.redirects = function(t) {
        return this._maxRedirects = t, this
    }, n.prototype.maxResponseSize = function(t) {
        if ("number" != typeof t) throw TypeError("Invalid argument");
        return this._maxResponseSize = t, this
    }, n.prototype.toJSON = function() {
        return {
            method: this.method,
            url: this.url,
            data: this._data,
            headers: this._header
        }
    }, n.prototype.send = function(t) {
        var e = s(t),
            i = this._header["content-type"];
        if (this._formData && console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"), e && !this._data) Array.isArray(t) ? this._data = [] : this._isHost(t) || (this._data = {});
        else if (t && this._data && this._isHost(this._data)) throw Error("Can't merge these send calls");
        if (e && s(this._data))
            for (var n in t) this._data[n] = t[n];
        else "string" == typeof t ? (i || this.type("form"), i = this._header["content-type"], this._data = "application/x-www-form-urlencoded" == i ? this._data ? this._data + "&" + t : t : (this._data || "") + t) : this._data = t;
        return !e || this._isHost(t) ? this : (i || this.type("json"), this)
    }, n.prototype.sortQuery = function(t) {
        return this._sort = void 0 === t || t, this
    }, n.prototype._finalizeQueryString = function() {
        var t = this._query.join("&");
        if (t && (this.url += (this.url.indexOf("?") >= 0 ? "&" : "?") + t), this._query.length = 0, this._sort) {
            var e = this.url.indexOf("?");
            if (e >= 0) {
                var i = this.url.substring(e + 1).split("&");
                "function" == typeof this._sort ? i.sort(this._sort) : i.sort(), this.url = this.url.substring(0, e) + "?" + i.join("&")
            }
        }
    }, n.prototype._appendQueryString = function() {
        console.trace("Unsupported")
    }, n.prototype._timeoutError = function(t, e, i) {
        if (!this._aborted) {
            var n = new Error(t + e + "ms exceeded");
            n.timeout = e, n.code = "ECONNABORTED", n.errno = i, this.timedout = !0, this.abort(), this.callback(n)
        }
    }, n.prototype._setTimeouts = function() {
        var t = this;
        this._timeout && !this._timer && (this._timer = setTimeout(function() {
            t._timeoutError("Timeout of ", t._timeout, "ETIME")
        }, this._timeout)), this._responseTimeout && !this._responseTimeoutTimer && (this._responseTimeoutTimer = setTimeout(function() {
            t._timeoutError("Response timeout of ", t._responseTimeout, "ETIMEDOUT")
        }, this._responseTimeout))
    }
}, function(t, e, i) {
    "use strict";

    function n(t) {
        if (t) return r(t)
    }

    function r(t) {
        for (var e in n.prototype) t[e] = n.prototype[e];
        return t
    }
    var s = i(17);
    t.exports = n, n.prototype.get = function(t) {
        return this.header[t.toLowerCase()]
    }, n.prototype._setHeaderProperties = function(t) {
        var e = t["content-type"] || "";
        this.type = s.type(e);
        var i = s.params(e);
        for (var n in i) this[n] = i[n];
        this.links = {};
        try {
            t.link && (this.links = s.parseLinks(t.link))
        } catch (t) {}
    }, n.prototype._setStatusProperties = function(t) {
        var e = t / 100 | 0;
        this.status = this.statusCode = t, this.statusType = e, this.info = 1 == e, this.ok = 2 == e, this.redirect = 3 == e, this.clientError = 4 == e, this.serverError = 5 == e, this.error = (4 == e || 5 == e) && this.toError(), this.accepted = 202 == t, this.noContent = 204 == t, this.badRequest = 400 == t, this.unauthorized = 401 == t, this.notAcceptable = 406 == t, this.forbidden = 403 == t, this.notFound = 404 == t
    }
}, function(t, e, i) {
    "use strict";
    e.type = function(t) {
        return t.split(/ *; */).shift()
    }, e.params = function(t) {
        return t.split(/ *; */).reduce(function(t, e) {
            var i = e.split(/ *= */),
                n = i.shift(),
                r = i.shift();
            return n && r && (t[n] = r), t
        }, {})
    }, e.parseLinks = function(t) {
        return t.split(/ *, */).reduce(function(t, e) {
            var i = e.split(/ *; */),
                n = i[0].slice(1, -1);
            return t[i[1].split(/ *= */)[1].slice(1, -1)] = n, t
        }, {})
    }, e.cleanHeader = function(t, e) {
        return delete t["content-type"], delete t["content-length"], delete t["transfer-encoding"], delete t.host, e && delete t.cookie, t
    }
}, function(t, e) {
    function i() {
        this._defaults = []
    }["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function(t) {
        i.prototype[t] = function() {
            return this._defaults.push({
                fn: t,
                arguments: arguments
            }), this
        }
    }), i.prototype._setDefaults = function(t) {
        this._defaults.forEach(function(e) {
            t[e.fn].apply(t, e.arguments)
        })
    }, t.exports = i
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        s = i(1),
        a = function(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(s),
        o = function() {
            function t() {
                n(this, t), this.$html = document.documentElement, this.$container = document.querySelector(".js-popin"), this.$contents = Array.from(this.$container.querySelectorAll(".js-content")), this.loadContents(), this.setTriggers(), this.setClose()
            }
            return r(t, [{
                key: "loadContents",
                value: function() {
                    var t = !0,
                        e = !1,
                        i = void 0;
                    try {
                        for (var n, r = this.$contents[Symbol.iterator](); !(t = (n = r.next()).done); t = !0) {
                            var s = n.value;
                            ! function(t) {
                                var e = t.dataset.contentUrl;
                                e && a.default.get(e).end(function(e, i) {
                                    t.querySelector(".inner").innerHTML = i.text
                                })
                            }(s)
                        }
                    } catch (t) {
                        e = !0, i = t
                    } finally {
                        try {
                            !t && r.return && r.return()
                        } finally {
                            if (e) throw i
                        }
                    }
                }
            }, {
                key: "setTriggers",
                value: function() {
                    var t = this;
                    this.$triggers = Array.from(document.querySelectorAll(".js-popin-trigger"));
                    var e = !0,
                        i = !1,
                        n = void 0;
                    try {
                        for (var r, s = this.$triggers[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                            var a = r.value;
                            ! function(e) {
                                e.addEventListener("click", function(i) {
                                    i.preventDefault(), t.open(e.dataset.popinName)
                                })
                            }(a)
                        }
                    } catch (t) {
                        i = !0, n = t
                    } finally {
                        try {
                            !e && s.return && s.return()
                        } finally {
                            if (i) throw n
                        }
                    }
                }
            }, {
                key: "setClose",
                value: function() {
                    var t = this;
                    this.$close = this.$container.querySelector(".js-close"), this.$close.addEventListener("click", function(e) {
                        e.preventDefault(), t.close()
                    }), window.addEventListener("keydown", function(e) {
                        27 === e.keyCode && t.close()
                    })
                }
            }, {
                key: "open",
                value: function(t) {
                    var e = null,
                        i = !0,
                        n = !1,
                        r = void 0;
                    try {
                        for (var s, a = this.$contents[Symbol.iterator](); !(i = (s = a.next()).done); i = !0) {
                            var o = s.value;
                            o.matches("." + t) ? e = o : o.classList.remove("active")
                        }
                    } catch (t) {
                        n = !0, r = t
                    } finally {
                        try {
                            !i && a.return && a.return()
                        } finally {
                            if (n) throw r
                        }
                    }
                    e && (e.scrollTop = 0, this.$container.classList.add("active"), this.$html.classList.remove("scrollable"), e.classList.add("active"))
                }
            }, {
                key: "close",
                value: function() {
                    this.$container.classList.remove("active"), this.$html.classList.add("scrollable");
                    var t = !0,
                        e = !1,
                        i = void 0;
                    try {
                        for (var n, r = this.$contents[Symbol.iterator](); !(t = (n = r.next()).done); t = !0) {
                            n.value.classList.remove("active")
                        }
                    } catch (t) {
                        e = !0, i = t
                    } finally {
                        try {
                            !t && r.return && r.return()
                        } finally {
                            if (e) throw i
                        }
                    }
                }
            }]), t
        }();
    e.default = o
}, function(t, e, i) {
    "use strict";

    function n(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }

    function r(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        a = i(0),
        o = function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(a),
        h = i(21),
        l = n(h),
        c = i(5),
        u = n(c),
        d = i(25),
        p = n(d),
        f = i(39),
        m = n(f),
        v = i(44),
        g = n(v),
        y = i(45),
        _ = n(y),
        x = function() {
            function t(e) {
                r(this, t), this.$canvas = e.canvas, this.isTouch = "ontouchstart" in window || navigator.msMaxTouchPoints > 0, this.isIOs = /iPad|iPhone|iPod/i.test(window.navigator.userAgent) && !window.MSStream, this.isAndroid = /android/i.test(window.navigator.userAgent), this.setMouse(), this.setOrientation(), this.setTime(), this.setSizes(), this.setScroll(), this.setRenderer(), this.setLava(), this.setPlanet(), this.setComposer(), this.update(), this.sizes.update(), this.scroll.update()
            }
            return s(t, [{
                key: "setMouse",
                value: function() {
                    var t = this;
                    this.mouse = {}, this.mouse.x = 0, this.mouse.y = 0, this.mouse.ratio = {}, this.mouse.ratio.x = 0, this.mouse.ratio.y = 0, this.mouse.ratioToCenter = {}, this.mouse.ratioToCenter.x = 0, this.mouse.ratioToCenter.y = 0, this.mouse.ratioToCenter.speed = {}, this.mouse.ratioToCenter.speed.x = 0, this.mouse.ratioToCenter.speed.y = 0, this.mouse.target = {}, this.mouse.target.x = 0, this.mouse.target.y = 0, document.addEventListener("mousemove", function(e) {
                        t.mouse.target.x = e.clientX, t.mouse.target.y = e.clientY
                    }, !1)
                }
            }, {
                key: "setOrientation",
                value: function() {
                    var t = this;
                    this.orientation = {}, this.orientation.x = 0, this.orientation.y = 0, this.orientation.target = {}, this.orientation.target.x = 0, this.orientation.target.y = 0, this.isTouch && window.addEventListener("deviceorientation", function(e) {
                        switch (window.orientation) {
                            case 90:
                                t.orientation.target.x = .04 * e.beta, t.orientation.target.y = .02 * -e.gamma - .25 * Math.PI;
                                break;
                            case -90:
                                t.orientation.target.x = .04 * -e.beta, t.orientation.target.y = .02 * e.gamma - .25 * Math.PI;
                                break;
                            default:
                            case 0:
                                t.orientation.target.x = .03 * e.gamma, t.orientation.target.y = .02 * e.beta - .25 * Math.PI
                        }
                        t.orientation.target.x > .5 ? t.orientation.target.x = .5 : t.orientation.target.x < -.5 && (t.orientation.target.x = -.5), t.orientation.target.y > .5 ? t.orientation.target.y = .5 : t.orientation.target.y < -.5 && (t.orientation.target.y = -.5)
                    }, !1)
                }
            }, {
                key: "setTime",
                value: function() {
                    this.time = {}, this.time.start = +new Date, this.time.elapsed = 0, this.time.current = this.time.start, this.time.delta = 16
                }
            }, {
                key: "setSizes",
                value: function() {
                    var t = this;
                    this.sizes = {}, this.sizes.$sizer = document.querySelector(".sizer"), this.sizes.$width = this.sizes.$sizer.querySelector(".width"), this.sizes.$height = this.sizes.$sizer.querySelector(".height"), this.sizes.width = this.sizes.$width.offsetWidth, this.sizes.height = this.sizes.$height.offsetHeight, this.sizes.timeout = null, this.sizes.update = function() {
                        t.sizes.width = t.sizes.$width.offsetWidth, t.sizes.height = t.sizes.$height.offsetHeight, t.lava.resize(), t.planet.resize(), t.renderer.setSize(t.sizes.width, t.sizes.height), t.composer.setSize(t.sizes.width, t.sizes.height)
                    }, window.addEventListener("resize", function() {
                        t.sizes.timeout && (window.clearTimeout(t.sizes.timeout), t.sizes.timeout = null), t.sizes.timeout = window.setTimeout(function() {
                            t.sizes.update(), t.sizes.timeout = null
                        }, t.isIOs || t.isAndroid ? 500 : 200)
                    })
                }
            }, {
                key: "setScroll",
                value: function() {
                    var t = this;
                    this.scroll = {}, this.scroll.targetValue = 0, this.scroll.value = 0, this.scroll.ratio = 0, this.scroll.lavaRatio = 0, this.scroll.planetRatio = 0, this.scroll.update = function() {
                        t.scroll.targetValue = window.pageYOffset || document.documentElement.scrollTop
                    }, window.addEventListener("scroll", this.scroll.update, {
                        passive: !0
                    })
                }
            }, {
                key: "setRenderer",
                value: function() {
                    this.renderer = new o.WebGLRenderer({
                        canvas: this.$canvas,
                        antialias: !0,
                        alpha: !0
                    }), this.renderer.setPixelRatio(window.devicePixelRatio || 1)
                }
            }, {
                key: "setLava",
                value: function() {
                    this.lava = new p.default({
                        isTouch: this.isTouch,
                        sizes: this.sizes,
                        time: this.time,
                        renderer: this.renderer,
                        scroll: this.scroll,
                        mouse: this.mouse,
                        orientation: this.orientation
                    })
                }
            }, {
                key: "setPlanet",
                value: function() {
                    this.planet = new m.default({
                        isTouch: this.isTouch,
                        sizes: this.sizes,
                        time: this.time,
                        renderer: this.renderer,
                        scroll: this.scroll,
                        mouse: this.mouse,
                        orientation: this.orientation
                    })
                }
            }, {
                key: "setComposer",
                value: function() {
                    this.composer = new l.default(this.renderer), this.renderShaderPass = new u.default({
                        uniforms: {
                            uTextureLava: {
                                type: "t",
                                value: null
                            },
                            uTexturePlanet: {
                                type: "t",
                                value: null
                            },
                            uScroll: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: g.default,
                        fragmentShader: _.default
                    }), this.renderShaderPass.uniforms.uTextureLava.value = this.lava.renderTarget.texture, this.renderShaderPass.uniforms.uTexturePlanet.value = this.planet.renderTarget.texture, this.renderShaderPass.uniforms.uScroll.value = 0, this.renderShaderPass.renderToScreen = !0, this.composer.addPass(this.renderShaderPass)
                }
            }, {
                key: "update",
                value: function() {
                    var t = this;
                    this.requestAnimationFrame = window.requestAnimationFrame(function() {
                        t.update()
                    });
                    var e = +new Date;
                    this.time.elapsed = e - this.time.start, this.time.delta = e - this.time.current, this.time.current = e, this.time.delta > 60 && (this.time.delta = 60), this.mouse.x += .005 * (this.mouse.target.x - this.mouse.x) * this.time.delta, this.mouse.y += .005 * (this.mouse.target.y - this.mouse.y) * this.time.delta, this.mouse.ratio.x = this.mouse.x / this.sizes.width, this.mouse.ratio.y = this.mouse.y / this.sizes.height;
                    var i = this.mouse.ratio.x - .5,
                        n = this.mouse.ratio.y - .5;
                    this.mouse.ratioToCenter.speed.x = i - this.mouse.ratioToCenter.x, this.mouse.ratioToCenter.speed.y = n - this.mouse.ratioToCenter.y, this.mouse.ratioToCenter.x = i, this.mouse.ratioToCenter.y = n, this.orientation.x += .005 * (this.orientation.target.x - this.orientation.x) * this.time.delta, this.orientation.y += .005 * (this.orientation.target.y - this.orientation.y) * this.time.delta, this.isIOs ? this.scroll.value += .01 * (this.scroll.targetValue - this.scroll.value) * this.time.delta : this.scroll.value = this.scroll.targetValue, this.scroll.ratio = this.scroll.value / this.sizes.height, this.scroll.lavaRatio = this.scroll.ratio, this.scroll.planetRatio = this.scroll.ratio - 1, this.renderShaderPass.uniforms.uScroll.value = this.scroll.ratio, this.scroll.ratio < 3 ? (this.$canvas.classList.add("fixed"), this.$canvas.classList.remove("absolute")) : (this.$canvas.classList.add("absolute"), this.$canvas.classList.remove("fixed")), this.scroll.ratio < 1 && (this.renderer.setClearColor("rgb(69, 1, 150),1"), this.lava.update()), this.scroll.ratio < 3 && 0 !== this.scroll.ratio && (this.renderer.setClearColor("rgb(69, 1, 150),1"), this.planet.update()), this.composer.render()
                }
            }]), t
        }();
    e.default = x
}, function(t, e, i) {
    "use strict";

    function n(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(0),
        s = function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(r),
        a = i(5),
        o = n(a),
        h = i(22),
        l = n(h),
        c = i(23),
        u = n(c),
        d = i(24),
        p = n(d),
        f = function(t, e) {
            if (this.renderer = t, void 0 === e) {
                var i = {
                        minFilter: s.LinearFilter,
                        magFilter: s.LinearFilter,
                        format: s.RGBAFormat,
                        stencilBuffer: !1
                    },
                    n = t.getSize();
                e = new s.WebGLRenderTarget(n.width, n.height, i), e.texture.name = "EffectComposer.rt1"
            }
            this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.passes = [], void 0 === l.default && console.error("EffectComposer relies on CopyShader"), void 0 === o.default && console.error("EffectComposer relies on ShaderPass"), this.copyPass = new o.default(l.default)
        };
    Object.assign(f.prototype, {
        swapBuffers: function() {
            var t = this.readBuffer;
            this.readBuffer = this.writeBuffer, this.writeBuffer = t
        },
        addPass: function(t) {
            this.passes.push(t);
            var e = this.renderer.getSize();
            t.setSize(e.width, e.height)
        },
        insertPass: function(t, e) {
            this.passes.splice(e, 0, t)
        },
        render: function(t) {
            var e, i, n = !1,
                r = this.passes.length;
            for (i = 0; i < r; i++)
                if (e = this.passes[i], !1 !== e.enabled) {
                    if (e.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), e.needsSwap) {
                        if (n) {
                            var s = this.renderer.context;
                            s.stencilFunc(s.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), s.stencilFunc(s.EQUAL, 1, 4294967295)
                        }
                        this.swapBuffers()
                    }
                    void 0 !== u.default && (e instanceof u.default ? n = !0 : e instanceof p.default && (n = !1))
                }
        },
        reset: function(t) {
            if (void 0 === t) {
                var e = this.renderer.getSize();
                t = this.renderTarget1.clone(), t.setSize(e.width, e.height)
            }
            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
        },
        setSize: function(t, e) {
            this.renderTarget1.setSize(t, e), this.renderTarget2.setSize(t, e);
            for (var i = 0; i < this.passes.length; i++) this.passes[i].setSize(t, e)
        }
    }), e.default = f
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(0),
        r = (function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            e.default = t
        }(n), {
            uniforms: {
                tDiffuse: {
                    value: null
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
        });
    e.default = r
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(0),
        r = (function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            e.default = t
        }(n), i(2)),
        s = function(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(r),
        a = function(t, e) {
            s.default.call(this), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
        };
    a.prototype = Object.assign(Object.create(s.default.prototype), {
        constructor: a,
        render: function(t, e, i, n, r) {
            var s = t.context,
                a = t.state;
            a.buffers.color.setMask(!1), a.buffers.depth.setMask(!1), a.buffers.color.setLocked(!0), a.buffers.depth.setLocked(!0);
            var o, h;
            this.inverse ? (o = 0, h = 1) : (o = 1, h = 0), a.buffers.stencil.setTest(!0), a.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), a.buffers.stencil.setFunc(s.ALWAYS, o, 4294967295), a.buffers.stencil.setClear(h), t.render(this.scene, this.camera, i, this.clear), t.render(this.scene, this.camera, e, this.clear), a.buffers.color.setLocked(!1), a.buffers.depth.setLocked(!1), a.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), a.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP)
        }
    }), e.default = a
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(0),
        r = (function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            e.default = t
        }(n), i(2)),
        s = function(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(r),
        a = function() {
            s.default.call(this), this.needsSwap = !1
        };
    a.prototype = Object.create(s.default.prototype), Object.assign(a.prototype, {
        render: function(t, e, i, n, r) {
            t.state.buffers.stencil.setTest(!1)
        }
    }), e.default = a
}, function(t, e, i) {
    "use strict";

    function n(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }

    function r(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        a = i(0),
        o = function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(a),
        h = i(6),
        l = i(7),
        c = n(l),
        u = i(26),
        d = n(u),
        p = i(27),
        f = n(p),
        m = i(28),
        v = n(m),
        g = i(8),
        y = n(g),
        _ = i(9),
        x = n(_),
        b = i(29),
        w = n(b),
        T = i(30),
        M = n(T),
        E = i(31),
        S = n(E),
        A = i(32),
        P = n(A),
        R = i(33),
        C = n(R),
        L = i(34),
        O = n(L),
        I = i(35),
        D = n(I),
        z = i(36),
        U = n(z),
        N = i(37),
        k = n(N),
        F = i(38),
        B = n(F),
        G = function() {
            function t(e) {
                r(this, t), this.isTouch = e.isTouch, this.sizes = e.sizes, this.time = e.time, this.renderer = e.renderer, this.scroll = e.scroll, this.mouse = e.mouse, this.orientation = e.orientation, this.textureLoader = new o.TextureLoader, this.renderTarget = new o.WebGLRenderTarget(this.sizes.width, this.sizes.height, {
                    minFilter: o.LinearFilter,
                    magFilter: o.LinearFilter
                }), this.scene = new o.Scene, this.aspect = this.sizes.width / this.sizes.height, this.height = 1 / this.aspect, this.setCamera(), this.setFluid(), this.setModelBubble(), this.setBackground(), this.setBubbles(), this.setLogo()
            }
            return s(t, [{
                key: "resize",
                value: function() {
                    this.aspect = this.sizes.width / this.sizes.height, this.height = 1 / this.aspect, this.camera.top = .5 / this.aspect, this.camera.bottom = -.5 / this.aspect, this.camera.updateProjectionMatrix(), this.aspect > 1 ? (this.logo.mesh.scale.x = 1 / this.aspect * this.logo.scale, this.logo.mesh.scale.y = 1 / this.aspect * this.logo.scale, this.logo.mesh.scale.z = 1 / this.aspect * this.logo.scale, this.logo.meshBlur.scale.x = 1 / this.aspect * this.logo.scale, this.logo.meshBlur.scale.y = 1 / this.aspect * this.logo.scale, this.logo.meshBlur.scale.z = 1 / this.aspect * this.logo.scale) : (this.logo.mesh.scale.x = .8 * this.logo.scale, this.logo.mesh.scale.y = .8 * this.logo.scale, this.logo.mesh.scale.z = .8 * this.logo.scale, this.logo.meshBlur.scale.x = .8 * this.logo.scale, this.logo.meshBlur.scale.y = .8 * this.logo.scale, this.logo.meshBlur.scale.z = .8 * this.logo.scale), this.renderTarget.setSize(this.sizes.width * window.devicePixelRatio, this.sizes.height * window.devicePixelRatio)
                }
            }, {
                key: "setCamera",
                value: function() {
                    this.aspect = this.sizes.width / this.sizes.height, this.camera = new o.OrthographicCamera(-.5, .5, -.5 / this.aspect, .5 / this.aspect, .001, 1e3), this.camera.position.z -= 10, this.camera.lookAt(new o.Vector3(0, 0, 0))
                }
            }, {
                key: "setDummy",
                value: function() {
                    this.dummy = {}, this.dummy.geometry = new o.BoxGeometry(.25, .25, .25, 1, 1, 1), this.dummy.material = new o.MeshBasicMaterial({
                        color: 16777215,
                        wireframe: !0
                    }), this.dummy.mesh = new o.Mesh(this.dummy.geometry, this.dummy.material), this.scene.add(this.dummy.mesh)
                }
            }, {
                key: "setFluid",
                value: function() {
                    this.fluid = {}, this.fluid.simulation = new d.default, this.fluid.texture = new o.Texture(this.fluid.simulation.$canvas)
                }
            }, {
                key: "setBackground",
                value: function() {
                    this.background = {}, this.background.geometry = new o.PlaneGeometry(2, 2, 1, 1), this.background.material = new o.ShaderMaterial({
                        uniforms: {
                            uColorStart: {
                                value: new o.Color(16138817)
                            },
                            uColorEnd: {
                                value: new o.Color(13383735)
                            },
                            uAlpha: {
                                value: 1
                            },
                            uNoise: {
                                value: .05
                            },
                            uAmplitude: {
                                value: .15
                            },
                            uOffset: {
                                value: .025
                            }
                        },
                        vertexShader: y.default,
                        fragmentShader: x.default,
                        wireframe: !1,
                        transparent: !0
                    }), this.background.mesh = new o.Mesh(this.background.geometry, this.background.material), this.background.mesh.rotation.y = Math.PI, this.background.mesh.position.z = 100, this.scene.add(this.background.mesh)
                }
            }, {
                key: "setModelBubble",
                value: function() {
                    var t = this;
                    this.modelBubble = {}, this.modelBubble.speed = {}, this.modelBubble.speed.x = 0, this.modelBubble.speed.y = 0, this.modelBubble.current = null, this.modelBubble.container = new o.Object3D, this.scene.add(this.modelBubble.container), this.modelBubble.shadowMaterial = {}, this.modelBubble.shadowMaterial.controller = new o.ShaderMaterial({
                        uniforms: {
                            uFluid: {
                                value: this.fluid.texture
                            },
                            uAlpha: {
                                value: .11
                            },
                            uShadow: {
                                value: this.textureLoader.load(C.default)
                            }
                        },
                        vertexShader: S.default,
                        fragmentShader: P.default,
                        wireframe: !1,
                        transparent: !0
                    }), this.modelBubble.shadowMaterial.sword = new o.ShaderMaterial({
                        uniforms: {
                            uFluid: {
                                value: this.fluid.texture
                            },
                            uAlpha: {
                                value: .11
                            },
                            uShadow: {
                                value: this.textureLoader.load(O.default)
                            }
                        },
                        vertexShader: S.default,
                        fragmentShader: P.default,
                        wireframe: !1,
                        transparent: !0
                    }), this.modelBubble.shadowMaterial.mushroom = new o.ShaderMaterial({
                        uniforms: {
                            uFluid: {
                                value: this.fluid.texture
                            },
                            uAlpha: {
                                value: .11
                            },
                            uShadow: {
                                value: this.textureLoader.load(D.default)
                            }
                        },
                        vertexShader: S.default,
                        fragmentShader: P.default,
                        wireframe: !1,
                        transparent: !0
                    }), this.modelBubble.shadowGeometry = new o.PlaneGeometry(1, 1, 10, 10), this.modelBubble.reset = function() {
                        var e = 0;
                        if (null !== t.modelBubble.current)
                            for (e = t.modelBubble.current.index + 1, t.modelBubble.container.remove(t.modelBubble.current); t.modelBubble.current.children.length > 0;) t.modelBubble.current.remove(t.modelBubble.current.children[0]);
                        e >= t.modelBubble.meshes.length && (e = 0);
                        var i = t.modelBubble.meshes[e];
                        i.rotation.z = "sword" === i.name ? .25 * Math.PI : 0, i.position.z = Math.floor(t.bubbles.count * Math.random()) + .25, i.position.y = -t.height / 2 - .2, i.position.x = .75 * (Math.random() - .5), t.modelBubble.container.add(i), t.modelBubble.current = i, t.modelBubble.speed.x = 0, t.modelBubble.speed.y = 0;
                        var n = new o.Mesh(t.modelBubble.shadowGeometry, t.modelBubble.shadowMaterial[i.name]);
                        n.position.x = -.02, n.position.y = -.03, n.position.z = .15, n.scale.set(.55, .55, .55), n.rotation.y = Math.PI, "sword" === i.name && (n.rotation.z = .25 * Math.PI, n.position.x = -.035, n.position.y = 0), i.add(n)
                    }, this.modelBubble.material = new o.ShaderMaterial({
                        uniforms: {
                            uFluid: {
                                value: this.fluid.texture
                            },
                            uNoise: {
                                value: 0
                            },
                            uMatCap: {
                                value: this.textureLoader.load(U.default)
                            }
                        },
                        vertexShader: f.default,
                        fragmentShader: v.default,
                        wireframe: !1
                    }), (new c.default).load("./static/models/all-models.3ds", function(e) {
                        t.modelBubble.meshes = [], e.children = e.children.sort(function() {
                            return Math.random() - .5
                        });
                        for (var i in e.children) {
                            var n = e.children[i],
                                r = n.geometry;
                            r.scale(.1, .1, .1), r.rotateX(.5 * -Math.PI), r.rotateY(Math.PI);
                            var s = new o.Mesh(r, t.modelBubble.material);
                            s.index = parseInt(i), s.name = n.name, s.scale.x = .8, s.scale.y = .8, s.scale.z = .8, t.modelBubble.meshes.push(s)
                        }
                        t.modelBubble.reset(), t.modelBubble.current.position.x = .3
                    })
                }
            }, {
                key: "setBubbles",
                value: function() {
                    var t = this;
                    this.bubbles = {}, this.bubbles.scale = .15, this.bubbles.scales = [.01, .17, .1, .13], this.bubbles.positions = [
                        [-.1, -.1],
                        [-.1, .25],
                        [-.25, .05],
                        [-.2, -.5]
                    ], this.bubbles.maxScale = this.bubbles.scales.reduce(function(t, e) {
                        return t > e ? t : e
                    }), this.bubbles.count = 4, this.bubbles.sphereGeometry = new o.SphereGeometry(1, 64, 17);
                    var e = Math.floor(Math.round(.5 * this.bubbles.sphereGeometry.faces.length));
                    this.bubbles.sphereGeometry.faces = this.bubbles.sphereGeometry.faces.slice(0, e), this.bubbles.sphereGeometry.rotateX(.5 * -Math.PI), this.bubbles.sphereTexture = this.textureLoader.load(U.default, function() {
                        h.TweenLite.to(t.bubbles.sphereMaterial.uniforms.uAlpha, 1, {
                            value: 1
                        })
                    }), this.bubbles.sphereMaterial = new o.ShaderMaterial({
                        uniforms: {
                            uFluid: {
                                value: this.fluid.texture
                            },
                            uNoise: {
                                value: .04
                            },
                            uMatCap: {
                                value: this.bubbles.sphereTexture
                            },
                            uRandomSeed: {
                                value: Math.random()
                            },
                            uAlpha: {
                                value: 0
                            }
                        },
                        vertexShader: f.default,
                        fragmentShader: v.default,
                        wireframe: !1,
                        transparent: !0
                    }), this.bubbles.shadowGeometry = new o.PlaneGeometry(1, 1, 10, 10), this.bubbles.all = [];
                    for (var i = 0; i < this.bubbles.count; i++) ! function(e) {
                        var i = {};
                        i.speed = {}, i.speed.x = 0, i.speed.y = 0, i.index = e, i.container = new o.Object3D, t.scene.add(i.container), i.reset = function() {
                            i.scale = t.bubbles.scales[i.index % t.bubbles.scales.length] * (1 + .1 * (Math.random() - .5)), i.mesh.position.x = .7 * (Math.random() - .5), i.mesh.position.y = -t.height / 2 - i.scale, i.shadowMesh.material.uniforms.uAlphaStart.value = i.scale / t.bubbles.maxScale * .15, i.mesh.scale.x = i.scale, i.mesh.scale.y = i.scale, i.mesh.scale.z = i.scale
                        }, i.mesh = new o.Mesh(t.bubbles.sphereGeometry, t.bubbles.sphereMaterial), i.container.add(i.mesh), i.shadowMesh = new o.Mesh(t.bubbles.shadowGeometry, t.getShadowMaterial()), i.shadowMesh.position.y = -.3, i.shadowMesh.position.x = -.2, i.shadowMesh.scale.set(2.2, 2.2, 2.2), i.shadowMesh.rotation.y = Math.PI, i.mesh.add(i.shadowMesh), i.reset();
                        var n = t.bubbles.positions[e % t.bubbles.positions.length];
                        i.mesh.position.x = n[0], i.mesh.position.y = n[1] / t.aspect, i.mesh.position.z = e, t.bubbles.all.push(i)
                    }(i)
                }
            }, {
                key: "getShadowMaterial",
                value: function() {
                    return new o.ShaderMaterial({
                        uniforms: {
                            uFluid: {
                                value: this.fluid.texture
                            },
                            uNoise: {
                                value: .04
                            },
                            uRandomSeed: {
                                value: this.bubbles.sphereMaterial.uniforms.uRandomSeed.value
                            },
                            uColorStart: {
                                value: new o.Color(0)
                            },
                            uColorEnd: {
                                value: new o.Color(0)
                            },
                            uAlphaStart: {
                                value: .15
                            },
                            uAlphaEnd: {
                                value: 0
                            },
                            uAmplitude: {
                                value: .15
                            },
                            uOffset: {
                                value: .35
                            }
                        },
                        vertexShader: w.default,
                        fragmentShader: M.default,
                        wireframe: !1,
                        transparent: !0
                    })
                }
            }, {
                key: "setLogo",
                value: function() {
                    var t = this;
                    this.logo = {}, this.logo.scale = 1, this.logo.geometry = new o.PlaneGeometry(1, .25, 1, 1), this.logo.texture = this.textureLoader.load(k.default, function() {
                        h.TweenLite.to(t.logo.material, 1.5, {
                            opacity: 1,
                            delay: .5
                        })
                    }), this.logo.material = new o.MeshBasicMaterial({
                        map: this.logo.texture,
                        wireframe: !1,
                        transparent: !0,
                        opacity: 0
                    }), this.logo.textureBlur = this.textureLoader.load(B.default, function() {
                        h.TweenLite.to(t.logo.materialBlur, 1.5, {
                            opacity: .2,
                            delay: .5
                        })
                    }), this.logo.materialBlur = new o.MeshBasicMaterial({
                        color: 16734809,
                        map: this.logo.textureBlur,
                        wireframe: !1,
                        transparent: !0,
                        opacity: 0,
                        blending: o.AdditiveBlending
                    }), this.logo.mesh = new o.Mesh(this.logo.geometry, this.logo.material), this.logo.mesh.rotation.y = Math.PI, this.logo.mesh.scale.x = .8, this.logo.mesh.scale.y = .8, this.logo.mesh.scale.z = .8, this.logo.mesh.position.z = Math.floor(.9 * this.bubbles.count) - .5, this.scene.add(this.logo.mesh), this.logo.meshBlur = new o.Mesh(this.logo.geometry, this.logo.materialBlur), this.logo.meshBlur.rotation.y = Math.PI, this.logo.meshBlur.scale.x = .8, this.logo.meshBlur.scale.y = .8, this.logo.meshBlur.scale.z = .8, this.logo.meshBlur.position.z = -2, this.scene.add(this.logo.meshBlur)
                }
            }, {
                key: "update",
                value: function() {
                    this.dummy && (this.dummy.mesh.rotation.y += .01), this.background.mesh.position.x = 1 * this.mouse.ratioToCenter.x * .015, this.background.mesh.position.y = 1 * this.mouse.ratioToCenter.y * .015;
                    var t = 0,
                        e = 0;
                    this.isTouch ? (t = this.orientation.x, e = this.orientation.y / this.aspect + .5 * (1 - 1 / this.aspect)) : (t = this.mouse.ratio.x, e = this.mouse.ratio.y / this.aspect + .5 * (1 - 1 / this.aspect)), this.fluid.simulation.addInput(t, e), this.fluid.simulation.update(), this.fluid.texture.needsUpdate = !0;
                    for (var i in this.bubbles.all) {
                        var n = this.bubbles.all[i],
                            r = Math.abs(-n.mesh.position.x - this.mouse.ratioToCenter.x),
                            s = Math.abs(n.mesh.position.y + this.mouse.ratioToCenter.y / this.aspect);
                        if (Math.sqrt(Math.pow(r, 2) + Math.pow(s, 2)) < n.scale) {
                            var a = 1 - n.scale / this.bubbles.maxScale * .8;
                            n.speed.x = .01 * -this.mouse.ratioToCenter.speed.x * a, n.speed.y = .01 * -this.mouse.ratioToCenter.speed.y * a
                        }
                        n.speed.x *= .98, n.speed.y *= .98, n.mesh.position.x += n.speed.x * this.time.delta, n.mesh.position.y += n.speed.y * this.time.delta, n.mesh.position.y += 75e-5 * ((this.bubbles.all.length - n.index) / this.bubbles.all.length * .95 + .05), n.mesh.position.y > this.height / 2 + n.scale + .1 && n.reset()
                    }
                    if (this.modelBubble.current) {
                        var o = Math.abs(-this.modelBubble.current.position.x - this.mouse.ratioToCenter.x),
                            h = Math.abs(this.modelBubble.current.position.y + this.mouse.ratioToCenter.y);
                        Math.sqrt(Math.pow(o, 2) + Math.pow(h, 2)) < .2 && (this.modelBubble.speed.x = .003 * -this.mouse.ratioToCenter.speed.x, this.modelBubble.speed.y = .003 * -this.mouse.ratioToCenter.speed.y), this.modelBubble.speed.x *= .98, this.modelBubble.speed.y *= .98, this.modelBubble.current.position.x += this.modelBubble.speed.x * this.time.delta, this.modelBubble.current.position.y += this.modelBubble.speed.y * this.time.delta, this.modelBubble.current.position.y += 75e-5, this.modelBubble.current.position.y > this.height / 2 + .35 && this.modelBubble.reset()
                    }
                    this.camera.position.y = .65 * -this.scroll.lavaRatio, this.render()
                }
            }, {
                key: "render",
                value: function() {
                    this.renderer.render(this.scene, this.camera, this.renderTarget)
                }
            }]), t
        }();
    e.default = G
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        s = function() {
            function t() {
                n(this, t), this.time = (new Date).getTime(), this.gridResolution = 16, this.diffusionRate = 0, this.viscocity = .1, this.force = 2800, this.source = 300, this.gridResPlus1 = this.gridResolution + 1, this.gridResPlus2 = this.gridResolution + 2, this.bufferSize = this.gridResPlus2 * this.gridResPlus2, this.u = this.generateArray(0, this.bufferSize), this.v = this.generateArray(0, this.bufferSize), this.dens = this.generateArray(0, this.bufferSize), this.u_prev = this.generateArray(0, this.bufferSize), this.v_prev = this.generateArray(0, this.bufferSize), this.dens_prev = this.generateArray(0, this.bufferSize), this.mouse = {
                    x: 0,
                    y: 0
                }, this.mouseInput = {
                    x: 0,
                    y: 0
                }, this.delta = 1 / 60, this.$canvas = document.createElement("canvas"), this.$canvas.width = this.gridResolution, this.$canvas.height = this.gridResolution, this.context = this.$canvas.getContext("2d"), this.cwidth = this.$canvas.width, this.cheight = this.$canvas.height
            }
            return r(t, [{
                key: "generateArray",
                value: function(t, e) {
                    for (var i = []; i.length < e;) i.push(t);
                    return i
                }
            }, {
                key: "update",
                value: function() {
                    var t = (new Date).getTime(),
                        e = t - this.time;
                    e > 60 ? e = 60 : e < 16 && (e = 16), this.delta = e / 1e3, this.time = t, this.u_prev = this.generateArray(0, this.bufferSize), this.v_prev = this.generateArray(0, this.bufferSize), this.dens_prev = this.generateArray(0, this.bufferSize), this.inputStep(), this.velocityStep(), this.densityStep(), this.drawStep()
                }
            }, {
                key: "addInput",
                value: function(t, e) {
                    var i = t < 0 ? 0 : t > 1 ? 1 : t,
                        n = e < 0 ? 0 : e > 1 ? 1 : e;
                    this.mouseInput.x = i * this.gridResolution, this.mouseInput.y = n * this.gridResolution
                }
            }, {
                key: "inputStep",
                value: function() {
                    var t = Math.floor(this.mouse.x / this.cwidth * this.gridResPlus1),
                        e = Math.floor((this.cheight - this.mouse.y) / this.cheight * this.gridResPlus1);
                    this.u[this.IX(t, e)] = this.force * (this.mouseInput.x - this.mouse.x) * this.delta, this.v[this.IX(t, e)] = this.force * (this.mouseInput.y - this.mouse.y) * this.delta, this.mouse.x = this.mouseInput.x, this.mouse.y = this.mouseInput.y
                }
            }, {
                key: "drawStep",
                value: function() {
                    this.context.clearRect(0, 0, this.cwidth, this.cheight);
                    for (var t = this.context.getImageData(0, 0, this.cwidth, this.cheight), e = t.data, i = 0; i <= this.gridResolution; i++)
                        for (var n = 0; n <= this.gridResolution; n++) {
                            var r = (this.dens[this.IX(i, this.gridResolution - n)], this.u[this.IX(i, this.gridResolution - n)]),
                                s = this.v[this.IX(i, this.gridResolution - n)];
                            r = Math.min(255, r);
                            var a = 4 * (n * this.gridResolution + i),
                                o = 127.5 + 100 * r,
                                h = 127.5 + 100 * s;
                            e[a + 0] = o, e[a + 1] = h, e[a + 2] = 127.5, e[a + 3] = 255
                        }
                    this.context.putImageData(t, 0, 0)
                }
            }, {
                key: "IX",
                value: function(t, e) {
                    return this.gridResPlus2 * e + t
                }
            }, {
                key: "setBnd",
                value: function(t, e) {
                    for (var i = 1; i <= this.gridResolution; i++) {
                        var n = e[this.IX(1, i)],
                            r = e[this.IX(this.gridResolution, i)];
                        e[this.IX(0, i)] = 1 == t ? -n : n, e[this.IX(this.gridResPlus1, i)] = 1 == t ? -r : r, n = e[this.IX(i, 1)], r = e[this.IX(i, this.gridResolution)], e[this.IX(i, 0)] = 2 == t ? -n : n, e[this.IX(i, this.gridResPlus1)] = 2 == t ? -r : r
                    }
                    return e[this.IX(0, 0)] = .5 * (e[this.IX(1, 0)] + e[this.IX(0, 1)]), e[this.IX(0, this.gridResPlus1)] = .5 * (e[this.IX(1, this.gridResPlus1)] + e[this.IX(0, this.gridResolution)]), e[this.IX(this.gridResPlus1, 0)] = .5 * (e[this.IX(this.gridResolution, 0)] + e[this.IX(this.gridResPlus1, 1)]), e[this.IX(this.gridResPlus1, this.gridResPlus1)] = .5 * (e[this.IX(this.gridResolution, this.gridResPlus1)] + e[this.IX(this.gridResPlus1, this.gridResolution)]), e
                }
            }, {
                key: "linearSolve",
                value: function(t, e, i, n, r) {
                    for (var s = 1 / r, a = n, o = t, h = e, l = 0 === a ? 1 : 20, c = 0; c < l; c++)
                        for (var u = this.gridResolution; u > 0; --u)
                            for (var d = this.gridResolution; d > 0; --d) {
                                var p = this.IX(u, d),
                                    f = i[p];
                                if (0 != a) {
                                    var m = h[p - 1] + h[p + 1] + h[p - this.gridResPlus2] + h[p + this.gridResPlus2];
                                    f += a * m
                                }
                                h[p] = f * s
                            }
                    this.setBnd(o, e)
                }
            }, {
                key: "advect",
                value: function(t, e, i, n, r) {
                    var s, a, o, h, l, c, u, d, p, f, m;
                    m = this.delta * this.gridResolution;
                    for (var v = 1; v <= this.gridResolution; v++)
                        for (var g = 1; g <= this.gridResolution; g++) {
                            var y = this.IX(v, g);
                            l = v - m * n[y], c = g - m * r[y], l < .5 && (l = .5), l > this.gridResolution + .5 && (l = this.gridResolution + .5), s = Math.floor(l), o = s + 1, c < .5 && (c = .5), c > this.gridResolution + .5 && (c = this.gridResolution + .5), a = Math.floor(c), h = a + 1, p = l - s, u = 1 - p, f = c - a, d = 1 - f, e[y] = u * (d * i[this.IX(s, a)] + f * i[this.IX(s, h)]) + p * (d * i[this.IX(o, a)] + f * i[this.IX(o, h)])
                        }
                    this.setBnd(t, e)
                }
            }, {
                key: "diffuse",
                value: function(t, e, i, n) {
                    var r = this.delta * n * this.gridResolution * this.gridResolution;
                    this.linearSolve(t, e, i, r, 1 + 4 * r)
                }
            }, {
                key: "project",
                value: function() {
                    var t, e;
                    for (t = 1; t <= this.gridResolution; t++)
                        for (e = 1; e <= this.gridResolution; e++) this.v_prev[this.IX(t, e)] = -.5 * (this.u[this.IX(t + 1, e)] - this.u[this.IX(t - 1, e)] + this.v[this.IX(t, e + 1)] - this.v[this.IX(t, e - 1)]) / this.gridResolution, this.u_prev[this.IX(t, e)] = 0;
                    for (this.setBnd(0, this.v_prev), this.setBnd(0, this.u_prev), this.linearSolve(0, this.u_prev, this.v_prev, 1, 4), t = 1; t <= this.gridResolution; t++)
                        for (e = 1; e <= this.gridResolution; e++) this.u[this.IX(t, e)] -= .5 * this.gridResolution * (this.u_prev[this.IX(t + 1, e)] - this.u_prev[this.IX(t - 1, e)]), this.v[this.IX(t, e)] -= .5 * this.gridResolution * (this.u_prev[this.IX(t, e + 1)] - this.u_prev[this.IX(t, e - 1)]);
                    this.setBnd(1, this.u), this.setBnd(2, this.v)
                }
            }, {
                key: "densityStep",
                value: function() {
                    this.addSource(this.dens, this.dens_prev);
                    var t = this.dens_prev;
                    this.dens_prev = this.dens, this.dens = t, this.diffuse(0, this.dens, this.dens_prev, this.diffusionRate), t = this.dens_prev, this.dens_prev = this.dens, this.dens = t, this.advect(0, this.dens, this.dens_prev, this.u, this.v)
                }
            }, {
                key: "velocityStep",
                value: function() {
                    this.addSource(this.u, this.u_prev), this.addSource(this.v, this.v_prev);
                    var t = this.u_prev;
                    this.u_prev = this.u, this.u = t, this.diffuse(1, this.u, this.u_prev, this.viscocity), t = this.v_prev, this.v_prev = this.v, this.v = t, this.diffuse(2, this.v, this.v_prev, this.viscocity), this.project(), t = this.u_prev, this.u_prev = this.u, this.u = t, t = this.v_prev, this.v_prev = this.v, this.v = t, this.advect(1, this.u, this.u_prev, this.u_prev, this.v_prev), this.advect(2, this.v, this.v_prev, this.u_prev, this.v_prev), this.project()
                }
            }, {
                key: "addSource",
                value: function(t, e) {
                    for (var i = 0; i < this.bufferSize; i++) t[i] += this.delta * e[i]
                }
            }]), t
        }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "vec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nuniform sampler2D uFluid;\nuniform float uRandomSeed;\nuniform float uNoise;\n\nvarying vec2 vN;\n\nvec2 matcap(vec3 eye, vec3 normal)\n{\n    vec3 reflected = reflect(eye, normal);\n    float m = 2.8284271247461903 * sqrt(reflected.z + 1.0);\n    return reflected.xy / m + 0.5;\n}\n\nvoid main()\n{\n    vec4 newPosition = modelMatrix * vec4(position, 1.0);\n\n    // Matcap (for orthographic camera)\n    vec3 eye = vec3(0.0, 0.0, -1.0);\n    vec3 n = normalize(normalMatrix * normal);\n\n    vN = matcap(eye, n).xy;\n\n    // Perlin\n    float noise = snoise(vec3(newPosition.xy * 2.0, uRandomSeed)) + 0.5;\n    newPosition.x += noise * uNoise;\n\n    // Fluid\n    vec2 fluidUv = vec2(1.0 - (newPosition.x + 0.5), (newPosition.y + 0.5));\n    newPosition.x -= (texture2D(uFluid, fluidUv).r - 0.5) * 0.04;\n    newPosition.y -= (texture2D(uFluid, fluidUv).g - 0.5) * 0.04;\n\n    gl_Position = projectionMatrix * viewMatrix * newPosition;\n}\n"
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "float rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nuniform sampler2D uMatCap;\nuniform float uAlpha;\n\nvarying vec2 vN;\n\nvoid main()\n{\n    vec3 base = texture2D(uMatCap, vN).rgb;\n    base.r += (rand(vN) - 0.5) * 0.05;\n    gl_FragColor = vec4(base, uAlpha);\n}\n"
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "vec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nuniform sampler2D uFluid;\nuniform float uRandomSeed;\nuniform float uNoise;\n\nvarying vec2 vUv;\n\nvoid main()\n{\n    vec4 newPosition = modelMatrix * vec4(position, 1.0);\n\n    // Perlin\n    float noise = snoise(vec3(newPosition.xy * 2.0, uRandomSeed)) + 0.5;\n    newPosition.x += noise * uNoise;\n\n    // Fluid\n    vec2 fluidUv = vec2(1.0 - (newPosition.x + 0.5), (newPosition.y + 0.5));\n    newPosition.x -= (texture2D(uFluid, fluidUv).r - 0.5) * 0.04;\n    newPosition.y -= (texture2D(uFluid, fluidUv).g - 0.5) * 0.04;\n\n    // UV\n    vUv = uv;\n\n    gl_Position = projectionMatrix * viewMatrix * newPosition;\n}\n"
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "float rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nuniform vec3 uColorStart;\nuniform vec3 uColorEnd;\nuniform float uAlphaStart;\nuniform float uAlphaEnd;\nuniform float uNoise;\nuniform float uAmplitude;\nuniform float uOffset;\n\n\nvarying vec2 vUv;\n\nvoid main()\n{\n    // Distance\n    float progress = clamp(distance(vUv, vec2(0.5)) - uOffset, 0.0, 1.0);\n    progress /= uAmplitude;\n    progress = clamp(progress, 0.0, 1.0);\n    progress = clamp(progress, 0.0, 1.0);\n\n    // Noise\n    if(uNoise > 0.0)\n    {\n        progress += (rand(vUv) - 0.5) * uNoise;\n    }\n\n    // color\n    vec3 color = mix(uColorStart, uColorEnd, progress);\n\n    // Alpha\n    float alpha = mix(uAlphaStart, uAlphaEnd, progress);\n\n    gl_FragColor = vec4(color, alpha);\n}\n"
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "uniform sampler2D uFluid;\n\nvarying vec2 vUv;\n\nvoid main()\n{\n    vec4 newPosition = modelMatrix * vec4(position, 1.0);\n\n    // Fluid\n    vec2 fluidUv = vec2(1.0 - (newPosition.x + 0.5), (newPosition.y + 0.5));\n    newPosition.x -= (texture2D(uFluid, fluidUv).r - 0.5) * 0.04;\n    newPosition.y -= (texture2D(uFluid, fluidUv).g - 0.5) * 0.04;\n\n    // UV\n    vUv = uv;\n\n    gl_Position = projectionMatrix * viewMatrix * newPosition;\n}\n"
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "uniform sampler2D uShadow;\nuniform float uAlpha;\n\nvarying vec2 vUv;\n\nvoid main()\n{\n    float alpha = (1.0 - texture2D(uShadow, vUv).r) * uAlpha;\n    gl_FragColor = vec4(vec3(0.0), alpha);\n}\n"
}, function(t, e, i) {
    t.exports = i.p + "images/bubble-shadow-controller.848911cfcba76153d833a7f5e2f243ef.png"
}, function(t, e, i) {
    t.exports = i.p + "images/bubble-shadow-sword.93e393802a4feb6ef08927fe99fde9c1.png"
}, function(t, e, i) {
    t.exports = i.p + "images/bubble-shadow-mushroom.0528b938b89422cfe96c0ea2d1d7856d.png"
}, function(t, e, i) {
    t.exports = i.p + "images/demo.png"
}, function(t, e, i) {
    t.exports = i.p + "images/loaded-logo.93716e9f4138fa5fff1e5508747cf33b.png"
}, function(t, e, i) {
    t.exports = i.p + "images/loaded-logo-blur.f2b0413aa25e6d487c1e356d2f8177d1.png"
}, function(t, e, i) {
    "use strict";

    function n(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }

    function r(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        a = i(0),
        o = function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(a),
        h = i(6),
        l = i(7),
        c = n(l),
        u = i(40),
        d = n(u),
        p = i(8),
        f = n(p),
        m = i(9),
        v = n(m),
        g = i(41),
        y = n(g),
        _ = i(42),
        x = n(_),
        b = i(43),
        w = n(b),
        T = function() {
            function t(e) {
                r(this, t), this.isTouch = e.isTouch, this.sizes = e.sizes, this.time = e.time, this.renderer = e.renderer, this.scroll = e.scroll, this.mouse = e.mouse, this.orientation = e.orientation, this.textureLoader = new o.TextureLoader, this.renderTarget = new o.WebGLRenderTarget(this.sizes.width, this.sizes.height, {
                    minFilter: o.NearestFilter,
                    magFilter: o.NearestFilter
                }), this.scene = new o.Scene, this.container = new o.Object3D, this.scene.add(this.container), this.setCamera(), this.setLights(), this.setEarth(), this.setBackground(), this.setGlow(), this.setBubbles(), this.setStars(), this.setMosaic()
            }
            return s(t, [{
                key: "resize",
                value: function() {
                    this.aspect = this.sizes.width / this.sizes.height, this.camera.aspect = this.sizes.width / this.sizes.height, this.camera.updateProjectionMatrix(), this.sizes.width >= 600 ? (this.container.position.x = -.2, this.container.position.y = 0, this.container.scale.x = 1, this.container.scale.y = 1, this.container.scale.z = 1) : this.sizes.width >= 400 ? (this.container.position.x = 0, this.container.position.y = -.2, this.container.scale.x = .8, this.container.scale.y = .8, this.container.scale.z = .8) : (this.container.position.x = 0, this.container.position.y = -.3, this.container.scale.x = .6, this.container.scale.y = .6, this.container.scale.z = .6), this.mosaic.container.position.x = .25 * this.aspect, this.sizes.width >= 600 ? (this.mosaic.container.scale.x = 1, this.mosaic.container.scale.y = 1, this.mosaic.container.scale.z = 1) : (this.mosaic.container.scale.x = .6, this.mosaic.container.scale.y = .6, this.mosaic.container.scale.z = .6), this.renderTarget.setSize(this.sizes.width * window.devicePixelRatio, this.sizes.height * window.devicePixelRatio)
                }
            }, {
                key: "setCamera",
                value: function() {
                    this.aspect = this.sizes.width / this.sizes.height, this.cameraContainer = new o.Object3D, this.scene.add(this.cameraContainer), this.camera = new o.PerspectiveCamera(45, this.sizes.width / this.sizes.height, .001, 1e4), this.camera.position.z -= 1, this.camera.lookAt(new o.Vector3(0, 0, 0)), this.cameraContainer.add(this.camera)
                }
            }, {
                key: "setLights",
                value: function() {
                    this.lights = {}, this.lights.directional1 = new o.DirectionalLight(16270403, 2.5), this.lights.directional1.position.x = 1, this.lights.directional1.position.y = -1, this.lights.directional1.position.z = -.2, this.container.add(this.lights.directional1), this.lights.ambient = new o.AmbientLight(16777215, 1), this.container.add(this.lights.ambient)
                }
            }, {
                key: "setDummy",
                value: function() {
                    this.dummy = {}, this.dummy.geometry = new o.BoxGeometry(.25, .25, .25, 1, 1, 1), this.dummy.material = new o.MeshBasicMaterial({
                        color: 16777215,
                        wireframe: !0
                    }), this.dummy.mesh = new o.Mesh(this.dummy.geometry, this.dummy.material), this.scene.add(this.dummy.mesh)
                }
            }, {
                key: "setEarth",
                value: function() {
                    var t = this;
                    this.earth = {}, this.earth.container = new o.Object3D, this.earth.container.rotation.order = "ZXY", this.earth.container.rotation.x = -.4, this.container.add(this.earth.container), this.earth.ocean = {}, this.earth.ocean.geometry = new o.SphereGeometry(.2, 32, 32), this.earth.ocean.material = new o.MeshPhongMaterial({
                        color: 3285281,
                        shininess: 0
                    }), this.earth.ocean.mesh = new o.Mesh(this.earth.ocean.geometry, this.earth.ocean.material), this.earth.container.add(this.earth.ocean.mesh), this.earth.continents = {}, (new c.default).load("./static/models/earth-continents.3ds", function(e) {
                        t.earth.continents.geometry = e.children[0].geometry, t.earth.continents.geometry.scale(.00356, .00356, .00356), t.earth.continents.geometry.rotateZ(.5 * Math.PI), t.earth.continents.material = new o.MeshPhongMaterial({
                            color: 6172977,
                            shininess: 0
                        }), t.earth.continents.material.flatShading = !0, t.earth.continents.mesh = new o.Mesh(t.earth.continents.geometry, t.earth.continents.material), t.setHotspots(), t.earth.continents.mesh.geometry.dispose(), t.earth.continents.mesh.material.dispose()
                    }), this.earth.flatContinents = {}, this.earth.flatContinents.texture = this.textureLoader.load(w.default, function() {
                        t.earth.flatContinents.geometry = new o.SphereGeometry(.201, 32, 32), t.earth.flatContinents.material = new o.MeshPhongMaterial({
                            color: 4990502,
                            shininess: 0,
                            alphaMap: t.earth.flatContinents.texture,
                            transparent: !0,
                            opacity: 0
                        }), h.TweenLite.to(t.earth.flatContinents.material, 2, {
                            opacity: 1
                        }), t.earth.flatContinents.mesh = new o.Mesh(t.earth.flatContinents.geometry, t.earth.flatContinents.material), t.earth.flatContinents.mesh.rotation.y = .45 * Math.PI, t.earth.flatContinents.mesh.rotation.x = .05 * Math.PI, t.earth.container.add(t.earth.flatContinents.mesh)
                    })
                }
            }, {
                key: "setBackground",
                value: function() {
                    this.background = {}, this.background.geometry = new o.PlaneGeometry(.8, .8, 1, 1), this.background.material = new o.ShaderMaterial({
                        uniforms: {
                            uColorStart: {
                                value: new o.Color(13450042)
                            },
                            uColorEnd: {
                                value: new o.Color(2302498)
                            },
                            uAlphaStart: {
                                value: 1
                            },
                            uAlphaEnd: {
                                value: 1
                            },
                            uNoise: {
                                value: .1
                            },
                            uAmplitude: {
                                value: .5
                            },
                            uOffset: {
                                value: 0
                            }
                        },
                        vertexShader: f.default,
                        fragmentShader: v.default,
                        wireframe: !1,
                        transparent: !0
                    }), this.background.mesh = new o.Mesh(this.background.geometry, this.background.material), this.background.mesh.rotation.y = Math.PI, this.background.mesh.position.x = -.15, this.background.mesh.position.z = .5, this.background.mesh.position.y = 0, this.container.add(this.background.mesh)
                }
            }, {
                key: "setGlow",
                value: function() {
                    this.glow = {}, this.glow.geometry = new o.PlaneGeometry(.2, .2, 1, 1), this.glow.material = new o.ShaderMaterial({
                        uniforms: {
                            uColorStart: {
                                value: new o.Color(13450042)
                            },
                            uColorEnd: {
                                value: new o.Color(13450042)
                            },
                            uAlphaStart: {
                                value: .75
                            },
                            uAlphaEnd: {
                                value: 0
                            },
                            uNoise: {
                                value: .1
                            },
                            uAmplitude: {
                                value: .5
                            },
                            uOffset: {
                                value: 0
                            }
                        },
                        vertexShader: f.default,
                        fragmentShader: v.default,
                        wireframe: !1,
                        transparent: !0
                    }), this.glow.mesh = new o.Mesh(this.glow.geometry, this.glow.material), this.glow.mesh.rotation.y = Math.PI, this.container.add(this.glow.mesh)
                }
            }, {
                key: "setBubbles",
                value: function() {
                    this.bubbles = {}, this.bubbles.container = new o.Object3D, this.bubbles.container.rotation.order = "ZXY", this.bubbles.container.rotation.x = -.3, this.bubbles.container.rotation.z = -.3, this.container.add(this.bubbles.container), this.bubbles.count = 80, this.bubbles.scale = .009, this.bubbles.geometry = new o.SphereGeometry(1, 16, 16), this.bubbles.material = new o.MeshLambertMaterial({
                        color: 5319724
                    }), this.bubbles.all = [];
                    for (var t = 0; t < this.bubbles.count; t++) {
                        var e = t / this.bubbles.count,
                            i = {};
                        i.speed = {}, i.speed.x = 0, i.speed.y = 0, i.mesh = new o.Mesh(this.bubbles.geometry, this.bubbles.material), i.mesh.position.z = Math.sin(2 * Math.PI * e) * (.3 + .12 * (Math.random() - .5)), i.mesh.position.x = Math.cos(2 * Math.PI * e) * (.3 + .01 * (Math.random() - .5)), i.mesh.position.y = .1 * (Math.random() - .5), i.scale = Math.random(), i.scale > .95 && (i.scale *= 1.8), i.scale *= this.bubbles.scale, i.mesh.scale.x = i.scale, i.mesh.scale.y = i.scale, i.mesh.scale.z = i.scale, this.bubbles.container.add(i.mesh), this.bubbles.all.push(i)
                    }
                }
            }, {
                key: "setStars",
                value: function() {
                    this.stars = {}, this.stars.count = 40, this.stars.scale = .006;
                    var t = new d.default({
                        width: 16,
                        height: 16,
                        stops: [{
                            offset: 0,
                            value: "rgba(248, 68, 67, 1)"
                        }, {
                            offset: 1,
                            value: "rgba(248, 68, 67, 0)"
                        }]
                    });
                    this.stars.texture = new o.Texture(t.canvas), this.stars.texture.needsUpdate = !0, this.stars.geometry = new o.Geometry;
                    for (var e = 0; e < this.stars.count; e++) {
                        var i = new o.Vector3(1 * (Math.random() - .5), 1 * (Math.random() - .5), 1 * (Math.random() - .5));
                        this.stars.geometry.vertices.push(i)
                    }
                    this.stars.geometry.verticesNeedUpdate = !0, this.stars.material = new o.PointsMaterial({
                        size: .01,
                        map: this.stars.texture,
                        transparent: !0
                    }), this.stars.points = new o.Points(this.stars.geometry, this.stars.material), this.container.add(this.stars.points)
                }
            }, {
                key: "setHotspots",
                value: function() {
                    var t = this;
                    this.hotspots = {}, this.hotspots.raycaster = new o.Raycaster, this.hotspots.all = [], this.hotspots.container = new o.Object3D, this.earth.container.add(this.hotspots.container), this.hotspots.glowGeometry = new o.PlaneGeometry(.08, .08, 1, 1), this.hotspots.glowTexture = this.textureLoader.load(y.default), this.hotspots.glowMaterial = new o.MeshBasicMaterial({
                        map: this.hotspots.glowTexture,
                        wireframe: !1,
                        transparent: !0,
                        opacity: 0,
                        side: o.BackSide
                    }), this.hotspots.glowMaterial.depthWrite = !1, h.TweenLite.to(this.hotspots.glowMaterial, 2, {
                        opacity: .1,
                        delay: .5
                    }), this.hotspots.strokeGeometry = new o.PlaneGeometry(.0014, .0014, 1, 1), this.hotspots.strokeGeometry.translate(0, 7e-4, 0), this.hotspots.strokeMaterial = new o.MeshBasicMaterial({
                        color: 16270403,
                        wireframe: !1,
                        side: o.DoubleSide,
                        transparent: !0,
                        opacity: 0
                    }), h.TweenLite.to(this.hotspots.strokeMaterial, 2, {
                        opacity: 1,
                        delay: .5,
                        onComplete: function() {
                            t.hotspots.strokeMaterial.transparent = !1
                        }
                    }), this.hotspots.dotGeometry = new o.CircleGeometry(.0012, 8), this.hotspots.dotMaterial = new o.MeshBasicMaterial({
                        color: 16270403,
                        wireframe: !1,
                        side: o.DoubleSide,
                        transparent: !0,
                        opacity: 0
                    }), h.TweenLite.to(this.hotspots.dotMaterial, 2, {
                        opacity: 1,
                        delay: .5,
                        onComplete: function() {
                            t.hotspots.dotMaterial.transparent = !1
                        }
                    });
                    for (var e = function(e) {
                            var i = e.clone(),
                                n = new o.Vector3;
                            n.subVectors(new o.Vector3, i), n.normalize(), t.hotspots.raycaster.set(i, n);
                            var r = t.hotspots.raycaster.intersectObject(t.earth.continents.mesh);
                            if (r.length) {
                                var s = {},
                                    a = r[0].point;
                                a.normalize(), s.container = new o.Object3D, s.container.position.x = .201 * a.x, s.container.position.y = .201 * a.y, s.container.position.z = .201 * a.z, s.container.lookAt(new o.Vector3), t.hotspots.container.add(s.container), s.glowMesh = new o.Mesh(t.hotspots.glowGeometry, t.hotspots.glowMaterial), s.container.add(s.glowMesh), Math.random() > .8 && (s.strokeMesh = new o.Mesh(t.hotspots.strokeGeometry, t.hotspots.strokeMaterial), s.strokeMesh.rotation.x = .5 * -Math.PI, s.strokeMesh.scale.y = 70 * Math.random(), s.container.add(s.strokeMesh)), s.dotMesh = new o.Mesh(t.hotspots.dotGeometry, t.hotspots.dotMaterial), s.container.add(s.dotMesh), t.hotspots.all.push(s)
                            }
                        }; this.hotspots.all.length < 300;) {
                        var i = this.getRandomSphereVector(0, 0, 0, .4);
                        e(i);
                        for (var n = Math.floor(5 * Math.random()), r = 0; r < n; r++) i.x += .055 * (Math.random() - .5), i.y += .055 * (Math.random() - .5), i.z += .055 * (Math.random() - .5), e(i)
                    }
                }
            }, {
                key: "setMosaic",
                value: function() {
                    var t = this;
                    this.mosaic = {}, this.mosaic.container = new o.Object3D, this.mosaic.container.position.y = -.8, this.mosaic.container.position.x = .5 * this.aspect, this.scene.add(this.mosaic.container), this.mosaic.glowGeometry = new o.PlaneGeometry(1.6, 1.6, 1, 1), this.mosaic.glowMaterial = new o.ShaderMaterial({
                        uniforms: {
                            uColorStart: {
                                value: new o.Color(13450042)
                            },
                            uColorEnd: {
                                value: new o.Color(13450042)
                            },
                            uAlphaStart: {
                                value: 1
                            },
                            uAlphaEnd: {
                                value: 0
                            },
                            uNoise: {
                                value: .1
                            },
                            uAmplitude: {
                                value: .5
                            },
                            uOffset: {
                                value: 0
                            }
                        },
                        vertexShader: f.default,
                        fragmentShader: v.default,
                        wireframe: !1,
                        transparent: !0
                    }), this.mosaic.glowMesh = new o.Mesh(this.mosaic.glowGeometry, this.mosaic.glowMaterial), this.mosaic.glowMesh.rotation.y = Math.PI, this.mosaic.glowMesh.position.z = .1, this.mosaic.container.add(this.mosaic.glowMesh), this.mosaic.mosaicGeometry = new o.PlaneGeometry(1, 1, 1, 1);
                    var e = new d.default({
                        width: 1024,
                        height: 1024,
                        stops: [{
                            offset: 0,
                            value: "#ffffff"
                        }, {
                            offset: 1,
                            value: "#000000"
                        }]
                    });
                    this.mosaic.alphaTexture = new o.Texture(e.canvas), this.mosaic.alphaTexture.needsUpdate = !0, this.mosaic.mosaicTexture = this.textureLoader.load(x.default, function() {
                        t.mosaic.mosaicMaterial = new o.MeshBasicMaterial({
                            map: t.mosaic.mosaicTexture,
                            alphaMap: t.mosaic.alphaTexture,
                            transparent: !0,
                            opacity: 0
                        }), h.TweenLite.to(t.mosaic.mosaicMaterial, 1.5, {
                            opacity: 1
                        }), t.mosaic.mosaicMesh = new o.Mesh(t.mosaic.mosaicGeometry, t.mosaic.mosaicMaterial), t.mosaic.mosaicMesh.rotation.y = Math.PI, t.mosaic.container.add(t.mosaic.mosaicMesh)
                    })
                }
            }, {
                key: "getRandomSphereVector",
                value: function(t, e, i, n) {
                    var r = Math.random(),
                        s = Math.random(),
                        a = 2 * Math.PI * r,
                        h = Math.acos(2 * s - 1),
                        l = t + n * Math.sin(h) * Math.cos(a),
                        c = e + n * Math.sin(h) * Math.sin(a),
                        u = i + n * Math.cos(h);
                    return new o.Vector3(l, c, u)
                }
            }, {
                key: "update",
                value: function() {
                    this.dummy && (this.dummy.mesh.rotation.y += .01), this.isTouch ? (this.camera.position.x = .1 * this.orientation.x, this.camera.position.y = .1 * this.orientation.y) : (this.camera.position.x = .1 * -this.mouse.ratioToCenter.x, this.camera.position.y = .1 * -this.mouse.ratioToCenter.y), this.cameraContainer.position.y = .65 * -this.scroll.planetRatio, this.background.mesh.position.y = .5 * -this.cameraContainer.position.y, this.bubbles.container.rotation.y += 9e-5 * this.time.delta, this.earth.continents.mesh && (this.earth.container.rotation.y += 3e-5 * this.time.delta), this.render()
                }
            }, {
                key: "render",
                value: function() {
                    this.renderer.render(this.scene, this.camera, this.renderTarget)
                }
            }]), t
        }();
    e.default = T
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = function t() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        n(this, t), this.options = {}, this.options.width = e.width || 256, this.options.height = e.height || 256, this.options.stops = e.stops || [{
            offset: 0,
            value: "#ffffff"
        }, {
            offset: 1,
            value: "#000000"
        }], this.canvas = document.createElement("canvas"), this.canvas.width = this.options.width, this.canvas.height = this.options.height, this.context = this.canvas.getContext("2d");
        var i = this.context.createRadialGradient(.5 * this.canvas.width, .5 * this.canvas.width, 0, .5 * this.canvas.width, .5 * this.canvas.width, .5 * this.canvas.width),
            r = !0,
            s = !1,
            a = void 0;
        try {
            for (var o, h = this.options.stops[Symbol.iterator](); !(r = (o = h.next()).done); r = !0) {
                var l = o.value;
                i.addColorStop(l.offset, l.value)
            }
        } catch (t) {
            s = !0, a = t
        } finally {
            try {
                !r && h.return && h.return()
            } finally {
                if (s) throw a
            }
        }
        this.context.fillStyle = i, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)
    };
    e.default = r
}, function(t, e, i) {
    t.exports = i.p + "images/hotspot-glow.62d3ed589a05c3b3f04d8420f6bbc477.png"
}, function(t, e, i) {
    t.exports = i.p + "images/mosaic.8d0fb5d2c5c652ee869e81b6f6515ae2.jpg"
}, function(t, e, i) {
    t.exports = i.p + "images/earth-alpha-map.a3a97476f21f925fb6bfecc353b38f6c.jpg"
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "varying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = "\nuniform sampler2D uTextureLava;\nuniform sampler2D uTexturePlanet;\nuniform float uScroll;\n\nvarying vec2 vUv;\n\nvoid main()\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = vUv;\n\n    // Lava\n    if(vUv.y - uScroll > 0.0)\n    {\n        // uv.y -= uScroll * 0.5;\n        color = texture2D(uTextureLava, uv).rgb;\n    }\n    // Planet\n    else\n    {\n        // uv.y -= (uScroll - 1.0) * 0.5;\n        color = texture2D(uTexturePlanet, uv).rgb;\n    }\n\n    gl_FragColor = vec4(color, 1.0);\n}"
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        },
        s = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        a = i(1),
        o = function(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(a),
        h = function() {
            function t() {
                n(this, t), this.fetchData()
            }
            return s(t, [{
                key: "fetchData",
                value: function() {
                    o.default.get("./static/data/content.json").set("accept", "json").type("json").end(function(t, e) {
                        var i = e.body,
                            n = document.querySelectorAll(".js-binding");
                        for (var s in n) {
                            var a = n[s];
                            if (a instanceof HTMLElement) {
                                var o = a.dataset.bindingPath,
                                    h = o.split("."),
                                    l = !0,
                                    c = i;
                                for (var u in h) {
                                    var d = h[u],
                                        p = c[d];
                                    if (void 0 === p) {
                                        l = !1;
                                        break
                                    }
                                    c = p
                                }
                                if (l) {
                                    var f = {};
                                    if (f.html = null, f.attributes = {}, "object" === (void 0 === c ? "undefined" : r(c)))
                                        for (var m in c) "html" === m ? f.html = c[m] : f.attributes[m] = c[m];
                                    else "string" == typeof c && (f.html = c);
                                    null !== f.html && (a.innerHTML = f.html);
                                    for (var v in f.attributes) {
                                        var g = f.attributes[v];
                                        a.setAttribute(v, g)
                                    }
                                } else console.warn('DataBinding: "' + o + '" could not be found')
                            }
                        }
                    })
                }
            }]), t
        }();
    e.default = h
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        s = i(48),
        a = (function(t) {
            t && t.__esModule
        }(s), function() {
            function t(e) {
                var i = this;
                n(this, t), this.popin = e.popin, this.resize = this.resize.bind(this), this.scroll = this.scroll.bind(this), this.windowScroll = window.pageYOffset || document.documentElement.scrollTop, this.windowHeight = window.innerHeight, this.$container = document.querySelector(".js-navigation"), this.$sections = document.querySelectorAll(".js-navigation-section"), this.$dark = document.querySelector(".js-dark"), this.$darkInner = this.$dark.querySelector(".js-inner"), this.$light = document.querySelector(".js-light"), this.$lightInner = this.$light.querySelector(".js-inner"), this.setScrollDown(), this.setCaseStudyButtons(), this.setScrollTop(), this.setScrollToContact(), this.setSections(), window.addEventListener("resize", function() {
                    i.resize(), i.update()
                }, {
                    capture: !1,
                    passive: !0
                }), window.addEventListener("scroll", function() {
                    i.scroll(), i.update()
                }, {
                    capture: !1,
                    passive: !0
                }), window.setTimeout(function() {
                    i.resize(), i.scroll(), i.update()
                }, 20)
            }
            return r(t, [{
                key: "setCaseStudyButtons",
                value: function() {
                    var t = this;
                    this.$casestudyButtons = document.querySelectorAll(".js-scroll-to-casestudies");
                    var e = !0,
                        i = !1,
                        n = void 0;
                    try {
                        for (var r, s = this.$casestudyButtons[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                            r.value.addEventListener("click", function(e) {
                                e.preventDefault(), t.scrollTo(document.getElementById("newsletter").offsetTop, 1500)
                            })
                        }
                    } catch (t) {
                        i = !0, n = t
                    } finally {
                        try {
                            !e && s.return && s.return()
                        } finally {
                            if (i) throw n
                        }
                    }
                }
            }, {
                key: "setScrollDown",
                value: function() {
                    var t = this;
                    this.$scrollDowns = document.querySelectorAll(".js-scroll-down"), this.scrollDownActive = !0;
                    var e = !0,
                        i = !1,
                        n = void 0;
                    try {
                        for (var r, s = this.$scrollDowns[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                            var a = r.value;
                            a.addEventListener("mouseenter", function() {
                                var e = !0,
                                    i = !1,
                                    n = void 0;
                                try {
                                    for (var r, s = t.$scrollDowns[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                                        r.value.classList.add("hover")
                                    }
                                } catch (t) {
                                    i = !0, n = t
                                } finally {
                                    try {
                                        !e && s.return && s.return()
                                    } finally {
                                        if (i) throw n
                                    }
                                }
                            }), a.addEventListener("mouseleave", function() {
                                var e = !0,
                                    i = !1,
                                    n = void 0;
                                try {
                                    for (var r, s = t.$scrollDowns[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                                        r.value.classList.remove("hover")
                                    }
                                } catch (t) {
                                    i = !0, n = t
                                } finally {
                                    try {
                                        !e && s.return && s.return()
                                    } finally {
                                        if (i) throw n
                                    }
                                }
                            }), a.addEventListener("click", function(e) {
                                e.preventDefault(), t.sections.reverse();
                                var i = t.sections.find(function(e) {
                                    return t.windowScroll >= e.start - 1 && t.windowScroll < e.end
                                });
                                t.sections.reverse(), i && t.scrollTo(i.end, 1500)
                            })
                        }
                    } catch (t) {
                        i = !0, n = t
                    } finally {
                        try {
                            !e && s.return && s.return()
                        } finally {
                            if (i) throw n
                        }
                    }
                }
            }, {
                key: "setScrollTop",
                value: function() {
                    var t = this;
                    document.querySelector(".js-scroll-to-top").addEventListener("click", function(e) {
                        e.preventDefault(), t.scrollTo(0, 1500), t.popin.close()
                    })
                }
            }, {
                key: "setScrollToContact",
                value: function() {
                    var t = this;
                    this.$scrollToContacts = document.querySelectorAll(".js-scroll-to-contact");
                    var e = !0,
                        i = !1,
                        n = void 0;
                    try {
                        for (var r, s = this.$scrollToContacts[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                            var a = r.value;
                            a.addEventListener("mouseenter", function() {
                                var e = !0,
                                    i = !1,
                                    n = void 0;
                                try {
                                    for (var r, s = t.$scrollToContacts[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                                        r.value.classList.add("hover")
                                    }
                                } catch (t) {
                                    i = !0, n = t
                                } finally {
                                    try {
                                        !e && s.return && s.return()
                                    } finally {
                                        if (i) throw n
                                    }
                                }
                            }), a.addEventListener("mouseleave", function() {
                                var e = !0,
                                    i = !1,
                                    n = void 0;
                                try {
                                    for (var r, s = t.$scrollToContacts[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                                        r.value.classList.remove("hover")
                                    }
                                } catch (t) {
                                    i = !0, n = t
                                } finally {
                                    try {
                                        !e && s.return && s.return()
                                    } finally {
                                        if (i) throw n
                                    }
                                }
                            })
                        }
                    } catch (t) {
                        i = !0, n = t
                    } finally {
                        try {
                            !e && s.return && s.return()
                        } finally {
                            if (i) throw n
                        }
                    }
                }
            }, {
                key: "setSections",
                value: function() {
                    this.sections = [];
                    var t = !0,
                        e = !1,
                        i = void 0;
                    try {
                        for (var n, r = this.$sections[Symbol.iterator](); !(t = (n = r.next()).done); t = !0) {
                            var s = n.value,
                                a = {};
                            a.$element = s, a.start = a.$element.offsetTop, a.end = a.start + a.$element.offsetHeight, a.theme = s.dataset.sectionTheme, this.sections.push(a)
                        }
                    } catch (t) {
                        e = !0, i = t
                    } finally {
                        try {
                            !t && r.return && r.return()
                        } finally {
                            if (e) throw i
                        }
                    }
                }
            }, {
                key: "resize",
                value: function() {
                    var t = 0,
                        e = !0,
                        i = !1,
                        n = void 0;
                    try {
                        for (var r, s = this.sections[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                            var a = r.value;
                            a.index = t++, a.start = a.$element.offsetTop, a.height = a.$element.offsetHeight, a.end = a.start + a.height
                        }
                    } catch (t) {
                        i = !0, n = t
                    } finally {
                        try {
                            !e && s.return && s.return()
                        } finally {
                            if (i) throw n
                        }
                    }
                    this.windowHeight = window.innerHeight
                }
            }, {
                key: "scroll",
                value: function() {
                    this.windowScroll = window.pageYOffset || document.documentElement.scrollTop;
                    var t = this.sections[this.sections.length - 1];
                    if (this.windowScroll + this.windowHeight > t.end - 150) {
                        if (this.scrollDownActive) {
                            this.scrollDownActive = !1;
                            var e = !0,
                                i = !1,
                                n = void 0;
                            try {
                                for (var r, s = this.$scrollDowns[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                                    var a = r.value;
                                    a.classList.remove("active")
                                }
                            } catch (t) {
                                i = !0, n = t
                            } finally {
                                try {
                                    !e && s.return && s.return()
                                } finally {
                                    if (i) throw n
                                }
                            }
                        }
                    } else if (!this.scrollDownActive) {
                        this.scrollDownActive = !0;
                        var o = !0,
                            h = !1,
                            l = void 0;
                        try {
                            for (var c, u = this.$scrollDowns[Symbol.iterator](); !(o = (c = u.next()).done); o = !0) {
                                var d = c.value;
                                d.classList.add("active")
                            }
                        } catch (t) {
                            h = !0, l = t
                        } finally {
                            try {
                                !o && u.return && u.return()
                            } finally {
                                if (h) throw l
                            }
                        }
                    }
                }
            }, {
                key: "update",
                value: function() {
                    var t = this,
                        e = this.sections.find(function(e) {
                            return t.windowScroll >= e.start && t.windowScroll <= e.end
                        }),
                        i = this.sections.find(function(e) {
                            return t.windowScroll + t.windowHeight >= e.start && t.windowScroll + t.windowHeight <= e.end
                        }),
                        n = (e.start + e.height - this.windowScroll) / this.windowHeight;
                    if (n < 0 && (n = 1 - Math.abs(n)), e.theme === i.theme) {
                        var r = this["$" + e.theme],
                            s = this["$" + e.theme + "Inner"],
                            a = "dark" === e.theme ? "light" : "dark",
                            o = this["$" + a],
                            h = this["$" + a + "Inner"];
                        r.style.transform = "translateY(0%)", s.style.transform = "translateY(0%)", o.style.transform = "translateY(100%)", h.style.transform = "translateY(-100%)"
                    } else {
                        var l = this["$" + e.theme],
                            c = this["$" + e.theme + "Inner"],
                            u = this["$" + i.theme],
                            d = this["$" + i.theme + "Inner"];
                        l.style.transform = "translateY(" + 100 * (n - 1) + "%)", l.style.bottom = "0", l.style.top = "auto", c.style.transform = "translateY(" + 100 * -(n - 1) + "%)", u.style.transform = "translateY(" + 100 * n + "%)", u.style.top = "0", u.style.bototm = "auto", d.style.transform = "translateY(" + 100 * -n + "%)"
                    }
                }
            }, {
                key: "scrollTo",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2e3,
                        i = window.scrollY || document.documentElement.scrollTop,
                        n = 0,
                        r = Math.max(.1, Math.min(Math.abs(i - t) / e, .8)),
                        s = function(t) {
                            return (t /= .5) < 1 ? .5 * Math.pow(t, 5) : .5 * (Math.pow(t - 2, 5) + 2)
                        };
                    ! function e() {
                        n += 1 / 60;
                        var a = n / r,
                            o = s(a);
                        a < 1 ? (window.requestAnimationFrame(e), window.scrollTo(0, i + (t - i) * o)) : window.scrollTo(0, t)
                    }()
                }
            }]), t
        }());
    e.default = a
}, function(t, e, i) {
    (function(n) {
        var r, s, a, o = void 0 !== t && t.exports && void 0 !== n ? n : this || window;
        (o._gsQueue || (o._gsQueue = [])).push(function() {
                "use strict";
                var t = (o.document || {}).documentElement,
                    e = o,
                    i = function(i, n) {
                        var r = "x" === n ? "Width" : "Height",
                            s = "scroll" + r,
                            a = "client" + r,
                            o = document.body;
                        return i === e || i === t || i === o ? Math.max(t[s], o[s]) - (e["inner" + r] || t[a] || o[a]) : i[s] - i["offset" + r]
                    },
                    n = function(t) {
                        return "string" == typeof t && (t = TweenLite.selector(t)), t.length && t !== e && t[0] && t[0].style && !t.nodeType && (t = t[0]), t === e || t.nodeType && t.style ? t : null
                    },
                    r = function(i, n) {
                        var r = "scroll" + ("x" === n ? "Left" : "Top");
                        return i === e && (null != i.pageXOffset ? r = "page" + n.toUpperCase() + "Offset" : i = null != t[r] ? t : document.body),
                            function() {
                                return i[r]
                            }
                    },
                    s = function(i, s) {
                        var a = n(i).getBoundingClientRect(),
                            o = !s || s === e || s === document.body,
                            h = (o ? t : s).getBoundingClientRect(),
                            l = {
                                x: a.left - h.left,
                                y: a.top - h.top
                            };
                        return !o && s && (l.x += r(s, "x")(), l.y += r(s, "y")()), l
                    },
                    a = function(t, e, n) {
                        var r = typeof t;
                        return isNaN(t) ? "number" === r || "string" === r && "=" === t.charAt(1) ? t : "max" === t ? i(e, n) : Math.min(i(e, n), s(t, e)[n]) : parseFloat(t)
                    },
                    h = o._gsDefine.plugin({
                        propName: "scrollTo",
                        API: 2,
                        global: !0,
                        version: "1.9.0",
                        init: function(t, i, n) {
                            return this._wdw = t === e, this._target = t, this._tween = n, "object" != typeof i ? (i = {
                                y: i
                            }, "string" == typeof i.y && "max" !== i.y && "=" !== i.y.charAt(1) && (i.x = i.y)) : i.nodeType && (i = {
                                y: i,
                                x: i
                            }), this.vars = i, this._autoKill = !1 !== i.autoKill, this.getX = r(t, "x"), this.getY = r(t, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != i.x ? (this._addTween(this, "x", this.x, a(i.x, t, "x") - (i.offsetX || 0), "scrollTo_x", !0), this._overwriteProps.push("scrollTo_x")) : this.skipX = !0, null != i.y ? (this._addTween(this, "y", this.y, a(i.y, t, "y") - (i.offsetY || 0), "scrollTo_y", !0), this._overwriteProps.push("scrollTo_y")) : this.skipY = !0, !0
                        },
                        set: function(t) {
                            this._super.setRatio.call(this, t);
                            var n = this._wdw || !this.skipX ? this.getX() : this.xPrev,
                                r = this._wdw || !this.skipY ? this.getY() : this.yPrev,
                                s = r - this.yPrev,
                                a = n - this.xPrev,
                                o = h.autoKillThreshold;
                            this.x < 0 && (this.x = 0), this.y < 0 && (this.y = 0), this._autoKill && (!this.skipX && (a > o || a < -o) && n < i(this._target, "x") && (this.skipX = !0), !this.skipY && (s > o || s < -o) && r < i(this._target, "y") && (this.skipY = !0), this.skipX && this.skipY && (this._tween.kill(), this.vars.onAutoKill && this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []))), this._wdw ? e.scrollTo(this.skipX ? n : this.x, this.skipY ? r : this.y) : (this.skipY || (this._target.scrollTop = this.y), this.skipX || (this._target.scrollLeft = this.x)), this.xPrev = this.x, this.yPrev = this.y
                        }
                    }),
                    l = h.prototype;
                h.max = i, h.getOffset = s, h.buildGetter = r, h.autoKillThreshold = 7, l._kill = function(t) {
                    return t.scrollTo_x && (this.skipX = !0), t.scrollTo_y && (this.skipY = !0), this._super._kill.call(this, t)
                }
            }), o._gsDefine && o._gsQueue.pop()(),
            function(n) {
                "use strict";
                var h = function() {
                    return (o.GreenSockGlobals || o).ScrollToPlugin
                };
                void 0 !== t && t.exports ? (i(10), t.exports = h()) : (s = [i(10)], r = h, void 0 !== (a = "function" == typeof r ? r.apply(e, s) : r) && (t.exports = a))
            }()
    }).call(e, i(3))
}]);